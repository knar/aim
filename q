warning: LF will be replaced by CRLF in src/three.module.js.
The file will have its original line endings in your working directory
[1mdiff --git a/package-lock.json b/package-lock.json[m
[1mindex 498d315..34ff3fb 100644[m
[1m--- a/package-lock.json[m
[1m+++ b/package-lock.json[m
[36m@@ -4672,9 +4672,9 @@[m
       }[m
     },[m
     "minimist": {[m
[31m-      "version": "1.2.0",[m
[31m-      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.0.tgz",[m
[31m-      "integrity": "sha1-o1AIsg9BOD7sH7kU9M1d95omQoQ=",[m
[32m+[m[32m      "version": "1.2.5",[m
[32m+[m[32m      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.5.tgz",[m
[32m+[m[32m      "integrity": "sha512-FM9nNUYrRBAELZQT3xeZQ7fmMOBg6nWNmJKTcgsJeaLstP/UODVpGsr5OhXhhXg6f+qtJ8uiZ+PUxkDWcgIXLw==",[m
       "dev": true[m
     },[m
     "mississippi": {[m
[1mdiff --git a/src/aim.js b/src/aim.js[m
[1mindex 1900f3a..77ff388 100644[m
[1m--- a/src/aim.js[m
[1m+++ b/src/aim.js[m
[36m@@ -7,6 +7,7 @@[m [mlet three_canvas[m
 let renderer[m
 let scene[m
 let camera[m
[32m+[m[32mlet raycaster[m
 let has_focus[m
 let hud_canvas[m
 let hud_context[m
[36m@@ -33,12 +34,12 @@[m [mconst wall_w = 100[m
 const wall_h = 200[m
 const wall_d = 200[m
 const t_box = {[m
[31m-	minX: -19/20 * wall_w,[m
[31m-	maxX: 19/20 * wall_w,[m
[31m-	minY: 1/20 * wall_h,[m
[31m-	maxY: 19/20 * wall_h,[m
[31m-	minZ: -wall_d + 20,[m
[31m-	maxZ: -wall_d + 20,[m
[32m+[m	[32mminX: -wall_w + 10,[m
[32m+[m	[32mmaxX: wall_w - 10,[m
[32m+[m	[32mminY: 10,[m
[32m+[m	[32mmaxY: wall_h - 10,[m
[32m+[m	[32mminZ: -wall_d + 10,[m
[32m+[m	[32mmaxZ: -wall_d + 10,[m
 }[m
 const box = {[m
 	minX: -wall_w,[m
[36m@@ -47,9 +48,11 @@[m [mconst box = {[m
 	maxZ: 10,[m
 }[m
 [m
[32m+[m[32mlet last_target_pos = { x: 0, y: 1/2 * wall_h, z: (t_box.minZ + t_box.maxZ) / 2 }[m
[32m+[m
 let start_time[m
 let time_left[m
[31m-let score[m
[32m+[m[32mlet hits[m
 let shots_fired[m
 [m
 let frame_times = [][m
[36m@@ -85,9 +88,10 @@[m [mfunction canvas_setup() {[m
 [m
 	// camera[m
 	const aspect = three_canvas.width / three_canvas.height[m
[31m-	camera = new three.PerspectiveCamera(horzToVertFov(config.fov, aspect), aspect, 0.1, 300)[m
[32m+[m	[32mcamera = new three.PerspectiveCamera(horzToVertFov(config.fov, aspect), aspect, 0.1, 3000)[m
 [m
 	camera.position.y = wall_h / 2[m
[32m+[m	[32mcamera.position.z = -7[m
 	camera.quaternion.setFromEuler(new three.Euler(aim.pitch, aim.yaw, 0, 'YXZ'))[m
 [m
 	// renderer[m
[36m@@ -101,20 +105,22 @@[m [mfunction canvas_setup() {[m
 [m
 	// scene setup[m
 	scene = new three.Scene()[m
[31m-	scene.background = new three.Color(0x0f1417)[m
[32m+[m	[32m//scene.background = new three.Color(0x1c2227)[m
[32m+[m	[32mscene.background = new three.Color(0x000)[m
 [m
 	scene.add(gen_floor_mesh())[m
 	scene.add(gen_wall_mesh())[m
 [m
[31m-	const ambient = new three.AmbientLight(0x444444, 1.6);[m
[32m+[m	[32mconst ambient = new three.AmbientLight(0xffffff, 0.2);[m
 	scene.add(ambient);[m
 [m
[31m-	const light = new three.SpotLight( 0xffffff, 1, 0, Math.PI / 16, 0.3, 10)[m
[31m-	light.target.position.set(0, 0, -wall_d)[m
[31m-	light.position.set(-100, wall_d * 4, 100)[m
[32m+[m	[32mconst light = new three.SpotLight( 0xffffff, 1.0, 0, Math.PI / 8, 0.5, 2)[m
[32m+[m	[32mlight.target.position.set(0, wall_h / 2, -wall_d)[m
[32m+[m[41m	[m
[32m+[m	[32mlight.position.set(-3/4 * wall_w , wall_h * 4, wall_d * 2)[m
 	light.castShadow = true[m
 	light.shadow.camera.near = 500[m
[31m-	light.shadow.camera.far = 1000 [m
[32m+[m	[32mlight.shadow.camera.far = 1000[m
 	light.shadow.mapSize.width = 4096[m
 	light.shadow.mapSize.height = 4096[m
 	scene.add(light)[m
[36m@@ -127,7 +133,10 @@[m [mfunction canvas_setup() {[m
 	// add targets[m
 	targets = [][m
 	for (let i = 0; i < config.num_targets; i++)[m
[31m-		spawnTarget()[m
[32m+[m		[32mspawn_target()[m
[32m+[m
[32m+[m	[32m// raycaster[m
[32m+[m	[32mraycaster = new three.Raycaster()[m
 }[m
 [m
 function set_event_listeners() {[m
[36m@@ -169,7 +178,7 @@[m [mfunction resize() {[m
 [m
 function reset_game_vars() {[m
 	start_time = Date.now()[m
[31m-	score = 0[m
[32m+[m	[32mhits = 0[m
 	shots_fired = 0[m
 }[m
 [m
[36m@@ -190,10 +199,11 @@[m [mfunction loop(time) {[m
 	rafID = null[m
 	start_loop()[m
 	[m
[31m-	time_left = config.duration - (Date.now() - start_time)[m
[32m+[m	[32mtime_left = config.duration * 1000 - (Date.now() - start_time)[m
 	if (time_left < 0) {[m
 		stop_loop()[m
[31m-		console.log('Score: ' + score)[m
[32m+[m		[32mrender_hud()[m
[32m+[m		[32mdocument.exitPointerLock();[m
 		return[m
 	}[m
 [m
[36m@@ -206,6 +216,8 @@[m [mfunction loop(time) {[m
 	[m
 	update_pos(dt)[m
 [m
[32m+[m	[32mraycaster.setFromCamera(new three.Vector2(0, 0), camera)[m
[32m+[m
 	renderer.render(scene, camera)[m
 [m
 	const now = ~~(performance.now())[m
[36m@@ -215,77 +227,89 @@[m [mfunction loop(time) {[m
 	frame_times.push(now)[m
 	fps = frame_times.length[m
 	[m
[31m-	if (now - last_hud_render_time > 50) {[m
[32m+[m	[32mif (now - last_hud_render_time > 100) {[m
 		render_hud()[m
 		last_hud_render_time = now[m
 	}[m
 }[m
 [m
 function shoot() {[m
[31m-	const yaw = aim.yaw % two_pi[m
[31m-	const pitch = aim.pitch % two_pi[m
[31m-[m
[31m-	// unit vector[m
[31m-	const d = {[m
[31m-		x: -Math.sin(yaw) * Math.cos(pitch),[m
[31m-		y: Math.sin(pitch),[m
[31m-		z: -Math.cos(yaw) * Math.cos(pitch),[m
[31m-	}[m
[32m+[m	[32mconst intersects = raycaster.intersectObjects(targets.map(({ mesh }) => mesh))[m
[32m+[m	[32mshots_fired++[m
 [m
[32m+[m	[32mif (!intersects.length)[m
[32m+[m		[32mreturn[m
[32m+[m[41m	[m
 	for (let i = 0; i < targets.length; i++) {[m
[31m-		const t = targets[i][m
[31m-		const q = dist_3d({[m
[31m-			x1: t.x,[m
[31m-			y1: t.y,[m
[31m-			z1: t.z[m
[31m-		}, {[m
[31m-			x2: camera.position.x,[m
[31m-			y2: camera.position.y,[m
[31m-			z2: camera.position.z,[m
[31m-		})[m
[31m-		[m
[31m-		// potential hit point, on same z-plane as target checked[m
[31m-		const p = {[m
[31m-			x: d.x * q + camera.position.x,[m
[31m-			y: d.y * q + camera.position.y,[m
[31m-			z: d.z * q + camera.position.z,[m
[31m-		}[m
[31m-		[m
[31m-		// distance between potential hit point and middle of target[m
[31m-		const off = dist_2d(p.x, p.y, t.x, t.y)[m
[31m-[m
[31m-		if (off < config.target_radius) {[m
[32m+[m		[32mif (targets[i].mesh == intersects[0].object) {[m
 			scene.remove(targets[i].mesh)[m
 			targets.splice(i, 1)[m
[31m-			spawnTarget()[m
[31m-			score++[m
[32m+[m			[32mspawn_target()[m
[32m+[m			[32mhits++[m
 			break[m
 		}[m
 	}[m
[31m-[m
[31m-	shots_fired++[m
 }[m
 [m
[31m-function spawnTarget() {[m
[31m-	if (targets.length < config.num_targets) {[m
[31m-		const x = rand(t_box.minX, t_box.maxX)[m
[31m-		const y = rand(t_box.minY, t_box.maxY)[m
[31m-		const z = rand(t_box.minZ, t_box.maxZ)[m
[31m-		[m
[31m-		const mesh = gen_target_mesh({ x, y, z })[m
[31m-		const t = { x, y, z, mesh }[m
[31m-[m
[31m-		targets.push(t)[m
[31m-		scene.add(t.mesh)[m
[32m+[m[32mfunction spawn_target() {[m
[32m+[m	[32mif (targets.length >= config.num_targets)[m
[32m+[m		[32mreturn[m
 [m
[31m-		targets.sort((a, b) => b.z - a.z)[m
[32m+[m	[32mlet x, y, z[m
[32m+[m	[32mswitch (config.spawn_type) {[m
[32m+[m		[32mcase 'relative_xy_radius':[m
[32m+[m			[32mdo {[m
[32m+[m				[32mconst dist = rand(config.relative_min_distance, config.relative_max_distance)[m
[32m+[m				[32mconst theta = rand(0, two_pi)[m
[32m+[m				[32mx = last_target_pos.x + dist * Math.cos(theta)[m
[32m+[m				[32my = last_target_pos.y + dist * Math.sin(theta)[m
[32m+[m				[32mz = last_target_pos.z[m
[32m+[m			[32m}[m
[32m+[m			[32mwhile (!within_box(x, y, z, t_box.minX, t_box.minY, t_box.minZ, t_box.maxX, t_box.maxY, t_box.maxZ) || overlaps_targets(x, y, z))[m
[32m+[m			[32mbreak[m
[32m+[m		[32mdefault:[m
[32m+[m			[32mdo {[m
[32m+[m				[32mx = rand(t_box.minX, t_box.maxX)[m
[32m+[m				[32my = rand(t_box.minY, t_box.maxY)[m
[32m+[m				[32mz = rand(t_box.minZ, t_box.maxZ)[m
[32m+[m			[32m}[m
[32m+[m			[32mwhile (overlaps_targets(x, y, z))[m
 	}[m
[32m+[m	[32mconst mesh = gen_target_mesh({ x, y, z })[m
[32m+[m	[32mconst t = { x, y, z, mesh }[m
[32m+[m	[32mlast_target_pos = { x: x, y: y, z: z }[m
[32m+[m	[32mtargets.push(t)[m
[32m+[m	[32mscene.add(t.mesh)[m
 }[m
 [m
 function rand(min, max) {[m
 	return Math.random() * (max - min) + min[m
 }[m
 [m
[32m+[m[32mfunction overlaps_targets(x, y, z) {[m
[32m+[m	[32mfor (const t of targets) {[m
[32m+[m		[32mif (dist_3d(x, y, z, t.x, t.y, t.z) < 2 * config.target_radius)[m
[32m+[m			[32mreturn true[m
[32m+[m	[32m}[m
[32m+[m	[32mreturn false[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// whether or not the point {x1, y1, z1} is within the box[m
[32m+[m[32m// formed by corners {x2, y2, z2} and {x3, y3, z3}[m
[32m+[m[32m// edge inclusive[m
[32m+[m[32mfunction within_box(x1, y1, z1, x2, y2, z2, x3, y3, z3) {[m
[32m+[m	[32mif (x2 > x3)[m
[32m+[m		[32m[x2, x3] = [x3, x2][m
[32m+[m	[32mif (y2 > y3)[m
[32m+[m		[32m[y2, y3] = [y3, y2][m
[32m+[m	[32mif (z2 > z3)[m
[32m+[m		[32m[z2, z3] = [z3, z2][m
[32m+[m	[32m// TODO: swapperoo[m
[32m+[m	[32mif (x1 < x2 || y1 < y2 || z1 < z2 || x1 > x3 || y1 > y3 || z1 > z3)[m
[32m+[m		[32mreturn false[m
[32m+[m	[32mreturn true[m
[32m+[m[32m}[m
[32m+[m
 function dist_2d(x1, y1, x2, y2) {[m
 	const dx = Math.abs(x1 - x2)[m
 	const dy = Math.abs(y1 - y2)[m
[36m@@ -293,7 +317,7 @@[m [mfunction dist_2d(x1, y1, x2, y2) {[m
 	return Math.sqrt(dx*dx + dy+dy)[m
 }[m
 [m
[31m-function dist_3d({ x1, y1, z1 }, { x2, y2, z2 }) {[m
[32m+[m[32mfunction dist_3d(x1, y1, z1, x2, y2, z2) {[m
 	const dx = Math.abs(x1 - x2)[m
 	const dy = Math.abs(y1 - y2)[m
 	const dz = Math.abs(z1 - z2)[m
[36m@@ -302,8 +326,8 @@[m [mfunction dist_3d({ x1, y1, z1 }, { x2, y2, z2 }) {[m
 }[m
 [m
 function gen_target_mesh({ x, y, z }) {[m
[31m-	let geo = new three.SphereGeometry(config.target_radius, 16, 16)[m
[31m-	let mat = new three.MeshStandardMaterial({ color: 0xb211d3, metalness: 0.05 })[m
[32m+[m	[32mlet geo = new three.SphereGeometry(config.target_radius, 32, 32)[m
[32m+[m	[32mlet mat = new three.MeshStandardMaterial({ color: 0x0c6ae4, roughness: 0.8, metalness: 0.2 })[m
 	//let geo_dot = new three.CylinderGeometry(config.target_radius * 0.3, config.target_radius * 0.6, 1.5, 32)[m
 	//	.translate(0, 0.26, 0)[m
 	//let mat_dot = new three.MeshStandardMaterial({ color: 0xffffff, metalness: 0 })[m
[36m@@ -316,6 +340,7 @@[m [mfunction gen_target_mesh({ x, y, z }) {[m
 	m.position.x = x[m
 	m.position.y = y[m
 	m.position.z = z[m
[32m+[m	[32mm.castShadow = true[m
 	//m.children.forEach(c => c.castShadow = true)[m
 	[m
 	return m[m
[36m@@ -413,8 +438,10 @@[m [mfunction render_hud() {[m
 	hud_context.font = '30px Monospace'[m
 	hud_context.fillStyle = '#ffffff'[m
 	let time = (time_left / 1000).toFixed(1)[m
[31m-	let acc = parseFloat(score * 100 / shots_fired).toFixed(2)[m
[31m-	hud_context.fillText('Score: ' + score + ' | Acc: ' + acc + '% | Time: ' + time + ' | FPS: ' + fps, 10, 30)[m
[32m+[m	[32mlet acc = parseFloat(hits * 100 / shots_fired).toFixed(1)[m
[32m+[m	[32mlet hits_per_second = (hits / (config.duration - time_left / 1000)).toFixed(2)[m
[32m+[m	[32mlet effective_score = (hits * acc / 100).toFixed(1)[m
[32m+[m	[32mhud_context.fillText('Hits: ' + hits + ' | H/s: ' + hits_per_second + ' | Acc: ' + acc + '% | Eff: ' + effective_score + ' | Time: ' + time + ' | FPS: ' + fps, 10, 30)[m
 }[m
 [m
 function update_pos(dt) {[m
[1mdiff --git a/src/components/ConfigMenu.js b/src/components/ConfigMenu.js[m
[1mindex dbb7df0..8244e0a 100644[m
[1m--- a/src/components/ConfigMenu.js[m
[1m+++ b/src/components/ConfigMenu.js[m
[36m@@ -38,10 +38,29 @@[m [mfunction ConfigMenu({config, setConfig}) {[m
 		setConfig({...config, duration: event.target.value})[m
 	}[m
 [m
[32m+[m	[32m// const menuItems = [[m
[32m+[m	[32m// 	{ title: 'CM/Rev', configValue: 'cm_per_rev', },[m
[32m+[m	[32m// 	{ title: 'CM/Rev', configValue: 'cm_per_rev', },[m
[32m+[m	[32m// 	{ title: 'CM/Rev', configValue: 'cm_per_rev', },[m
[32m+[m	[32m// ][m
[32m+[m
 	const renderConfigMenu = () => {[m
 		return ([m
 			<div className="config-menu">[m
 				<h3>Feel</h3>[m
[32m+[m
[32m+[m				[32m{/* {menuItems.map(({title, configValue}) => ([m
[32m+[m					[32m<div className="config-entry">[m
[32m+[m						[32m<label>{title}</label>[m
[32m+[m						[32m<input[m
[32m+[m							[32mtype="number"[m
[32m+[m							[32mvalue={config[configValue]}[m
[32m+[m							[32monChange={ev => setConfig({...config, [configValue]: ev.target.value})}[m
[32m+[m							[32mstep="0.01"[m
[32m+[m						[32m/>[m
[32m+[m					[32m</div>[m
[32m+[m				[32m))} */}[m
[32m+[m
 				<div className="config-entry">[m
 					<label>CM/Rev:</label>[m
 					<input[m
[36m@@ -97,7 +116,6 @@[m [mfunction ConfigMenu({config, setConfig}) {[m
 						step="1"[m
 					/>[m
 				</div>[m
[31m-				<h3>yayya</h3>[m
 			</div>[m
 		)[m
 	}[m
[1mdiff --git a/src/components/configmenu.css b/src/components/configmenu.css[m
[1mindex a84be3f..dd088bf 100644[m
[1m--- a/src/components/configmenu.css[m
[1m+++ b/src/components/configmenu.css[m
[36m@@ -3,12 +3,13 @@[m
 	position: fixed;[m
 	bottom: 16px;[m
 	left: 16px;[m
[31m-	padding: 16px;[m
[31m-	border-radius: 12px;[m
[32m+[m	[32mpadding: 12px;[m
[32m+[m	[32mborder-radius: 2px;[m
 	background-color: white;[m
 	box-shadow: 0 0 10px black;[m
 	display: flex;[m
 	flex-direction: column;[m
[32m+[m	[32mfont-family: monospace;[m
 }[m
 [m
 .config-entry {[m
[36m@@ -28,4 +29,5 @@[m [mlabel {[m
 [m
 input {[m
 	width: 80px;[m
[32m+[m	[32mfont-family: monospace;[m
 }[m
[1mdiff --git a/src/default_config.js b/src/default_config.js[m
[1mindex 3c89380..f61f2dc 100644[m
[1m--- a/src/default_config.js[m
[1m+++ b/src/default_config.js[m
[36m@@ -3,11 +3,16 @@[m [mexport const default_config = {[m
 	cm_per_rev: 30.0,[m
 	dpi: 800,[m
 [m
[31m-	duration: 60 * 1000,[m
[31m-	num_targets: 2,[m
[31m-	target_radius: 2,[m
[32m+[m	[32mduration: 15,[m
[32m+[m	[32mnum_targets: 6,[m
[32m+[m	[32mtarget_radius: 8,[m
[32m+[m
[32m+[m	[32m//spawn_type: 'relative_xy_radius',[m
[32m+[m	[32mspawn_type: '',[m
[32m+[m	[32mrelative_min_distance: 20,[m
[32m+[m	[32mrelative_max_distance: 160,[m
 	[m
[31m-	move_speed: 0.025,[m
[32m+[m	[32mmove_speed: 0.2,[m
 [m
 	frame_rate_limit: 500,[m
 }[m
[1mdiff --git a/src/three.module.js b/src/three.module.js[m
[1mindex b8f3da1..50d7296 100644[m
[1m--- a/src/three.module.js[m
[1m+++ b/src/three.module.js[m
[36m@@ -91,7 +91,7 @@[m [mif ( Object.assign === undefined ) {[m
 [m
 }[m
 [m
[31m-var REVISION = '109';[m
[32m+[m[32mvar REVISION = '116dev';[m
 var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };[m
 var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };[m
 var CullFaceNone = 0;[m
[36m@@ -109,9 +109,6 @@[m [mvar BackSide = 1;[m
 var DoubleSide = 2;[m
 var FlatShading = 1;[m
 var SmoothShading = 2;[m
[31m-var NoColors = 0;[m
[31m-var FaceColors = 1;[m
[31m-var VertexColors = 2;[m
 var NoBlending = 0;[m
 var NormalBlending = 1;[m
 var AdditiveBlending = 2;[m
[36m@@ -194,6 +191,12 @@[m [mvar RGBEFormat = RGBAFormat;[m
 var DepthFormat = 1026;[m
 var DepthStencilFormat = 1027;[m
 var RedFormat = 1028;[m
[32m+[m[32mvar RedIntegerFormat = 1029;[m
[32m+[m[32mvar RGFormat = 1030;[m
[32m+[m[32mvar RGIntegerFormat = 1031;[m
[32m+[m[32mvar RGBIntegerFormat = 1032;[m
[32m+[m[32mvar RGBAIntegerFormat = 1033;[m
[32m+[m
 var RGB_S3TC_DXT1_Format = 33776;[m
 var RGBA_S3TC_DXT1_Format = 33777;[m
 var RGBA_S3TC_DXT3_Format = 33778;[m
[36m@@ -203,6 +206,8 @@[m [mvar RGB_PVRTC_2BPPV1_Format = 35841;[m
 var RGBA_PVRTC_4BPPV1_Format = 35842;[m
 var RGBA_PVRTC_2BPPV1_Format = 35843;[m
 var RGB_ETC1_Format = 36196;[m
[32m+[m[32mvar RGB_ETC2_Format = 37492;[m
[32m+[m[32mvar RGBA_ETC2_EAC_Format = 37496;[m
 var RGBA_ASTC_4x4_Format = 37808;[m
 var RGBA_ASTC_5x4_Format = 37809;[m
 var RGBA_ASTC_5x5_Format = 37810;[m
[36m@@ -217,6 +222,21 @@[m [mvar RGBA_ASTC_10x8_Format = 37818;[m
 var RGBA_ASTC_10x10_Format = 37819;[m
 var RGBA_ASTC_12x10_Format = 37820;[m
 var RGBA_ASTC_12x12_Format = 37821;[m
[32m+[m[32mvar RGBA_BPTC_Format = 36492;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_4x4_Format = 37840;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_5x4_Format = 37841;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_5x5_Format = 37842;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_6x5_Format = 37843;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_6x6_Format = 37844;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_8x5_Format = 37845;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_8x6_Format = 37846;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_8x8_Format = 37847;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_10x5_Format = 37848;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_10x6_Format = 37849;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_10x8_Format = 37850;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_10x10_Format = 37851;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_12x10_Format = 37852;[m
[32m+[m[32mvar SRGB8_ALPHA8_ASTC_12x12_Format = 37853;[m
 var LoopOnce = 2200;[m
 var LoopRepeat = 2201;[m
 var LoopPingPong = 2202;[m
[36m@@ -260,6 +280,16 @@[m [mvar NotEqualStencilFunc = 517;[m
 var GreaterEqualStencilFunc = 518;[m
 var AlwaysStencilFunc = 519;[m
 [m
[32m+[m[32mvar StaticDrawUsage = 35044;[m
[32m+[m[32mvar DynamicDrawUsage = 35048;[m
[32m+[m[32mvar StreamDrawUsage = 35040;[m
[32m+[m[32mvar StaticReadUsage = 35045;[m
[32m+[m[32mvar DynamicReadUsage = 35049;[m
[32m+[m[32mvar StreamReadUsage = 35041;[m
[32m+[m[32mvar StaticCopyUsage = 35046;[m
[32m+[m[32mvar DynamicCopyUsage = 35050;[m
[32m+[m[32mvar StreamCopyUsage = 35042;[m
[32m+[m
 /**[m
  * https://github.com/mrdoob/eventdispatcher.js/[m
  */[m
[36m@@ -330,6 +360,7 @@[m [mObject.assign( EventDispatcher.prototype, {[m
 [m
 			event.target = this;[m
 [m
[32m+[m			[32m// Make a copy, in case listeners are removed while iterating.[m
 			var array = listenerArray.slice( 0 );[m
 [m
 			for ( var i = 0, l = array.length; i < l; i ++ ) {[m
[36m@@ -347,6 +378,8 @@[m [mObject.assign( EventDispatcher.prototype, {[m
 /**[m
  * @author alteredq / http://alteredqualia.com/[m
  * @author mrdoob / http://mrdoob.com/[m
[32m+[m[32m * @author WestLangley / http://github.com/WestLangley[m
[32m+[m[32m * @author thezwap[m
  */[m
 [m
 var _lut = [];[m
[36m@@ -357,7 +390,7 @@[m [mfor ( var i = 0; i < 256; i ++ ) {[m
 [m
 }[m
 [m
[31m-var _Math = {[m
[32m+[m[32mvar MathUtils = {[m
 [m
 	DEG2RAD: Math.PI / 180,[m
 	RAD2DEG: 180 / Math.PI,[m
[36m@@ -461,13 +494,13 @@[m [mvar _Math = {[m
 [m
 	degToRad: function ( degrees ) {[m
 [m
[31m-		return degrees * _Math.DEG2RAD;[m
[32m+[m		[32mreturn degrees * MathUtils.DEG2RAD;[m
 [m
 	},[m
 [m
 	radToDeg: function ( radians ) {[m
 [m
[31m-		return radians * _Math.RAD2DEG;[m
[32m+[m		[32mreturn radians * MathUtils.RAD2DEG;[m
 [m
 	},[m
 [m
[36m@@ -487,6 +520,61 @@[m [mvar _Math = {[m
 [m
 		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );[m
 [m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32msetQuaternionFromProperEuler: function ( q, a, b, c, order ) {[m
[32m+[m
[32m+[m		[32m// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles[m
[32m+[m
[32m+[m		[32m// rotations are applied to the axes in the order specified by 'order'[m
[32m+[m		[32m// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'[m
[32m+[m		[32m// angles are in radians[m
[32m+[m
[32m+[m		[32mvar cos = Math.cos;[m
[32m+[m		[32mvar sin = Math.sin;[m
[32m+[m
[32m+[m		[32mvar c2 = cos( b / 2 );[m
[32m+[m		[32mvar s2 = sin( b / 2 );[m
[32m+[m
[32m+[m		[32mvar c13 = cos( ( a + c ) / 2 );[m
[32m+[m		[32mvar s13 = sin( ( a + c ) / 2 );[m
[32m+[m
[32m+[m		[32mvar c1_3 = cos( ( a - c ) / 2 );[m
[32m+[m		[32mvar s1_3 = sin( ( a - c ) / 2 );[m
[32m+[m
[32m+[m		[32mvar c3_1 = cos( ( c - a ) / 2 );[m
[32m+[m		[32mvar s3_1 = sin( ( c - a ) / 2 );[m
[32m+[m
[32m+[m		[32mif ( order === 'XYX' ) {[m
[32m+[m
[32m+[m			[32mq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );[m
[32m+[m
[32m+[m		[32m} else if ( order === 'YZY' ) {[m
[32m+[m
[32m+[m			[32mq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );[m
[32m+[m
[32m+[m		[32m} else if ( order === 'ZXZ' ) {[m
[32m+[m
[32m+[m			[32mq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );[m
[32m+[m
[32m+[m		[32m} else if ( order === 'XZX' ) {[m
[32m+[m
[32m+[m			[32mq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );[m
[32m+[m
[32m+[m		[32m} else if ( order === 'YXY' ) {[m
[32m+[m
[32m+[m			[32mq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );[m
[32m+[m
[32m+[m		[32m} else if ( order === 'ZYZ' ) {[m
[32m+[m
[32m+[m			[32mq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );[m
[32m+[m
[32m+[m		[32m} else {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 	}[m
 [m
 };[m
[36m@@ -873,9 +961,7 @@[m [mObject.assign( Vector2.prototype, {[m
 [m
 		// computes the angle in radians with respect to the positive x-axis[m
 [m
[31m-		var angle = Math.atan2( this.y, this.x );[m
[31m-[m
[31m-		if ( angle < 0 ) angle += 2 * Math.PI;[m
[32m+[m		[32mvar angle = Math.atan2( - this.y, - this.x ) + Math.PI;[m
 [m
 		return angle;[m
 [m
[36m@@ -982,666 +1068,796 @@[m [mObject.assign( Vector2.prototype, {[m
 } );[m
 [m
 /**[m
[31m- * @author mikael emtinger / http://gomo.se/[m
  * @author alteredq / http://alteredqualia.com/[m
  * @author WestLangley / http://github.com/WestLangley[m
  * @author bhouston / http://clara.io[m
[32m+[m[32m * @author tschw[m
  */[m
 [m
[31m-function Quaternion( x, y, z, w ) {[m
[32m+[m[32mfunction Matrix3() {[m
 [m
[31m-	this._x = x || 0;[m
[31m-	this._y = y || 0;[m
[31m-	this._z = z || 0;[m
[31m-	this._w = ( w !== undefined ) ? w : 1;[m
[32m+[m	[32mthis.elements = [[m
 [m
[31m-}[m
[32m+[m		[32m1, 0, 0,[m
[32m+[m		[32m0, 1, 0,[m
[32m+[m		[32m0, 0, 1[m
 [m
[31m-Object.assign( Quaternion, {[m
[32m+[m	[32m];[m
 [m
[31m-	slerp: function ( qa, qb, qm, t ) {[m
[32m+[m	[32mif ( arguments.length > 0 ) {[m
 [m
[31m-		return qm.copy( qa ).slerp( qb, t );[m
[32m+[m		[32mconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );[m
 [m
[31m-	},[m
[32m+[m	[32m}[m
 [m
[31m-	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {[m
[32m+[m[32m}[m
 [m
[31m-		// fuzz-free, array-based Quaternion SLERP operation[m
[32m+[m[32mObject.assign( Matrix3.prototype, {[m
 [m
[31m-		var x0 = src0[ srcOffset0 + 0 ],[m
[31m-			y0 = src0[ srcOffset0 + 1 ],[m
[31m-			z0 = src0[ srcOffset0 + 2 ],[m
[31m-			w0 = src0[ srcOffset0 + 3 ],[m
[32m+[m	[32misMatrix3: true,[m
 [m
[31m-			x1 = src1[ srcOffset1 + 0 ],[m
[31m-			y1 = src1[ srcOffset1 + 1 ],[m
[31m-			z1 = src1[ srcOffset1 + 2 ],[m
[31m-			w1 = src1[ srcOffset1 + 3 ];[m
[32m+[m	[32mset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {[m
 [m
[31m-		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {[m
[32m+[m		[32mvar te = this.elements;[m
 [m
[31m-			var s = 1 - t,[m
[32m+[m		[32mte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;[m
[32m+[m		[32mte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;[m
[32m+[m		[32mte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;[m
 [m
[31m-				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,[m
[32m+[m		[32mreturn this;[m
 [m
[31m-				dir = ( cos >= 0 ? 1 : - 1 ),[m
[31m-				sqrSin = 1 - cos * cos;[m
[32m+[m	[32m},[m
 [m
[31m-			// Skip the Slerp for tiny steps to avoid numeric problems:[m
[31m-			if ( sqrSin > Number.EPSILON ) {[m
[32m+[m	[32midentity: function () {[m
 [m
[31m-				var sin = Math.sqrt( sqrSin ),[m
[31m-					len = Math.atan2( sin, cos * dir );[m
[32m+[m		[32mthis.set([m
 [m
[31m-				s = Math.sin( s * len ) / sin;[m
[31m-				t = Math.sin( t * len ) / sin;[m
[32m+[m			[32m1, 0, 0,[m
[32m+[m			[32m0, 1, 0,[m
[32m+[m			[32m0, 0, 1[m
 [m
[31m-			}[m
[32m+[m		[32m);[m
 [m
[31m-			var tDir = t * dir;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-			x0 = x0 * s + x1 * tDir;[m
[31m-			y0 = y0 * s + y1 * tDir;[m
[31m-			z0 = z0 * s + z1 * tDir;[m
[31m-			w0 = w0 * s + w1 * tDir;[m
[32m+[m	[32m},[m
 [m
[31m-			// Normalize in case we just did a lerp:[m
[31m-			if ( s === 1 - t ) {[m
[32m+[m	[32mclone: function () {[m
 [m
[31m-				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );[m
[32m+[m		[32mreturn new this.constructor().fromArray( this.elements );[m
 [m
[31m-				x0 *= f;[m
[31m-				y0 *= f;[m
[31m-				z0 *= f;[m
[31m-				w0 *= f;[m
[32m+[m	[32m},[m
 [m
[31m-			}[m
[32m+[m	[32mcopy: function ( m ) {[m
 [m
[31m-		}[m
[32m+[m		[32mvar te = this.elements;[m
[32m+[m		[32mvar me = m.elements;[m
 [m
[31m-		dst[ dstOffset ] = x0;[m
[31m-		dst[ dstOffset + 1 ] = y0;[m
[31m-		dst[ dstOffset + 2 ] = z0;[m
[31m-		dst[ dstOffset + 3 ] = w0;[m
[32m+[m		[32mte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];[m
[32m+[m		[32mte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];[m
[32m+[m		[32mte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];[m
 [m
[31m-	}[m
[32m+[m		[32mreturn this;[m
 [m
[31m-} );[m
[32m+[m	[32m},[m
 [m
[31m-Object.defineProperties( Quaternion.prototype, {[m
[32m+[m	[32mextractBasis: function ( xAxis, yAxis, zAxis ) {[m
 [m
[31m-	x: {[m
[32m+[m		[32mxAxis.setFromMatrix3Column( this, 0 );[m
[32m+[m		[32myAxis.setFromMatrix3Column( this, 1 );[m
[32m+[m		[32mzAxis.setFromMatrix3Column( this, 2 );[m
 [m
[31m-		get: function () {[m
[32m+[m		[32mreturn this;[m
 [m
[31m-			return this._x;[m
[32m+[m	[32m},[m
 [m
[31m-		},[m
[32m+[m	[32msetFromMatrix4: function ( m ) {[m
 [m
[31m-		set: function ( value ) {[m
[32m+[m		[32mvar me = m.elements;[m
 [m
[31m-			this._x = value;[m
[31m-			this._onChangeCallback();[m
[32m+[m		[32mthis.set([m
 [m
[31m-		}[m
[32m+[m			[32mme[ 0 ], me[ 4 ], me[ 8 ],[m
[32m+[m			[32mme[ 1 ], me[ 5 ], me[ 9 ],[m
[32m+[m			[32mme[ 2 ], me[ 6 ], me[ 10 ][m
 [m
[31m-	},[m
[32m+[m		[32m);[m
 [m
[31m-	y: {[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		get: function () {[m
[32m+[m	[32m},[m
 [m
[31m-			return this._y;[m
[32m+[m	[32mmultiply: function ( m ) {[m
 [m
[31m-		},[m
[32m+[m		[32mreturn this.multiplyMatrices( this, m );[m
 [m
[31m-		set: function ( value ) {[m
[32m+[m	[32m},[m
 [m
[31m-			this._y = value;[m
[31m-			this._onChangeCallback();[m
[32m+[m	[32mpremultiply: function ( m ) {[m
 [m
[31m-		}[m
[32m+[m		[32mreturn this.multiplyMatrices( m, this );[m
 [m
 	},[m
 [m
[31m-	z: {[m
[32m+[m	[32mmultiplyMatrices: function ( a, b ) {[m
 [m
[31m-		get: function () {[m
[32m+[m		[32mvar ae = a.elements;[m
[32m+[m		[32mvar be = b.elements;[m
[32m+[m		[32mvar te = this.elements;[m
 [m
[31m-			return this._z;[m
[32m+[m		[32mvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];[m
[32m+[m		[32mvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];[m
[32m+[m		[32mvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];[m
 [m
[31m-		},[m
[32m+[m		[32mvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];[m
[32m+[m		[32mvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];[m
[32m+[m		[32mvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];[m
 [m
[31m-		set: function ( value ) {[m
[32m+[m		[32mte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;[m
[32m+[m		[32mte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;[m
[32m+[m		[32mte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;[m
 [m
[31m-			this._z = value;[m
[31m-			this._onChangeCallback();[m
[32m+[m		[32mte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;[m
[32m+[m		[32mte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;[m
[32m+[m		[32mte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;[m
 [m
[31m-		}[m
[32m+[m		[32mte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;[m
[32m+[m		[32mte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;[m
[32m+[m		[32mte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;[m
[32m+[m
[32m+[m		[32mreturn this;[m
 [m
 	},[m
 [m
[31m-	w: {[m
[32m+[m	[32mmultiplyScalar: function ( s ) {[m
 [m
[31m-		get: function () {[m
[32m+[m		[32mvar te = this.elements;[m
 [m
[31m-			return this._w;[m
[32m+[m		[32mte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;[m
[32m+[m		[32mte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;[m
[32m+[m		[32mte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;[m
 [m
[31m-		},[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		set: function ( value ) {[m
[32m+[m	[32m},[m
 [m
[31m-			this._w = value;[m
[31m-			this._onChangeCallback();[m
[32m+[m	[32mdeterminant: function () {[m
 [m
[31m-		}[m
[32m+[m		[32mvar te = this.elements;[m
 [m
[31m-	}[m
[32m+[m		[32mvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],[m
[32m+[m			[32md = te[ 3 ], e = te[ 4 ], f = te[ 5 ],[m
[32m+[m			[32mg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];[m
 [m
[31m-} );[m
[32m+[m		[32mreturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;[m
 [m
[31m-Object.assign( Quaternion.prototype, {[m
[32m+[m	[32m},[m
 [m
[31m-	isQuaternion: true,[m
[32m+[m	[32mgetInverse: function ( matrix, throwOnDegenerate ) {[m
 [m
[31m-	set: function ( x, y, z, w ) {[m
[32m+[m		[32mif ( throwOnDegenerate !== undefined ) {[m
 [m
[31m-		this._x = x;[m
[31m-		this._y = y;[m
[31m-		this._z = z;[m
[31m-		this._w = w;[m
[32m+[m			[32mconsole.warn( "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate." );[m
 [m
[31m-		this._onChangeCallback();[m
[32m+[m		[32m}[m
 [m
[31m-		return this;[m
[32m+[m		[32mvar me = matrix.elements,[m
[32m+[m			[32mte = this.elements,[m
 [m
[31m-	},[m
[32m+[m			[32mn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],[m
[32m+[m			[32mn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],[m
[32m+[m			[32mn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],[m
 [m
[31m-	clone: function () {[m
[32m+[m			[32mt11 = n33 * n22 - n32 * n23,[m
[32m+[m			[32mt12 = n32 * n13 - n33 * n12,[m
[32m+[m			[32mt13 = n23 * n12 - n22 * n13,[m
 [m
[31m-		return new this.constructor( this._x, this._y, this._z, this._w );[m
[32m+[m			[32mdet = n11 * t11 + n21 * t12 + n31 * t13;[m
 [m
[31m-	},[m
[32m+[m		[32mif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );[m
 [m
[31m-	copy: function ( quaternion ) {[m
[32m+[m		[32mvar detInv = 1 / det;[m
 [m
[31m-		this._x = quaternion.x;[m
[31m-		this._y = quaternion.y;[m
[31m-		this._z = quaternion.z;[m
[31m-		this._w = quaternion.w;[m
[32m+[m		[32mte[ 0 ] = t11 * detInv;[m
[32m+[m		[32mte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;[m
[32m+[m		[32mte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;[m
 [m
[31m-		this._onChangeCallback();[m
[32m+[m		[32mte[ 3 ] = t12 * detInv;[m
[32m+[m		[32mte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;[m
[32m+[m		[32mte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;[m
[32m+[m
[32m+[m		[32mte[ 6 ] = t13 * detInv;[m
[32m+[m		[32mte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;[m
[32m+[m		[32mte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setFromEuler: function ( euler, update ) {[m
[31m-[m
[31m-		if ( ! ( euler && euler.isEuler ) ) {[m
[31m-[m
[31m-			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );[m
[31m-[m
[31m-		}[m
[32m+[m	[32mtranspose: function () {[m
 [m
[31m-		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;[m
[32m+[m		[32mvar tmp, m = this.elements;[m
 [m
[31m-		// http://www.mathworks.com/matlabcentral/fileexchange/[m
[31m-		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/[m
[31m-		//	content/SpinCalc.m[m
[32m+[m		[32mtmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;[m
[32m+[m		[32mtmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;[m
[32m+[m		[32mtmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;[m
 [m
[31m-		var cos = Math.cos;[m
[31m-		var sin = Math.sin;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		var c1 = cos( x / 2 );[m
[31m-		var c2 = cos( y / 2 );[m
[31m-		var c3 = cos( z / 2 );[m
[32m+[m	[32m},[m
 [m
[31m-		var s1 = sin( x / 2 );[m
[31m-		var s2 = sin( y / 2 );[m
[31m-		var s3 = sin( z / 2 );[m
[32m+[m	[32mgetNormalMatrix: function ( matrix4 ) {[m
 [m
[31m-		if ( order === 'XYZ' ) {[m
[32m+[m		[32mreturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();[m
 [m
[31m-			this._x = s1 * c2 * c3 + c1 * s2 * s3;[m
[31m-			this._y = c1 * s2 * c3 - s1 * c2 * s3;[m
[31m-			this._z = c1 * c2 * s3 + s1 * s2 * c3;[m
[31m-			this._w = c1 * c2 * c3 - s1 * s2 * s3;[m
[32m+[m	[32m},[m
 [m
[31m-		} else if ( order === 'YXZ' ) {[m
[32m+[m	[32mtransposeIntoArray: function ( r ) {[m
 [m
[31m-			this._x = s1 * c2 * c3 + c1 * s2 * s3;[m
[31m-			this._y = c1 * s2 * c3 - s1 * c2 * s3;[m
[31m-			this._z = c1 * c2 * s3 - s1 * s2 * c3;[m
[31m-			this._w = c1 * c2 * c3 + s1 * s2 * s3;[m
[32m+[m		[32mvar m = this.elements;[m
 [m
[31m-		} else if ( order === 'ZXY' ) {[m
[32m+[m		[32mr[ 0 ] = m[ 0 ];[m
[32m+[m		[32mr[ 1 ] = m[ 3 ];[m
[32m+[m		[32mr[ 2 ] = m[ 6 ];[m
[32m+[m		[32mr[ 3 ] = m[ 1 ];[m
[32m+[m		[32mr[ 4 ] = m[ 4 ];[m
[32m+[m		[32mr[ 5 ] = m[ 7 ];[m
[32m+[m		[32mr[ 6 ] = m[ 2 ];[m
[32m+[m		[32mr[ 7 ] = m[ 5 ];[m
[32m+[m		[32mr[ 8 ] = m[ 8 ];[m
 [m
[31m-			this._x = s1 * c2 * c3 - c1 * s2 * s3;[m
[31m-			this._y = c1 * s2 * c3 + s1 * c2 * s3;[m
[31m-			this._z = c1 * c2 * s3 + s1 * s2 * c3;[m
[31m-			this._w = c1 * c2 * c3 - s1 * s2 * s3;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		} else if ( order === 'ZYX' ) {[m
[32m+[m	[32m},[m
 [m
[31m-			this._x = s1 * c2 * c3 - c1 * s2 * s3;[m
[31m-			this._y = c1 * s2 * c3 + s1 * c2 * s3;[m
[31m-			this._z = c1 * c2 * s3 - s1 * s2 * c3;[m
[31m-			this._w = c1 * c2 * c3 + s1 * s2 * s3;[m
[32m+[m	[32msetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {[m
 [m
[31m-		} else if ( order === 'YZX' ) {[m
[32m+[m		[32mvar c = Math.cos( rotation );[m
[32m+[m		[32mvar s = Math.sin( rotation );[m
 [m
[31m-			this._x = s1 * c2 * c3 + c1 * s2 * s3;[m
[31m-			this._y = c1 * s2 * c3 + s1 * c2 * s3;[m
[31m-			this._z = c1 * c2 * s3 - s1 * s2 * c3;[m
[31m-			this._w = c1 * c2 * c3 - s1 * s2 * s3;[m
[32m+[m		[32mthis.set([m
[32m+[m			[32msx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,[m
[32m+[m			[32m- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,[m
[32m+[m			[32m0, 0, 1[m
[32m+[m		[32m);[m
 [m
[31m-		} else if ( order === 'XZY' ) {[m
[32m+[m	[32m},[m
 [m
[31m-			this._x = s1 * c2 * c3 - c1 * s2 * s3;[m
[31m-			this._y = c1 * s2 * c3 - s1 * c2 * s3;[m
[31m-			this._z = c1 * c2 * s3 + s1 * s2 * c3;[m
[31m-			this._w = c1 * c2 * c3 + s1 * s2 * s3;[m
[32m+[m	[32mscale: function ( sx, sy ) {[m
 [m
[31m-		}[m
[32m+[m		[32mvar te = this.elements;[m
 [m
[31m-		if ( update !== false ) this._onChangeCallback();[m
[32m+[m		[32mte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;[m
[32m+[m		[32mte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setFromAxisAngle: function ( axis, angle ) {[m
[32m+[m	[32mrotate: function ( theta ) {[m
 [m
[31m-		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm[m
[32m+[m		[32mvar c = Math.cos( theta );[m
[32m+[m		[32mvar s = Math.sin( theta );[m
 [m
[31m-		// assumes axis is normalized[m
[32m+[m		[32mvar te = this.elements;[m
 [m
[31m-		var halfAngle = angle / 2, s = Math.sin( halfAngle );[m
[32m+[m		[32mvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];[m
[32m+[m		[32mvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];[m
 [m
[31m-		this._x = axis.x * s;[m
[31m-		this._y = axis.y * s;[m
[31m-		this._z = axis.z * s;[m
[31m-		this._w = Math.cos( halfAngle );[m
[32m+[m		[32mte[ 0 ] = c * a11 + s * a21;[m
[32m+[m		[32mte[ 3 ] = c * a12 + s * a22;[m
[32m+[m		[32mte[ 6 ] = c * a13 + s * a23;[m
 [m
[31m-		this._onChangeCallback();[m
[32m+[m		[32mte[ 1 ] = - s * a11 + c * a21;[m
[32m+[m		[32mte[ 4 ] = - s * a12 + c * a22;[m
[32m+[m		[32mte[ 7 ] = - s * a13 + c * a23;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setFromRotationMatrix: function ( m ) {[m
[31m-[m
[31m-		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm[m
[31m-[m
[31m-		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)[m
[32m+[m	[32mtranslate: function ( tx, ty ) {[m
 [m
[31m-		var te = m.elements,[m
[32m+[m		[32mvar te = this.elements;[m
 [m
[31m-			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],[m
[31m-			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],[m
[31m-			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],[m
[32m+[m		[32mte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];[m
[32m+[m		[32mte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];[m
 [m
[31m-			trace = m11 + m22 + m33,[m
[31m-			s;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		if ( trace > 0 ) {[m
[32m+[m	[32m},[m
 [m
[31m-			s = 0.5 / Math.sqrt( trace + 1.0 );[m
[32m+[m	[32mequals: function ( matrix ) {[m
 [m
[31m-			this._w = 0.25 / s;[m
[31m-			this._x = ( m32 - m23 ) * s;[m
[31m-			this._y = ( m13 - m31 ) * s;[m
[31m-			this._z = ( m21 - m12 ) * s;[m
[32m+[m		[32mvar te = this.elements;[m
[32m+[m		[32mvar me = matrix.elements;[m
 [m
[31m-		} else if ( m11 > m22 && m11 > m33 ) {[m
[32m+[m		[32mfor ( var i = 0; i < 9; i ++ ) {[m
 [m
[31m-			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );[m
[32m+[m			[32mif ( te[ i ] !== me[ i ] ) return false;[m
 [m
[31m-			this._w = ( m32 - m23 ) / s;[m
[31m-			this._x = 0.25 * s;[m
[31m-			this._y = ( m12 + m21 ) / s;[m
[31m-			this._z = ( m13 + m31 ) / s;[m
[32m+[m		[32m}[m
 [m
[31m-		} else if ( m22 > m33 ) {[m
[32m+[m		[32mreturn true;[m
 [m
[31m-			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );[m
[32m+[m	[32m},[m
 [m
[31m-			this._w = ( m13 - m31 ) / s;[m
[31m-			this._x = ( m12 + m21 ) / s;[m
[31m-			this._y = 0.25 * s;[m
[31m-			this._z = ( m23 + m32 ) / s;[m
[32m+[m	[32mfromArray: function ( array, offset ) {[m
 [m
[31m-		} else {[m
[32m+[m		[32mif ( offset === undefined ) offset = 0;[m
 [m
[31m-			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );[m
[32m+[m		[32mfor ( var i = 0; i < 9; i ++ ) {[m
 [m
[31m-			this._w = ( m21 - m12 ) / s;[m
[31m-			this._x = ( m13 + m31 ) / s;[m
[31m-			this._y = ( m23 + m32 ) / s;[m
[31m-			this._z = 0.25 * s;[m
[32m+[m			[32mthis.elements[ i ] = array[ i + offset ];[m
 [m
 		}[m
 [m
[31m-		this._onChangeCallback();[m
[31m-[m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setFromUnitVectors: function ( vFrom, vTo ) {[m
[32m+[m	[32mtoArray: function ( array, offset ) {[m
 [m
[31m-		// assumes direction vectors vFrom and vTo are normalized[m
[32m+[m		[32mif ( array === undefined ) array = [];[m
[32m+[m		[32mif ( offset === undefined ) offset = 0;[m
 [m
[31m-		var EPS = 0.000001;[m
[32m+[m		[32mvar te = this.elements;[m
 [m
[31m-		var r = vFrom.dot( vTo ) + 1;[m
[32m+[m		[32marray[ offset ] = te[ 0 ];[m
[32m+[m		[32marray[ offset + 1 ] = te[ 1 ];[m
[32m+[m		[32marray[ offset + 2 ] = te[ 2 ];[m
 [m
[31m-		if ( r < EPS ) {[m
[32m+[m		[32marray[ offset + 3 ] = te[ 3 ];[m
[32m+[m		[32marray[ offset + 4 ] = te[ 4 ];[m
[32m+[m		[32marray[ offset + 5 ] = te[ 5 ];[m
 [m
[31m-			r = 0;[m
[32m+[m		[32marray[ offset + 6 ] = te[ 6 ];[m
[32m+[m		[32marray[ offset + 7 ] = te[ 7 ];[m
[32m+[m		[32marray[ offset + 8 ] = te[ 8 ];[m
 [m
[31m-			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {[m
[32m+[m		[32mreturn array;[m
 [m
[31m-				this._x = - vFrom.y;[m
[31m-				this._y = vFrom.x;[m
[31m-				this._z = 0;[m
[31m-				this._w = r;[m
[32m+[m	[32m}[m
 [m
[31m-			} else {[m
[32m+[m[32m} );[m
 [m
[31m-				this._x = 0;[m
[31m-				this._y = - vFrom.z;[m
[31m-				this._z = vFrom.y;[m
[31m-				this._w = r;[m
[32m+[m[32m/**[m
[32m+[m[32m * @author mrdoob / http://mrdoob.com/[m
[32m+[m[32m * @author alteredq / http://alteredqualia.com/[m
[32m+[m[32m * @author szimek / https://github.com/szimek/[m
[32m+[m[32m */[m
 [m
[31m-			}[m
[32m+[m[32mvar _canvas;[m
 [m
[31m-		} else {[m
[32m+[m[32mvar ImageUtils = {[m
 [m
[31m-			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3[m
[32m+[m	[32mgetDataURL: function ( image ) {[m
 [m
[31m-			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;[m
[31m-			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;[m
[31m-			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;[m
[31m-			this._w = r;[m
[32m+[m		[32mvar canvas;[m
 [m
[31m-		}[m
[32m+[m		[32mif ( typeof HTMLCanvasElement == 'undefined' ) {[m
 [m
[31m-		return this.normalize();[m
[32m+[m			[32mreturn image.src;[m
 [m
[31m-	},[m
[32m+[m		[32m} else if ( image instanceof HTMLCanvasElement ) {[m
 [m
[31m-	angleTo: function ( q ) {[m
[32m+[m			[32mcanvas = image;[m
 [m
[31m-		return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );[m
[32m+[m		[32m} else {[m
 [m
[31m-	},[m
[32m+[m			[32mif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );[m
 [m
[31m-	rotateTowards: function ( q, step ) {[m
[32m+[m			[32m_canvas.width = image.width;[m
[32m+[m			[32m_canvas.height = image.height;[m
 [m
[31m-		var angle = this.angleTo( q );[m
[32m+[m			[32mvar context = _canvas.getContext( '2d' );[m
 [m
[31m-		if ( angle === 0 ) return this;[m
[32m+[m			[32mif ( image instanceof ImageData ) {[m
 [m
[31m-		var t = Math.min( 1, step / angle );[m
[32m+[m				[32mcontext.putImageData( image, 0, 0 );[m
 [m
[31m-		this.slerp( q, t );[m
[32m+[m			[32m} else {[m
 [m
[31m-		return this;[m
[32m+[m				[32mcontext.drawImage( image, 0, 0, image.width, image.height );[m
 [m
[31m-	},[m
[32m+[m			[32m}[m
 [m
[31m-	inverse: function () {[m
[32m+[m			[32mcanvas = _canvas;[m
 [m
[31m-		// quaternion is assumed to have unit length[m
[32m+[m		[32m}[m
 [m
[31m-		return this.conjugate();[m
[32m+[m		[32mif ( canvas.width > 2048 || canvas.height > 2048 ) {[m
 [m
[31m-	},[m
[32m+[m			[32mreturn canvas.toDataURL( 'image/jpeg', 0.6 );[m
 [m
[31m-	conjugate: function () {[m
[32m+[m		[32m} else {[m
 [m
[31m-		this._x *= - 1;[m
[31m-		this._y *= - 1;[m
[31m-		this._z *= - 1;[m
[32m+[m			[32mreturn canvas.toDataURL( 'image/png' );[m
 [m
[31m-		this._onChangeCallback();[m
[32m+[m		[32m}[m
 [m
[31m-		return this;[m
[32m+[m	[32m}[m
 [m
[31m-	},[m
[32m+[m[32m};[m
 [m
[31m-	dot: function ( v ) {[m
[32m+[m[32m/**[m
[32m+[m[32m * @author mrdoob / http://mrdoob.com/[m
[32m+[m[32m * @author alteredq / http://alteredqualia.com/[m
[32m+[m[32m * @author szimek / https://github.com/szimek/[m
[32m+[m[32m */[m
 [m
[31m-		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;[m
[32m+[m[32mvar textureId = 0;[m
 [m
[31m-	},[m
[32m+[m[32mfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {[m
 [m
[31m-	lengthSq: function () {[m
[32m+[m	[32mObject.defineProperty( this, 'id', { value: textureId ++ } );[m
 [m
[31m-		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;[m
[32m+[m	[32mthis.uuid = MathUtils.generateUUID();[m
[32m+[m
[32m+[m	[32mthis.name = '';[m
[32m+[m
[32m+[m	[32mthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;[m
[32m+[m	[32mthis.mipmaps = [];[m
[32m+[m
[32m+[m	[32mthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;[m
[32m+[m
[32m+[m	[32mthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;[m
[32m+[m	[32mthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;[m
[32m+[m
[32m+[m	[32mthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;[m
[32m+[m	[32mthis.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;[m
[32m+[m
[32m+[m	[32mthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;[m
[32m+[m
[32m+[m	[32mthis.format = format !== undefined ? format : RGBAFormat;[m
[32m+[m	[32mthis.internalFormat = null;[m
[32m+[m	[32mthis.type = type !== undefined ? type : UnsignedByteType;[m
[32m+[m
[32m+[m	[32mthis.offset = new Vector2( 0, 0 );[m
[32m+[m	[32mthis.repeat = new Vector2( 1, 1 );[m
[32m+[m	[32mthis.center = new Vector2( 0, 0 );[m
[32m+[m	[32mthis.rotation = 0;[m
[32m+[m
[32m+[m	[32mthis.matrixAutoUpdate = true;[m
[32m+[m	[32mthis.matrix = new Matrix3();[m
[32m+[m
[32m+[m	[32mthis.generateMipmaps = true;[m
[32m+[m	[32mthis.premultiplyAlpha = false;[m
[32m+[m	[32mthis.flipY = true;[m
[32m+[m	[32mthis.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)[m
[32m+[m
[32m+[m	[32m// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.[m
[32m+[m	[32m//[m
[32m+[m	[32m// Also changing the encoding after already used by a Material will not automatically make the Material[m
[32m+[m	[32m// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.[m
[32m+[m	[32mthis.encoding = encoding !== undefined ? encoding : LinearEncoding;[m
[32m+[m
[32m+[m	[32mthis.version = 0;[m
[32m+[m	[32mthis.onUpdate = null;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mTexture.DEFAULT_IMAGE = undefined;[m
[32m+[m[32mTexture.DEFAULT_MAPPING = UVMapping;[m
[32m+[m
[32m+[m[32mTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {[m
[32m+[m
[32m+[m	[32mconstructor: Texture,[m
[32m+[m
[32m+[m	[32misTexture: true,[m
[32m+[m
[32m+[m	[32mupdateMatrix: function () {[m
[32m+[m
[32m+[m		[32mthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );[m
 [m
 	},[m
 [m
[31m-	length: function () {[m
[32m+[m	[32mclone: function () {[m
 [m
[31m-		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );[m
[32m+[m		[32mreturn new this.constructor().copy( this );[m
 [m
 	},[m
 [m
[31m-	normalize: function () {[m
[32m+[m	[32mcopy: function ( source ) {[m
 [m
[31m-		var l = this.length();[m
[32m+[m		[32mthis.name = source.name;[m
 [m
[31m-		if ( l === 0 ) {[m
[32m+[m		[32mthis.image = source.image;[m
[32m+[m		[32mthis.mipmaps = source.mipmaps.slice( 0 );[m
 [m
[31m-			this._x = 0;[m
[31m-			this._y = 0;[m
[31m-			this._z = 0;[m
[31m-			this._w = 1;[m
[32m+[m		[32mthis.mapping = source.mapping;[m
 [m
[31m-		} else {[m
[32m+[m		[32mthis.wrapS = source.wrapS;[m
[32m+[m		[32mthis.wrapT = source.wrapT;[m
 [m
[31m-			l = 1 / l;[m
[32m+[m		[32mthis.magFilter = source.magFilter;[m
[32m+[m		[32mthis.minFilter = source.minFilter;[m
 [m
[31m-			this._x = this._x * l;[m
[31m-			this._y = this._y * l;[m
[31m-			this._z = this._z * l;[m
[31m-			this._w = this._w * l;[m
[32m+[m		[32mthis.anisotropy = source.anisotropy;[m
 [m
[31m-		}[m
[32m+[m		[32mthis.format = source.format;[m
[32m+[m		[32mthis.internalFormat = source.internalFormat;[m
[32m+[m		[32mthis.type = source.type;[m
 [m
[31m-		this._onChangeCallback();[m
[32m+[m		[32mthis.offset.copy( source.offset );[m
[32m+[m		[32mthis.repeat.copy( source.repeat );[m
[32m+[m		[32mthis.center.copy( source.center );[m
[32m+[m		[32mthis.rotation = source.rotation;[m
[32m+[m
[32m+[m		[32mthis.matrixAutoUpdate = source.matrixAutoUpdate;[m
[32m+[m		[32mthis.matrix.copy( source.matrix );[m
[32m+[m
[32m+[m		[32mthis.generateMipmaps = source.generateMipmaps;[m
[32m+[m		[32mthis.premultiplyAlpha = source.premultiplyAlpha;[m
[32m+[m		[32mthis.flipY = source.flipY;[m
[32m+[m		[32mthis.unpackAlignment = source.unpackAlignment;[m
[32m+[m		[32mthis.encoding = source.encoding;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	multiply: function ( q, p ) {[m
[32m+[m	[32mtoJSON: function ( meta ) {[m
 [m
[31m-		if ( p !== undefined ) {[m
[32m+[m		[32mvar isRootObject = ( meta === undefined || typeof meta === 'string' );[m
 [m
[31m-			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );[m
[31m-			return this.multiplyQuaternions( q, p );[m
[32m+[m		[32mif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {[m
[32m+[m
[32m+[m			[32mreturn meta.textures[ this.uuid ];[m
 [m
 		}[m
 [m
[31m-		return this.multiplyQuaternions( this, q );[m
[32m+[m		[32mvar output = {[m
 [m
[31m-	},[m
[32m+[m			[32mmetadata: {[m
[32m+[m				[32mversion: 4.5,[m
[32m+[m				[32mtype: 'Texture',[m
[32m+[m				[32mgenerator: 'Texture.toJSON'[m
[32m+[m			[32m},[m
 [m
[31m-	premultiply: function ( q ) {[m
[32m+[m			[32muuid: this.uuid,[m
[32m+[m			[32mname: this.name,[m
 [m
[31m-		return this.multiplyQuaternions( q, this );[m
[32m+[m			[32mmapping: this.mapping,[m
 [m
[31m-	},[m
[32m+[m			[32mrepeat: [ this.repeat.x, this.repeat.y ],[m
[32m+[m			[32moffset: [ this.offset.x, this.offset.y ],[m
[32m+[m			[32mcenter: [ this.center.x, this.center.y ],[m
[32m+[m			[32mrotation: this.rotation,[m
 [m
[31m-	multiplyQuaternions: function ( a, b ) {[m
[32m+[m			[32mwrap: [ this.wrapS, this.wrapT ],[m
 [m
[31m-		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm[m
[32m+[m			[32mformat: this.format,[m
[32m+[m			[32mtype: this.type,[m
[32m+[m			[32mencoding: this.encoding,[m
 [m
[31m-		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;[m
[31m-		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;[m
[32m+[m			[32mminFilter: this.minFilter,[m
[32m+[m			[32mmagFilter: this.magFilter,[m
[32m+[m			[32manisotropy: this.anisotropy,[m
 [m
[31m-		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;[m
[31m-		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;[m
[31m-		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;[m
[31m-		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;[m
[32m+[m			[32mflipY: this.flipY,[m
 [m
[31m-		this._onChangeCallback();[m
[32m+[m			[32mpremultiplyAlpha: this.premultiplyAlpha,[m
[32m+[m			[32munpackAlignment: this.unpackAlignment[m
 [m
[31m-		return this;[m
[32m+[m		[32m};[m
 [m
[31m-	},[m
[32m+[m		[32mif ( this.image !== undefined ) {[m
 [m
[31m-	slerp: function ( qb, t ) {[m
[32m+[m			[32m// TODO: Move to THREE.Image[m
 [m
[31m-		if ( t === 0 ) return this;[m
[31m-		if ( t === 1 ) return this.copy( qb );[m
[32m+[m			[32mvar image = this.image;[m
 [m
[31m-		var x = this._x, y = this._y, z = this._z, w = this._w;[m
[32m+[m			[32mif ( image.uuid === undefined ) {[m
 [m
[31m-		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/[m
[32m+[m				[32mimage.uuid = MathUtils.generateUUID(); // UGH[m
 [m
[31m-		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;[m
[32m+[m			[32m}[m
 [m
[31m-		if ( cosHalfTheta < 0 ) {[m
[32m+[m			[32mif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {[m
 [m
[31m-			this._w = - qb._w;[m
[31m-			this._x = - qb._x;[m
[31m-			this._y = - qb._y;[m
[31m-			this._z = - qb._z;[m
[32m+[m				[32mvar url;[m
 [m
[31m-			cosHalfTheta = - cosHalfTheta;[m
[32m+[m				[32mif ( Array.isArray( image ) ) {[m
 [m
[31m-		} else {[m
[32m+[m					[32m// process array of images e.g. CubeTexture[m
 [m
[31m-			this.copy( qb );[m
[32m+[m					[32murl = [];[m
 [m
[31m-		}[m
[32m+[m					[32mfor ( var i = 0, l = image.length; i < l; i ++ ) {[m
 [m
[31m-		if ( cosHalfTheta >= 1.0 ) {[m
[32m+[m						[32murl.push( ImageUtils.getDataURL( image[ i ] ) );[m
 [m
[31m-			this._w = w;[m
[31m-			this._x = x;[m
[31m-			this._y = y;[m
[31m-			this._z = z;[m
[32m+[m					[32m}[m
 [m
[31m-			return this;[m
[32m+[m				[32m} else {[m
 [m
[31m-		}[m
[32m+[m					[32m// process single image[m
 [m
[31m-		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;[m
[32m+[m					[32murl = ImageUtils.getDataURL( image );[m
 [m
[31m-		if ( sqrSinHalfTheta <= Number.EPSILON ) {[m
[32m+[m				[32m}[m
 [m
[31m-			var s = 1 - t;[m
[31m-			this._w = s * w + t * this._w;[m
[31m-			this._x = s * x + t * this._x;[m
[31m-			this._y = s * y + t * this._y;[m
[31m-			this._z = s * z + t * this._z;[m
[32m+[m				[32mmeta.images[ image.uuid ] = {[m
[32m+[m					[32muuid: image.uuid,[m
[32m+[m					[32murl: url[m
[32m+[m				[32m};[m
 [m
[31m-			this.normalize();[m
[31m-			this._onChangeCallback();[m
[32m+[m			[32m}[m
 [m
[31m-			return this;[m
[32m+[m			[32moutput.image = image.uuid;[m
 [m
 		}[m
 [m
[31m-		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );[m
[31m-		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );[m
[31m-		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,[m
[31m-			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;[m
[32m+[m		[32mif ( ! isRootObject ) {[m
 [m
[31m-		this._w = ( w * ratioA + this._w * ratioB );[m
[31m-		this._x = ( x * ratioA + this._x * ratioB );[m
[31m-		this._y = ( y * ratioA + this._y * ratioB );[m
[31m-		this._z = ( z * ratioA + this._z * ratioB );[m
[32m+[m			[32mmeta.textures[ this.uuid ] = output;[m
 [m
[31m-		this._onChangeCallback();[m
[32m+[m		[32m}[m
 [m
[31m-		return this;[m
[32m+[m		[32mreturn output;[m
 [m
 	},[m
 [m
[31m-	equals: function ( quaternion ) {[m
[32m+[m	[32mdispose: function () {[m
 [m
[31m-		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );[m
[32m+[m		[32mthis.dispatchEvent( { type: 'dispose' } );[m
 [m
 	},[m
 [m
[31m-	fromArray: function ( array, offset ) {[m
[32m+[m	[32mtransformUv: function ( uv ) {[m
 [m
[31m-		if ( offset === undefined ) offset = 0;[m
[32m+[m		[32mif ( this.mapping !== UVMapping ) return uv;[m
 [m
[31m-		this._x = array[ offset ];[m
[31m-		this._y = array[ offset + 1 ];[m
[31m-		this._z = array[ offset + 2 ];[m
[31m-		this._w = array[ offset + 3 ];[m
[32m+[m		[32muv.applyMatrix3( this.matrix );[m
 [m
[31m-		this._onChangeCallback();[m
[32m+[m		[32mif ( uv.x < 0 || uv.x > 1 ) {[m
 [m
[31m-		return this;[m
[32m+[m			[32mswitch ( this.wrapS ) {[m
 [m
[31m-	},[m
[32m+[m				[32mcase RepeatWrapping:[m
 [m
[31m-	toArray: function ( array, offset ) {[m
[32m+[m					[32muv.x = uv.x - Math.floor( uv.x );[m
[32m+[m					[32mbreak;[m
 [m
[31m-		if ( array === undefined ) array = [];[m
[31m-		if ( offset === undefined ) offset = 0;[m
[32m+[m				[32mcase ClampToEdgeWrapping:[m
 [m
[31m-		array[ offset ] = this._x;[m
[31m-		array[ offset + 1 ] = this._y;[m
[31m-		array[ offset + 2 ] = this._z;[m
[31m-		array[ offset + 3 ] = this._w;[m
[32m+[m					[32muv.x = uv.x < 0 ? 0 : 1;[m
[32m+[m					[32mbreak;[m
 [m
[31m-		return array;[m
[32m+[m				[32mcase MirroredRepeatWrapping:[m
 [m
[31m-	},[m
[32m+[m					[32mif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {[m
 [m
[31m-	_onChange: function ( callback ) {[m
[32m+[m						[32muv.x = Math.ceil( uv.x ) - uv.x;[m
 [m
[31m-		this._onChangeCallback = callback;[m
[32m+[m					[32m} else {[m
 [m
[31m-		return this;[m
[32m+[m						[32muv.x = uv.x - Math.floor( uv.x );[m
 [m
[31m-	},[m
[32m+[m					[32m}[m
[32m+[m					[32mbreak;[m
 [m
[31m-	_onChangeCallback: function () {}[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( uv.y < 0 || uv.y > 1 ) {[m
[32m+[m
[32m+[m			[32mswitch ( this.wrapT ) {[m
[32m+[m
[32m+[m				[32mcase RepeatWrapping:[m
[32m+[m
[32m+[m					[32muv.y = uv.y - Math.floor( uv.y );[m
[32m+[m					[32mbreak;[m
[32m+[m
[32m+[m				[32mcase ClampToEdgeWrapping:[m
[32m+[m
[32m+[m					[32muv.y = uv.y < 0 ? 0 : 1;[m
[32m+[m					[32mbreak;[m
[32m+[m
[32m+[m				[32mcase MirroredRepeatWrapping:[m
[32m+[m
[32m+[m					[32mif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {[m
[32m+[m
[32m+[m						[32muv.y = Math.ceil( uv.y ) - uv.y;[m
[32m+[m
[32m+[m					[32m} else {[m
[32m+[m
[32m+[m						[32muv.y = uv.y - Math.floor( uv.y );[m
[32m+[m
[32m+[m					[32m}[m
[32m+[m					[32mbreak;[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( this.flipY ) {[m
[32m+[m
[32m+[m			[32muv.y = 1 - uv.y;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn uv;[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m[32m} );[m
[32m+[m
[32m+[m[32mObject.defineProperty( Texture.prototype, "needsUpdate", {[m
[32m+[m
[32m+[m	[32mset: function ( value ) {[m
[32m+[m
[32m+[m		[32mif ( value === true ) this.version ++;[m
[32m+[m
[32m+[m	[32m}[m
 [m
 } );[m
 [m
 /**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- * @author kile / http://kile.stravaganza.org/[m
[32m+[m[32m * @author supereggbert / http://www.paulbrunt.co.uk/[m
  * @author philogb / http://blog.thejit.org/[m
  * @author mikael emtinger / http://gomo.se/[m
  * @author egraether / http://egraether.com/[m
  * @author WestLangley / http://github.com/WestLangley[m
  */[m
 [m
[31m-var _vector = new Vector3();[m
[31m-var _quaternion = new Quaternion();[m
[31m-[m
[31m-function Vector3( x, y, z ) {[m
[32m+[m[32mfunction Vector4( x, y, z, w ) {[m
 [m
 	this.x = x || 0;[m
 	this.y = y || 0;[m
 	this.z = z || 0;[m
[32m+[m	[32mthis.w = ( w !== undefined ) ? w : 1;[m
 [m
 }[m
 [m
[31m-Object.assign( Vector3.prototype, {[m
[32m+[m[32mObject.defineProperties( Vector4.prototype, {[m
 [m
[31m-	isVector3: true,[m
[32m+[m	[32m"width": {[m
 [m
[31m-	set: function ( x, y, z ) {[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mreturn this.z;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m
[32m+[m		[32mset: function ( value ) {[m
[32m+[m
[32m+[m			[32mthis.z = value;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m"height": {[m
[32m+[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mreturn this.w;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m
[32m+[m		[32mset: function ( value ) {[m
[32m+[m
[32m+[m			[32mthis.w = value;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m[32m} );[m
[32m+[m
[32m+[m[32mObject.assign( Vector4.prototype, {[m
[32m+[m
[32m+[m	[32misVector4: true,[m
[32m+[m
[32m+[m	[32mset: function ( x, y, z, w ) {[m
 [m
 		this.x = x;[m
 		this.y = y;[m
 		this.z = z;[m
[32m+[m		[32mthis.w = w;[m
 [m
 		return this;[m
 [m
[36m@@ -1652,6 +1868,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = scalar;[m
 		this.y = scalar;[m
 		this.z = scalar;[m
[32m+[m		[32mthis.w = scalar;[m
 [m
 		return this;[m
 [m
[36m@@ -1681,6 +1898,14 @@[m [mObject.assign( Vector3.prototype, {[m
 [m
 	},[m
 [m
[32m+[m	[32msetW: function ( w ) {[m
[32m+[m
[32m+[m		[32mthis.w = w;[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
 	setComponent: function ( index, value ) {[m
 [m
 		switch ( index ) {[m
[36m@@ -1688,6 +1913,7 @@[m [mObject.assign( Vector3.prototype, {[m
 			case 0: this.x = value; break;[m
 			case 1: this.y = value; break;[m
 			case 2: this.z = value; break;[m
[32m+[m			[32mcase 3: this.w = value; break;[m
 			default: throw new Error( 'index is out of range: ' + index );[m
 [m
 		}[m
[36m@@ -1703,6 +1929,7 @@[m [mObject.assign( Vector3.prototype, {[m
 			case 0: return this.x;[m
 			case 1: return this.y;[m
 			case 2: return this.z;[m
[32m+[m			[32mcase 3: return this.w;[m
 			default: throw new Error( 'index is out of range: ' + index );[m
 [m
 		}[m
[36m@@ -1711,7 +1938,7 @@[m [mObject.assign( Vector3.prototype, {[m
 [m
 	clone: function () {[m
 [m
[31m-		return new this.constructor( this.x, this.y, this.z );[m
[32m+[m		[32mreturn new this.constructor( this.x, this.y, this.z, this.w );[m
 [m
 	},[m
 [m
[36m@@ -1720,6 +1947,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = v.x;[m
 		this.y = v.y;[m
 		this.z = v.z;[m
[32m+[m		[32mthis.w = ( v.w !== undefined ) ? v.w : 1;[m
 [m
 		return this;[m
 [m
[36m@@ -1729,7 +1957,7 @@[m [mObject.assign( Vector3.prototype, {[m
 [m
 		if ( w !== undefined ) {[m
 [m
[31m-			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );[m
[32m+[m			[32mconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );[m
 			return this.addVectors( v, w );[m
 [m
 		}[m
[36m@@ -1737,6 +1965,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x += v.x;[m
 		this.y += v.y;[m
 		this.z += v.z;[m
[32m+[m		[32mthis.w += v.w;[m
 [m
 		return this;[m
 [m
[36m@@ -1747,6 +1976,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x += s;[m
 		this.y += s;[m
 		this.z += s;[m
[32m+[m		[32mthis.w += s;[m
 [m
 		return this;[m
 [m
[36m@@ -1757,6 +1987,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = a.x + b.x;[m
 		this.y = a.y + b.y;[m
 		this.z = a.z + b.z;[m
[32m+[m		[32mthis.w = a.w + b.w;[m
 [m
 		return this;[m
 [m
[36m@@ -1767,6 +1998,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x += v.x * s;[m
 		this.y += v.y * s;[m
 		this.z += v.z * s;[m
[32m+[m		[32mthis.w += v.w * s;[m
 [m
 		return this;[m
 [m
[36m@@ -1776,7 +2008,7 @@[m [mObject.assign( Vector3.prototype, {[m
 [m
 		if ( w !== undefined ) {[m
 [m
[31m-			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );[m
[32m+[m			[32mconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );[m
 			return this.subVectors( v, w );[m
 [m
 		}[m
[36m@@ -1784,6 +2016,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x -= v.x;[m
 		this.y -= v.y;[m
 		this.z -= v.z;[m
[32m+[m		[32mthis.w -= v.w;[m
 [m
 		return this;[m
 [m
[36m@@ -1794,6 +2027,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x -= s;[m
 		this.y -= s;[m
 		this.z -= s;[m
[32m+[m		[32mthis.w -= s;[m
 [m
 		return this;[m
 [m
[36m@@ -1804,23 +2038,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = a.x - b.x;[m
 		this.y = a.y - b.y;[m
 		this.z = a.z - b.z;[m
[31m-[m
[31m-		return this;[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	multiply: function ( v, w ) {[m
[31m-[m
[31m-		if ( w !== undefined ) {[m
[31m-[m
[31m-			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );[m
[31m-			return this.multiplyVectors( v, w );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		this.x *= v.x;[m
[31m-		this.y *= v.y;[m
[31m-		this.z *= v.z;[m
[32m+[m		[32mthis.w = a.w - b.w;[m
 [m
 		return this;[m
 [m
[36m@@ -1831,130 +2049,187 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x *= scalar;[m
 		this.y *= scalar;[m
 		this.z *= scalar;[m
[32m+[m		[32mthis.w *= scalar;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	multiplyVectors: function ( a, b ) {[m
[32m+[m	[32mapplyMatrix4: function ( m ) {[m
 [m
[31m-		this.x = a.x * b.x;[m
[31m-		this.y = a.y * b.y;[m
[31m-		this.z = a.z * b.z;[m
[32m+[m		[32mvar x = this.x, y = this.y, z = this.z, w = this.w;[m
[32m+[m		[32mvar e = m.elements;[m
[32m+[m
[32m+[m		[32mthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;[m
[32m+[m		[32mthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;[m
[32m+[m		[32mthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;[m
[32m+[m		[32mthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	applyEuler: function ( euler ) {[m
[32m+[m	[32mdivideScalar: function ( scalar ) {[m
 [m
[31m-		if ( ! ( euler && euler.isEuler ) ) {[m
[32m+[m		[32mreturn this.multiplyScalar( 1 / scalar );[m
 [m
[31m-			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );[m
[32m+[m	[32m},[m
 [m
[31m-		}[m
[32m+[m	[32msetAxisAngleFromQuaternion: function ( q ) {[m
 [m
[31m-		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );[m
[32m+[m		[32m// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm[m
 [m
[31m-	},[m
[32m+[m		[32m// q is assumed to be normalized[m
 [m
[31m-	applyAxisAngle: function ( axis, angle ) {[m
[32m+[m		[32mthis.w = 2 * Math.acos( q.w );[m
 [m
[31m-		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );[m
[32m+[m		[32mvar s = Math.sqrt( 1 - q.w * q.w );[m
 [m
[31m-	},[m
[32m+[m		[32mif ( s < 0.0001 ) {[m
 [m
[31m-	applyMatrix3: function ( m ) {[m
[32m+[m			[32mthis.x = 1;[m
[32m+[m			[32mthis.y = 0;[m
[32m+[m			[32mthis.z = 0;[m
 [m
[31m-		var x = this.x, y = this.y, z = this.z;[m
[31m-		var e = m.elements;[m
[32m+[m		[32m} else {[m
 [m
[31m-		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;[m
[31m-		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;[m
[31m-		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;[m
[32m+[m			[32mthis.x = q.x / s;[m
[32m+[m			[32mthis.y = q.y / s;[m
[32m+[m			[32mthis.z = q.z / s;[m
[32m+[m
[32m+[m		[32m}[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	applyMatrix4: function ( m ) {[m
[32m+[m	[32msetAxisAngleFromRotationMatrix: function ( m ) {[m
 [m
[31m-		var x = this.x, y = this.y, z = this.z;[m
[31m-		var e = m.elements;[m
[32m+[m		[32m// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm[m
 [m
[31m-		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );[m
[32m+[m		[32m// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)[m
 [m
[31m-		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;[m
[31m-		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;[m
[31m-		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;[m
[32m+[m		[32mvar angle, x, y, z,		// variables for result[m
[32m+[m			[32mepsilon = 0.01,		// margin to allow for rounding errors[m
[32m+[m			[32mepsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees[m
 [m
[31m-		return this;[m
[32m+[m			[32mte = m.elements,[m
 [m
[31m-	},[m
[32m+[m			[32mm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],[m
[32m+[m			[32mm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],[m
[32m+[m			[32mm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];[m
 [m
[31m-	applyQuaternion: function ( q ) {[m
[32m+[m		[32mif ( ( Math.abs( m12 - m21 ) < epsilon ) &&[m
[32m+[m		[32m     ( Math.abs( m13 - m31 ) < epsilon ) &&[m
[32m+[m		[32m     ( Math.abs( m23 - m32 ) < epsilon ) ) {[m
 [m
[31m-		var x = this.x, y = this.y, z = this.z;[m
[31m-		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;[m
[32m+[m			[32m// singularity found[m
[32m+[m			[32m// first check for identity matrix which must have +1 for all terms[m
[32m+[m			[32m// in leading diagonal and zero in other terms[m
 [m
[31m-		// calculate quat * vector[m
[32m+[m			[32mif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&[m
[32m+[m			[32m     ( Math.abs( m13 + m31 ) < epsilon2 ) &&[m
[32m+[m			[32m     ( Math.abs( m23 + m32 ) < epsilon2 ) &&[m
[32m+[m			[32m     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {[m
 [m
[31m-		var ix = qw * x + qy * z - qz * y;[m
[31m-		var iy = qw * y + qz * x - qx * z;[m
[31m-		var iz = qw * z + qx * y - qy * x;[m
[31m-		var iw = - qx * x - qy * y - qz * z;[m
[32m+[m				[32m// this singularity is identity matrix so angle = 0[m
 [m
[31m-		// calculate result * inverse quat[m
[32m+[m				[32mthis.set( 1, 0, 0, 0 );[m
 [m
[31m-		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;[m
[31m-		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;[m
[31m-		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;[m
[32m+[m				[32mreturn this; // zero angle, arbitrary axis[m
 [m
[31m-		return this;[m
[32m+[m			[32m}[m
 [m
[31m-	},[m
[32m+[m			[32m// otherwise this singularity is angle = 180[m
 [m
[31m-	project: function ( camera ) {[m
[32m+[m			[32mangle = Math.PI;[m
 [m
[31m-		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );[m
[32m+[m			[32mvar xx = ( m11 + 1 ) / 2;[m
[32m+[m			[32mvar yy = ( m22 + 1 ) / 2;[m
[32m+[m			[32mvar zz = ( m33 + 1 ) / 2;[m
[32m+[m			[32mvar xy = ( m12 + m21 ) / 4;[m
[32m+[m			[32mvar xz = ( m13 + m31 ) / 4;[m
[32m+[m			[32mvar yz = ( m23 + m32 ) / 4;[m
 [m
[31m-	},[m
[32m+[m			[32mif ( ( xx > yy ) && ( xx > zz ) ) {[m
 [m
[31m-	unproject: function ( camera ) {[m
[32m+[m				[32m// m11 is the largest diagonal term[m
 [m
[31m-		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );[m
[32m+[m				[32mif ( xx < epsilon ) {[m
 [m
[31m-	},[m
[32m+[m					[32mx = 0;[m
[32m+[m					[32my = 0.707106781;[m
[32m+[m					[32mz = 0.707106781;[m
 [m
[31m-	transformDirection: function ( m ) {[m
[32m+[m				[32m} else {[m
 [m
[31m-		// input: THREE.Matrix4 affine matrix[m
[31m-		// vector interpreted as a direction[m
[32m+[m					[32mx = Math.sqrt( xx );[m
[32m+[m					[32my = xy / x;[m
[32m+[m					[32mz = xz / x;[m
 [m
[31m-		var x = this.x, y = this.y, z = this.z;[m
[31m-		var e = m.elements;[m
[32m+[m				[32m}[m
 [m
[31m-		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;[m
[31m-		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;[m
[31m-		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;[m
[32m+[m			[32m} else if ( yy > zz ) {[m
 [m
[31m-		return this.normalize();[m
[32m+[m				[32m// m22 is the largest diagonal term[m
 [m
[31m-	},[m
[32m+[m				[32mif ( yy < epsilon ) {[m
 [m
[31m-	divide: function ( v ) {[m
[32m+[m					[32mx = 0.707106781;[m
[32m+[m					[32my = 0;[m
[32m+[m					[32mz = 0.707106781;[m
 [m
[31m-		this.x /= v.x;[m
[31m-		this.y /= v.y;[m
[31m-		this.z /= v.z;[m
[32m+[m				[32m} else {[m
 [m
[31m-		return this;[m
[32m+[m					[32my = Math.sqrt( yy );[m
[32m+[m					[32mx = xy / y;[m
[32m+[m					[32mz = yz / y;[m
 [m
[31m-	},[m
[32m+[m				[32m}[m
 [m
[31m-	divideScalar: function ( scalar ) {[m
[32m+[m			[32m} else {[m
 [m
[31m-		return this.multiplyScalar( 1 / scalar );[m
[32m+[m				[32m// m33 is the largest diagonal term so base result on this[m
[32m+[m
[32m+[m				[32mif ( zz < epsilon ) {[m
[32m+[m
[32m+[m					[32mx = 0.707106781;[m
[32m+[m					[32my = 0.707106781;[m
[32m+[m					[32mz = 0;[m
[32m+[m
[32m+[m				[32m} else {[m
[32m+[m
[32m+[m					[32mz = Math.sqrt( zz );[m
[32m+[m					[32mx = xz / z;[m
[32m+[m					[32my = yz / z;[m
[32m+[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mthis.set( x, y, z, angle );[m
[32m+[m
[32m+[m			[32mreturn this; // return 180 deg rotation[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32m// as we have reached here there are no singularities so we can handle normally[m
[32m+[m
[32m+[m		[32mvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +[m
[32m+[m		[32m                   ( m13 - m31 ) * ( m13 - m31 ) +[m
[32m+[m		[32m                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize[m
[32m+[m
[32m+[m		[32mif ( Math.abs( s ) < 0.001 ) s = 1;[m
[32m+[m
[32m+[m		[32m// prevent divide by zero, should not happen if matrix is orthogonal and should be[m
[32m+[m		[32m// caught by singularity test above, but I've left it in just in case[m
[32m+[m
[32m+[m		[32mthis.x = ( m32 - m23 ) / s;[m
[32m+[m		[32mthis.y = ( m13 - m31 ) / s;[m
[32m+[m		[32mthis.z = ( m21 - m12 ) / s;[m
[32m+[m		[32mthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );[m
[32m+[m
[32m+[m		[32mreturn this;[m
 [m
 	},[m
 [m
[36m@@ -1963,6 +2238,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = Math.min( this.x, v.x );[m
 		this.y = Math.min( this.y, v.y );[m
 		this.z = Math.min( this.z, v.z );[m
[32m+[m		[32mthis.w = Math.min( this.w, v.w );[m
 [m
 		return this;[m
 [m
[36m@@ -1973,6 +2249,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = Math.max( this.x, v.x );[m
 		this.y = Math.max( this.y, v.y );[m
 		this.z = Math.max( this.z, v.z );[m
[32m+[m		[32mthis.w = Math.max( this.w, v.w );[m
 [m
 		return this;[m
 [m
[36m@@ -1985,6 +2262,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = Math.max( min.x, Math.min( max.x, this.x ) );[m
 		this.y = Math.max( min.y, Math.min( max.y, this.y ) );[m
 		this.z = Math.max( min.z, Math.min( max.z, this.z ) );[m
[32m+[m		[32mthis.w = Math.max( min.w, Math.min( max.w, this.w ) );[m
 [m
 		return this;[m
 [m
[36m@@ -1995,6 +2273,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );[m
 		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );[m
 		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );[m
[32m+[m		[32mthis.w = Math.max( minVal, Math.min( maxVal, this.w ) );[m
 [m
 		return this;[m
 [m
[36m@@ -2013,6 +2292,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = Math.floor( this.x );[m
 		this.y = Math.floor( this.y );[m
 		this.z = Math.floor( this.z );[m
[32m+[m		[32mthis.w = Math.floor( this.w );[m
 [m
 		return this;[m
 [m
[36m@@ -2023,6 +2303,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = Math.ceil( this.x );[m
 		this.y = Math.ceil( this.y );[m
 		this.z = Math.ceil( this.z );[m
[32m+[m		[32mthis.w = Math.ceil( this.w );[m
 [m
 		return this;[m
 [m
[36m@@ -2033,6 +2314,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = Math.round( this.x );[m
 		this.y = Math.round( this.y );[m
 		this.z = Math.round( this.z );[m
[32m+[m		[32mthis.w = Math.round( this.w );[m
 [m
 		return this;[m
 [m
[36m@@ -2043,6 +2325,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );[m
 		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );[m
 		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );[m
[32m+[m		[32mthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );[m
 [m
 		return this;[m
 [m
[36m@@ -2053,6 +2336,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x = - this.x;[m
 		this.y = - this.y;[m
 		this.z = - this.z;[m
[32m+[m		[32mthis.w = - this.w;[m
 [m
 		return this;[m
 [m
[36m@@ -2060,27 +2344,25 @@[m [mObject.assign( Vector3.prototype, {[m
 [m
 	dot: function ( v ) {[m
 [m
[31m-		return this.x * v.x + this.y * v.y + this.z * v.z;[m
[32m+[m		[32mreturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;[m
 [m
 	},[m
 [m
[31m-	// TODO lengthSquared?[m
[31m-[m
 	lengthSq: function () {[m
 [m
[31m-		return this.x * this.x + this.y * this.y + this.z * this.z;[m
[32m+[m		[32mreturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;[m
 [m
 	},[m
 [m
 	length: function () {[m
 [m
[31m-		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );[m
[32m+[m		[32mreturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );[m
 [m
 	},[m
 [m
 	manhattanLength: function () {[m
 [m
[31m-		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );[m
[32m+[m		[32mreturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );[m
 [m
 	},[m
 [m
[36m@@ -2101,6 +2383,7 @@[m [mObject.assign( Vector3.prototype, {[m
 		this.x += ( v.x - this.x ) * alpha;[m
 		this.y += ( v.y - this.y ) * alpha;[m
 		this.z += ( v.z - this.z ) * alpha;[m
[32m+[m		[32mthis.w += ( v.w - this.w ) * alpha;[m
 [m
 		return this;[m
 [m
[36m@@ -2112,1023 +2395,855 @@[m [mObject.assign( Vector3.prototype, {[m
 [m
 	},[m
 [m
[31m-	cross: function ( v, w ) {[m
[31m-[m
[31m-		if ( w !== undefined ) {[m
[31m-[m
[31m-			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );[m
[31m-			return this.crossVectors( v, w );[m
[31m-[m
[31m-		}[m
[32m+[m	[32mequals: function ( v ) {[m
 [m
[31m-		return this.crossVectors( this, v );[m
[32m+[m		[32mreturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );[m
 [m
 	},[m
 [m
[31m-	crossVectors: function ( a, b ) {[m
[32m+[m	[32mfromArray: function ( array, offset ) {[m
 [m
[31m-		var ax = a.x, ay = a.y, az = a.z;[m
[31m-		var bx = b.x, by = b.y, bz = b.z;[m
[32m+[m		[32mif ( offset === undefined ) offset = 0;[m
 [m
[31m-		this.x = ay * bz - az * by;[m
[31m-		this.y = az * bx - ax * bz;[m
[31m-		this.z = ax * by - ay * bx;[m
[32m+[m		[32mthis.x = array[ offset ];[m
[32m+[m		[32mthis.y = array[ offset + 1 ];[m
[32m+[m		[32mthis.z = array[ offset + 2 ];[m
[32m+[m		[32mthis.w = array[ offset + 3 ];[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	projectOnVector: function ( v ) {[m
[32m+[m	[32mtoArray: function ( array, offset ) {[m
 [m
[31m-		// v cannot be the zero v[m
[32m+[m		[32mif ( array === undefined ) array = [];[m
[32m+[m		[32mif ( offset === undefined ) offset = 0;[m
 [m
[31m-		var scalar = v.dot( this ) / v.lengthSq();[m
[32m+[m		[32marray[ offset ] = this.x;[m
[32m+[m		[32marray[ offset + 1 ] = this.y;[m
[32m+[m		[32marray[ offset + 2 ] = this.z;[m
[32m+[m		[32marray[ offset + 3 ] = this.w;[m
 [m
[31m-		return this.copy( v ).multiplyScalar( scalar );[m
[32m+[m		[32mreturn array;[m
 [m
 	},[m
 [m
[31m-	projectOnPlane: function ( planeNormal ) {[m
[32m+[m	[32mfromBufferAttribute: function ( attribute, index, offset ) {[m
 [m
[31m-		_vector.copy( this ).projectOnVector( planeNormal );[m
[32m+[m		[32mif ( offset !== undefined ) {[m
 [m
[31m-		return this.sub( _vector );[m
[32m+[m			[32mconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );[m
 [m
[31m-	},[m
[32m+[m		[32m}[m
 [m
[31m-	reflect: function ( normal ) {[m
[32m+[m		[32mthis.x = attribute.getX( index );[m
[32m+[m		[32mthis.y = attribute.getY( index );[m
[32m+[m		[32mthis.z = attribute.getZ( index );[m
[32m+[m		[32mthis.w = attribute.getW( index );[m
 [m
[31m-		// reflect incident vector off plane orthogonal to normal[m
[31m-		// normal is assumed to have unit length[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );[m
[32m+[m	[32m}[m
 [m
[31m-	},[m
[32m+[m[32m} );[m
 [m
[31m-	angleTo: function ( v ) {[m
[32m+[m[32m/**[m
[32m+[m[32m * @author szimek / https://github.com/szimek/[m
[32m+[m[32m * @author alteredq / http://alteredqualia.com/[m
[32m+[m[32m * @author Marius Kintel / https://github.com/kintel[m
[32m+[m[32m */[m
 [m
[31m-		var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );[m
[32m+[m[32m/*[m
[32m+[m[32m In options, we can specify:[m
[32m+[m[32m * Texture parameters for an auto-generated target texture[m
[32m+[m[32m * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers[m
[32m+[m[32m*/[m
[32m+[m[32mfunction WebGLRenderTarget( width, height, options ) {[m
 [m
[31m-		if ( denominator === 0 ) console.error( 'THREE.Vector3: angleTo() can\'t handle zero length vectors.' );[m
[32m+[m	[32mthis.width = width;[m
[32m+[m	[32mthis.height = height;[m
 [m
[31m-		var theta = this.dot( v ) / denominator;[m
[32m+[m	[32mthis.scissor = new Vector4( 0, 0, width, height );[m
[32m+[m	[32mthis.scissorTest = false;[m
 [m
[31m-		// clamp, to handle numerical problems[m
[32m+[m	[32mthis.viewport = new Vector4( 0, 0, width, height );[m
 [m
[31m-		return Math.acos( _Math.clamp( theta, - 1, 1 ) );[m
[32m+[m	[32moptions = options || {};[m
 [m
[31m-	},[m
[32m+[m	[32mthis.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );[m
 [m
[31m-	distanceTo: function ( v ) {[m
[32m+[m	[32mthis.texture.image = {};[m
[32m+[m	[32mthis.texture.image.width = width;[m
[32m+[m	[32mthis.texture.image.height = height;[m
 [m
[31m-		return Math.sqrt( this.distanceToSquared( v ) );[m
[32m+[m	[32mthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;[m
[32m+[m	[32mthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;[m
 [m
[31m-	},[m
[32m+[m	[32mthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;[m
[32m+[m	[32mthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;[m
[32m+[m	[32mthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;[m
 [m
[31m-	distanceToSquared: function ( v ) {[m
[32m+[m[32m}[m
 [m
[31m-		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;[m
[32m+[m[32mWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {[m
 [m
[31m-		return dx * dx + dy * dy + dz * dz;[m
[32m+[m	[32mconstructor: WebGLRenderTarget,[m
 [m
[31m-	},[m
[32m+[m	[32misWebGLRenderTarget: true,[m
 [m
[31m-	manhattanDistanceTo: function ( v ) {[m
[32m+[m	[32msetSize: function ( width, height ) {[m
 [m
[31m-		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );[m
[32m+[m		[32mif ( this.width !== width || this.height !== height ) {[m
 [m
[31m-	},[m
[32m+[m			[32mthis.width = width;[m
[32m+[m			[32mthis.height = height;[m
 [m
[31m-	setFromSpherical: function ( s ) {[m
[32m+[m			[32mthis.texture.image.width = width;[m
[32m+[m			[32mthis.texture.image.height = height;[m
 [m
[31m-		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );[m
[32m+[m			[32mthis.dispose();[m
 [m
[31m-	},[m
[32m+[m		[32m}[m
 [m
[31m-	setFromSphericalCoords: function ( radius, phi, theta ) {[m
[32m+[m		[32mthis.viewport.set( 0, 0, width, height );[m
[32m+[m		[32mthis.scissor.set( 0, 0, width, height );[m
 [m
[31m-		var sinPhiRadius = Math.sin( phi ) * radius;[m
[32m+[m	[32m},[m
 [m
[31m-		this.x = sinPhiRadius * Math.sin( theta );[m
[31m-		this.y = Math.cos( phi ) * radius;[m
[31m-		this.z = sinPhiRadius * Math.cos( theta );[m
[32m+[m	[32mclone: function () {[m
 [m
[31m-		return this;[m
[32m+[m		[32mreturn new this.constructor().copy( this );[m
 [m
 	},[m
 [m
[31m-	setFromCylindrical: function ( c ) {[m
[32m+[m	[32mcopy: function ( source ) {[m
 [m
[31m-		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );[m
[32m+[m		[32mthis.width = source.width;[m
[32m+[m		[32mthis.height = source.height;[m
 [m
[31m-	},[m
[32m+[m		[32mthis.viewport.copy( source.viewport );[m
 [m
[31m-	setFromCylindricalCoords: function ( radius, theta, y ) {[m
[32m+[m		[32mthis.texture = source.texture.clone();[m
 [m
[31m-		this.x = radius * Math.sin( theta );[m
[31m-		this.y = y;[m
[31m-		this.z = radius * Math.cos( theta );[m
[32m+[m		[32mthis.depthBuffer = source.depthBuffer;[m
[32m+[m		[32mthis.stencilBuffer = source.stencilBuffer;[m
[32m+[m		[32mthis.depthTexture = source.depthTexture;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setFromMatrixPosition: function ( m ) {[m
[32m+[m	[32mdispose: function () {[m
 [m
[31m-		var e = m.elements;[m
[32m+[m		[32mthis.dispatchEvent( { type: 'dispose' } );[m
 [m
[31m-		this.x = e[ 12 ];[m
[31m-		this.y = e[ 13 ];[m
[31m-		this.z = e[ 14 ];[m
[32m+[m	[32m}[m
 [m
[31m-		return this;[m
[32m+[m[32m} );[m
 [m
[31m-	},[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Mugen87 / https://github.com/Mugen87[m
[32m+[m[32m * @author Matt DesLauriers / @mattdesl[m
[32m+[m[32m */[m
 [m
[31m-	setFromMatrixScale: function ( m ) {[m
[32m+[m[32mfunction WebGLMultisampleRenderTarget( width, height, options ) {[m
 [m
[31m-		var sx = this.setFromMatrixColumn( m, 0 ).length();[m
[31m-		var sy = this.setFromMatrixColumn( m, 1 ).length();[m
[31m-		var sz = this.setFromMatrixColumn( m, 2 ).length();[m
[32m+[m	[32mWebGLRenderTarget.call( this, width, height, options );[m
 [m
[31m-		this.x = sx;[m
[31m-		this.y = sy;[m
[31m-		this.z = sz;[m
[32m+[m	[32mthis.samples = 4;[m
 [m
[31m-		return this;[m
[32m+[m[32m}[m
 [m
[31m-	},[m
[32m+[m[32mWebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {[m
 [m
[31m-	setFromMatrixColumn: function ( m, index ) {[m
[32m+[m	[32mconstructor: WebGLMultisampleRenderTarget,[m
 [m
[31m-		return this.fromArray( m.elements, index * 4 );[m
[32m+[m	[32misWebGLMultisampleRenderTarget: true,[m
 [m
[31m-	},[m
[32m+[m	[32mcopy: function ( source ) {[m
 [m
[31m-	equals: function ( v ) {[m
[32m+[m		[32mWebGLRenderTarget.prototype.copy.call( this, source );[m
 [m
[31m-		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );[m
[32m+[m		[32mthis.samples = source.samples;[m
 [m
[31m-	},[m
[32m+[m		[32mreturn this;[m
 [m
[31m-	fromArray: function ( array, offset ) {[m
[32m+[m	[32m}[m
 [m
[31m-		if ( offset === undefined ) offset = 0;[m
[32m+[m[32m} );[m
 [m
[31m-		this.x = array[ offset ];[m
[31m-		this.y = array[ offset + 1 ];[m
[31m-		this.z = array[ offset + 2 ];[m
[32m+[m[32m/**[m
[32m+[m[32m * @author mikael emtinger / http://gomo.se/[m
[32m+[m[32m * @author alteredq / http://alteredqualia.com/[m
[32m+[m[32m * @author WestLangley / http://github.com/WestLangley[m
[32m+[m[32m * @author bhouston / http://clara.io[m
[32m+[m[32m */[m
 [m
[31m-		return this;[m
[32m+[m[32mfunction Quaternion( x, y, z, w ) {[m
 [m
[31m-	},[m
[32m+[m	[32mthis._x = x || 0;[m
[32m+[m	[32mthis._y = y || 0;[m
[32m+[m	[32mthis._z = z || 0;[m
[32m+[m	[32mthis._w = ( w !== undefined ) ? w : 1;[m
 [m
[31m-	toArray: function ( array, offset ) {[m
[32m+[m[32m}[m
 [m
[31m-		if ( array === undefined ) array = [];[m
[31m-		if ( offset === undefined ) offset = 0;[m
[32m+[m[32mObject.assign( Quaternion, {[m
 [m
[31m-		array[ offset ] = this.x;[m
[31m-		array[ offset + 1 ] = this.y;[m
[31m-		array[ offset + 2 ] = this.z;[m
[32m+[m	[32mslerp: function ( qa, qb, qm, t ) {[m
 [m
[31m-		return array;[m
[32m+[m		[32mreturn qm.copy( qa ).slerp( qb, t );[m
 [m
 	},[m
 [m
[31m-	fromBufferAttribute: function ( attribute, index, offset ) {[m
[32m+[m	[32mslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {[m
 [m
[31m-		if ( offset !== undefined ) {[m
[32m+[m		[32m// fuzz-free, array-based Quaternion SLERP operation[m
 [m
[31m-			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );[m
[32m+[m		[32mvar x0 = src0[ srcOffset0 + 0 ],[m
[32m+[m			[32my0 = src0[ srcOffset0 + 1 ],[m
[32m+[m			[32mz0 = src0[ srcOffset0 + 2 ],[m
[32m+[m			[32mw0 = src0[ srcOffset0 + 3 ],[m
 [m
[31m-		}[m
[32m+[m			[32mx1 = src1[ srcOffset1 + 0 ],[m
[32m+[m			[32my1 = src1[ srcOffset1 + 1 ],[m
[32m+[m			[32mz1 = src1[ srcOffset1 + 2 ],[m
[32m+[m			[32mw1 = src1[ srcOffset1 + 3 ];[m
 [m
[31m-		this.x = attribute.getX( index );[m
[31m-		this.y = attribute.getY( index );[m
[31m-		this.z = attribute.getZ( index );[m
[32m+[m		[32mif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {[m
 [m
[31m-		return this;[m
[32m+[m			[32mvar s = 1 - t,[m
 [m
[31m-	}[m
[32m+[m				[32mcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,[m
 [m
[31m-} );[m
[32m+[m				[32mdir = ( cos >= 0 ? 1 : - 1 ),[m
[32m+[m				[32msqrSin = 1 - cos * cos;[m
 [m
[31m-/**[m
[31m- * @author alteredq / http://alteredqualia.com/[m
[31m- * @author WestLangley / http://github.com/WestLangley[m
[31m- * @author bhouston / http://clara.io[m
[31m- * @author tschw[m
[31m- */[m
[32m+[m			[32m// Skip the Slerp for tiny steps to avoid numeric problems:[m
[32m+[m			[32mif ( sqrSin > Number.EPSILON ) {[m
 [m
[31m-var _vector$1 = new Vector3();[m
[32m+[m				[32mvar sin = Math.sqrt( sqrSin ),[m
[32m+[m					[32mlen = Math.atan2( sin, cos * dir );[m
 [m
[31m-function Matrix3() {[m
[32m+[m				[32ms = Math.sin( s * len ) / sin;[m
[32m+[m				[32mt = Math.sin( t * len ) / sin;[m
 [m
[31m-	this.elements = [[m
[32m+[m			[32m}[m
 [m
[31m-		1, 0, 0,[m
[31m-		0, 1, 0,[m
[31m-		0, 0, 1[m
[32m+[m			[32mvar tDir = t * dir;[m
 [m
[31m-	];[m
[32m+[m			[32mx0 = x0 * s + x1 * tDir;[m
[32m+[m			[32my0 = y0 * s + y1 * tDir;[m
[32m+[m			[32mz0 = z0 * s + z1 * tDir;[m
[32m+[m			[32mw0 = w0 * s + w1 * tDir;[m
 [m
[31m-	if ( arguments.length > 0 ) {[m
[32m+[m			[32m// Normalize in case we just did a lerp:[m
[32m+[m			[32mif ( s === 1 - t ) {[m
 [m
[31m-		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );[m
[32m+[m				[32mvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );[m
 [m
[31m-	}[m
[32m+[m				[32mx0 *= f;[m
[32m+[m				[32my0 *= f;[m
[32m+[m				[32mz0 *= f;[m
[32m+[m				[32mw0 *= f;[m
 [m
[31m-}[m
[32m+[m			[32m}[m
 [m
[31m-Object.assign( Matrix3.prototype, {[m
[32m+[m		[32m}[m
 [m
[31m-	isMatrix3: true,[m
[32m+[m		[32mdst[ dstOffset ] = x0;[m
[32m+[m		[32mdst[ dstOffset + 1 ] = y0;[m
[32m+[m		[32mdst[ dstOffset + 2 ] = z0;[m
[32m+[m		[32mdst[ dstOffset + 3 ] = w0;[m
 [m
[31m-	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {[m
[32m+[m	[32m}[m
 [m
[31m-		var te = this.elements;[m
[32m+[m[32m} );[m
 [m
[31m-		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;[m
[31m-		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;[m
[31m-		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;[m
[32m+[m[32mObject.defineProperties( Quaternion.prototype, {[m
 [m
[31m-		return this;[m
[32m+[m	[32mx: {[m
 [m
[31m-	},[m
[32m+[m		[32mget: function () {[m
 [m
[31m-	identity: function () {[m
[32m+[m			[32mreturn this._x;[m
 [m
[31m-		this.set([m
[32m+[m		[32m},[m
 [m
[31m-			1, 0, 0,[m
[31m-			0, 1, 0,[m
[31m-			0, 0, 1[m
[32m+[m		[32mset: function ( value ) {[m
 [m
[31m-		);[m
[32m+[m			[32mthis._x = value;[m
[32m+[m			[32mthis._onChangeCallback();[m
 [m
[31m-		return this;[m
[32m+[m		[32m}[m
 [m
 	},[m
 [m
[31m-	clone: function () {[m
[32m+[m	[32my: {[m
 [m
[31m-		return new this.constructor().fromArray( this.elements );[m
[32m+[m		[32mget: function () {[m
 [m
[31m-	},[m
[32m+[m			[32mreturn this._y;[m
 [m
[31m-	copy: function ( m ) {[m
[32m+[m		[32m},[m
 [m
[31m-		var te = this.elements;[m
[31m-		var me = m.elements;[m
[32m+[m		[32mset: function ( value ) {[m
 [m
[31m-		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];[m
[31m-		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];[m
[31m-		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];[m
[32m+[m			[32mthis._y = value;[m
[32m+[m			[32mthis._onChangeCallback();[m
 [m
[31m-		return this;[m
[32m+[m		[32m}[m
 [m
 	},[m
 [m
[31m-	setFromMatrix4: function ( m ) {[m
[32m+[m	[32mz: {[m
 [m
[31m-		var me = m.elements;[m
[32m+[m		[32mget: function () {[m
 [m
[31m-		this.set([m
[32m+[m			[32mreturn this._z;[m
 [m
[31m-			me[ 0 ], me[ 4 ], me[ 8 ],[m
[31m-			me[ 1 ], me[ 5 ], me[ 9 ],[m
[31m-			me[ 2 ], me[ 6 ], me[ 10 ][m
[32m+[m		[32m},[m
 [m
[31m-		);[m
[32m+[m		[32mset: function ( value ) {[m
 [m
[31m-		return this;[m
[32m+[m			[32mthis._z = value;[m
[32m+[m			[32mthis._onChangeCallback();[m
[32m+[m
[32m+[m		[32m}[m
 [m
 	},[m
 [m
[31m-	applyToBufferAttribute: function ( attribute ) {[m
[32m+[m	[32mw: {[m
 [m
[31m-		for ( var i = 0, l = attribute.count; i < l; i ++ ) {[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mreturn this._w;[m
 [m
[31m-			_vector$1.x = attribute.getX( i );[m
[31m-			_vector$1.y = attribute.getY( i );[m
[31m-			_vector$1.z = attribute.getZ( i );[m
[32m+[m		[32m},[m
 [m
[31m-			_vector$1.applyMatrix3( this );[m
[32m+[m		[32mset: function ( value ) {[m
 [m
[31m-			attribute.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );[m
[32m+[m			[32mthis._w = value;[m
[32m+[m			[32mthis._onChangeCallback();[m
 [m
 		}[m
 [m
[31m-		return attribute;[m
[32m+[m	[32m}[m
 [m
[31m-	},[m
[32m+[m[32m} );[m
 [m
[31m-	multiply: function ( m ) {[m
[32m+[m[32mObject.assign( Quaternion.prototype, {[m
 [m
[31m-		return this.multiplyMatrices( this, m );[m
[32m+[m	[32misQuaternion: true,[m
 [m
[31m-	},[m
[32m+[m	[32mset: function ( x, y, z, w ) {[m
 [m
[31m-	premultiply: function ( m ) {[m
[32m+[m		[32mthis._x = x;[m
[32m+[m		[32mthis._y = y;[m
[32m+[m		[32mthis._z = z;[m
[32m+[m		[32mthis._w = w;[m
 [m
[31m-		return this.multiplyMatrices( m, this );[m
[32m+[m		[32mthis._onChangeCallback();[m
[32m+[m
[32m+[m		[32mreturn this;[m
 [m
 	},[m
 [m
[31m-	multiplyMatrices: function ( a, b ) {[m
[32m+[m	[32mclone: function () {[m
 [m
[31m-		var ae = a.elements;[m
[31m-		var be = b.elements;[m
[31m-		var te = this.elements;[m
[32m+[m		[32mreturn new this.constructor( this._x, this._y, this._z, this._w );[m
 [m
[31m-		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];[m
[31m-		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];[m
[31m-		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];[m
[32m+[m	[32m},[m
 [m
[31m-		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];[m
[31m-		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];[m
[31m-		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];[m
[32m+[m	[32mcopy: function ( quaternion ) {[m
 [m
[31m-		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;[m
[31m-		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;[m
[31m-		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;[m
[32m+[m		[32mthis._x = quaternion.x;[m
[32m+[m		[32mthis._y = quaternion.y;[m
[32m+[m		[32mthis._z = quaternion.z;[m
[32m+[m		[32mthis._w = quaternion.w;[m
 [m
[31m-		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;[m
[31m-		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;[m
[31m-		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;[m
[31m-[m
[31m-		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;[m
[31m-		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;[m
[31m-		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;[m
[32m+[m		[32mthis._onChangeCallback();[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	multiplyScalar: function ( s ) {[m
[31m-[m
[31m-		var te = this.elements;[m
[31m-[m
[31m-		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;[m
[31m-		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;[m
[31m-		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;[m
[31m-[m
[31m-		return this;[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	determinant: function () {[m
[31m-[m
[31m-		var te = this.elements;[m
[31m-[m
[31m-		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],[m
[31m-			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],[m
[31m-			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];[m
[31m-[m
[31m-		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	getInverse: function ( matrix, throwOnDegenerate ) {[m
[32m+[m	[32msetFromEuler: function ( euler, update ) {[m
 [m
[31m-		if ( matrix && matrix.isMatrix4 ) {[m
[32m+[m		[32mif ( ! ( euler && euler.isEuler ) ) {[m
 [m
[31m-			console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );[m
[32m+[m			[32mthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );[m
 [m
 		}[m
 [m
[31m-		var me = matrix.elements,[m
[31m-			te = this.elements,[m
[31m-[m
[31m-			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],[m
[31m-			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],[m
[31m-			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],[m
[31m-[m
[31m-			t11 = n33 * n22 - n32 * n23,[m
[31m-			t12 = n32 * n13 - n33 * n12,[m
[31m-			t13 = n23 * n12 - n22 * n13,[m
[31m-[m
[31m-			det = n11 * t11 + n21 * t12 + n31 * t13;[m
[32m+[m		[32mvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;[m
 [m
[31m-		if ( det === 0 ) {[m
[32m+[m		[32m// http://www.mathworks.com/matlabcentral/fileexchange/[m
[32m+[m		[32m// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/[m
[32m+[m		[32m//	content/SpinCalc.m[m
 [m
[31m-			var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";[m
[32m+[m		[32mvar cos = Math.cos;[m
[32m+[m		[32mvar sin = Math.sin;[m
 [m
[31m-			if ( throwOnDegenerate === true ) {[m
[32m+[m		[32mvar c1 = cos( x / 2 );[m
[32m+[m		[32mvar c2 = cos( y / 2 );[m
[32m+[m		[32mvar c3 = cos( z / 2 );[m
 [m
[31m-				throw new Error( msg );[m
[32m+[m		[32mvar s1 = sin( x / 2 );[m
[32m+[m		[32mvar s2 = sin( y / 2 );[m
[32m+[m		[32mvar s3 = sin( z / 2 );[m
 [m
[31m-			} else {[m
[32m+[m		[32mif ( order === 'XYZ' ) {[m
 [m
[31m-				console.warn( msg );[m
[32m+[m			[32mthis._x = s1 * c2 * c3 + c1 * s2 * s3;[m
[32m+[m			[32mthis._y = c1 * s2 * c3 - s1 * c2 * s3;[m
[32m+[m			[32mthis._z = c1 * c2 * s3 + s1 * s2 * c3;[m
[32m+[m			[32mthis._w = c1 * c2 * c3 - s1 * s2 * s3;[m
 [m
[31m-			}[m
[32m+[m		[32m} else if ( order === 'YXZ' ) {[m
 [m
[31m-			return this.identity();[m
[32m+[m			[32mthis._x = s1 * c2 * c3 + c1 * s2 * s3;[m
[32m+[m			[32mthis._y = c1 * s2 * c3 - s1 * c2 * s3;[m
[32m+[m			[32mthis._z = c1 * c2 * s3 - s1 * s2 * c3;[m
[32m+[m			[32mthis._w = c1 * c2 * c3 + s1 * s2 * s3;[m
 [m
[31m-		}[m
[32m+[m		[32m} else if ( order === 'ZXY' ) {[m
 [m
[31m-		var detInv = 1 / det;[m
[32m+[m			[32mthis._x = s1 * c2 * c3 - c1 * s2 * s3;[m
[32m+[m			[32mthis._y = c1 * s2 * c3 + s1 * c2 * s3;[m
[32m+[m			[32mthis._z = c1 * c2 * s3 + s1 * s2 * c3;[m
[32m+[m			[32mthis._w = c1 * c2 * c3 - s1 * s2 * s3;[m
 [m
[31m-		te[ 0 ] = t11 * detInv;[m
[31m-		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;[m
[31m-		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;[m
[32m+[m		[32m} else if ( order === 'ZYX' ) {[m
 [m
[31m-		te[ 3 ] = t12 * detInv;[m
[31m-		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;[m
[31m-		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;[m
[32m+[m			[32mthis._x = s1 * c2 * c3 - c1 * s2 * s3;[m
[32m+[m			[32mthis._y = c1 * s2 * c3 + s1 * c2 * s3;[m
[32m+[m			[32mthis._z = c1 * c2 * s3 - s1 * s2 * c3;[m
[32m+[m			[32mthis._w = c1 * c2 * c3 + s1 * s2 * s3;[m
 [m
[31m-		te[ 6 ] = t13 * detInv;[m
[31m-		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;[m
[31m-		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;[m
[32m+[m		[32m} else if ( order === 'YZX' ) {[m
 [m
[31m-		return this;[m
[32m+[m			[32mthis._x = s1 * c2 * c3 + c1 * s2 * s3;[m
[32m+[m			[32mthis._y = c1 * s2 * c3 + s1 * c2 * s3;[m
[32m+[m			[32mthis._z = c1 * c2 * s3 - s1 * s2 * c3;[m
[32m+[m			[32mthis._w = c1 * c2 * c3 - s1 * s2 * s3;[m
 [m
[31m-	},[m
[32m+[m		[32m} else if ( order === 'XZY' ) {[m
 [m
[31m-	transpose: function () {[m
[32m+[m			[32mthis._x = s1 * c2 * c3 - c1 * s2 * s3;[m
[32m+[m			[32mthis._y = c1 * s2 * c3 - s1 * c2 * s3;[m
[32m+[m			[32mthis._z = c1 * c2 * s3 + s1 * s2 * c3;[m
[32m+[m			[32mthis._w = c1 * c2 * c3 + s1 * s2 * s3;[m
 [m
[31m-		var tmp, m = this.elements;[m
[32m+[m		[32m}[m
 [m
[31m-		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;[m
[31m-		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;[m
[31m-		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;[m
[32m+[m		[32mif ( update !== false ) this._onChangeCallback();[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	getNormalMatrix: function ( matrix4 ) {[m
[32m+[m	[32msetFromAxisAngle: function ( axis, angle ) {[m
 [m
[31m-		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();[m
[32m+[m		[32m// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm[m
 [m
[31m-	},[m
[32m+[m		[32m// assumes axis is normalized[m
 [m
[31m-	transposeIntoArray: function ( r ) {[m
[32m+[m		[32mvar halfAngle = angle / 2, s = Math.sin( halfAngle );[m
 [m
[31m-		var m = this.elements;[m
[32m+[m		[32mthis._x = axis.x * s;[m
[32m+[m		[32mthis._y = axis.y * s;[m
[32m+[m		[32mthis._z = axis.z * s;[m
[32m+[m		[32mthis._w = Math.cos( halfAngle );[m
 [m
[31m-		r[ 0 ] = m[ 0 ];[m
[31m-		r[ 1 ] = m[ 3 ];[m
[31m-		r[ 2 ] = m[ 6 ];[m
[31m-		r[ 3 ] = m[ 1 ];[m
[31m-		r[ 4 ] = m[ 4 ];[m
[31m-		r[ 5 ] = m[ 7 ];[m
[31m-		r[ 6 ] = m[ 2 ];[m
[31m-		r[ 7 ] = m[ 5 ];[m
[31m-		r[ 8 ] = m[ 8 ];[m
[32m+[m		[32mthis._onChangeCallback();[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {[m
[31m-[m
[31m-		var c = Math.cos( rotation );[m
[31m-		var s = Math.sin( rotation );[m
[31m-[m
[31m-		this.set([m
[31m-			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,[m
[31m-			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,[m
[31m-			0, 0, 1[m
[31m-		);[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	scale: function ( sx, sy ) {[m
[31m-[m
[31m-		var te = this.elements;[m
[31m-[m
[31m-		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;[m
[31m-		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;[m
[31m-[m
[31m-		return this;[m
[31m-[m
[31m-	},[m
[32m+[m	[32msetFromRotationMatrix: function ( m ) {[m
 [m
[31m-	rotate: function ( theta ) {[m
[32m+[m		[32m// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm[m
 [m
[31m-		var c = Math.cos( theta );[m
[31m-		var s = Math.sin( theta );[m
[32m+[m		[32m// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)[m
 [m
[31m-		var te = this.elements;[m
[32m+[m		[32mvar te = m.elements,[m
 [m
[31m-		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];[m
[31m-		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];[m
[32m+[m			[32mm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],[m
[32m+[m			[32mm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],[m
[32m+[m			[32mm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],[m
 [m
[31m-		te[ 0 ] = c * a11 + s * a21;[m
[31m-		te[ 3 ] = c * a12 + s * a22;[m
[31m-		te[ 6 ] = c * a13 + s * a23;[m
[32m+[m			[32mtrace = m11 + m22 + m33,[m
[32m+[m			[32ms;[m
 [m
[31m-		te[ 1 ] = - s * a11 + c * a21;[m
[31m-		te[ 4 ] = - s * a12 + c * a22;[m
[31m-		te[ 7 ] = - s * a13 + c * a23;[m
[32m+[m		[32mif ( trace > 0 ) {[m
 [m
[31m-		return this;[m
[32m+[m			[32ms = 0.5 / Math.sqrt( trace + 1.0 );[m
 [m
[31m-	},[m
[32m+[m			[32mthis._w = 0.25 / s;[m
[32m+[m			[32mthis._x = ( m32 - m23 ) * s;[m
[32m+[m			[32mthis._y = ( m13 - m31 ) * s;[m
[32m+[m			[32mthis._z = ( m21 - m12 ) * s;[m
 [m
[31m-	translate: function ( tx, ty ) {[m
[32m+[m		[32m} else if ( m11 > m22 && m11 > m33 ) {[m
 [m
[31m-		var te = this.elements;[m
[32m+[m			[32ms = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );[m
 [m
[31m-		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];[m
[31m-		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];[m
[32m+[m			[32mthis._w = ( m32 - m23 ) / s;[m
[32m+[m			[32mthis._x = 0.25 * s;[m
[32m+[m			[32mthis._y = ( m12 + m21 ) / s;[m
[32m+[m			[32mthis._z = ( m13 + m31 ) / s;[m
 [m
[31m-		return this;[m
[32m+[m		[32m} else if ( m22 > m33 ) {[m
 [m
[31m-	},[m
[32m+[m			[32ms = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );[m
 [m
[31m-	equals: function ( matrix ) {[m
[32m+[m			[32mthis._w = ( m13 - m31 ) / s;[m
[32m+[m			[32mthis._x = ( m12 + m21 ) / s;[m
[32m+[m			[32mthis._y = 0.25 * s;[m
[32m+[m			[32mthis._z = ( m23 + m32 ) / s;[m
 [m
[31m-		var te = this.elements;[m
[31m-		var me = matrix.elements;[m
[32m+[m		[32m} else {[m
 [m
[31m-		for ( var i = 0; i < 9; i ++ ) {[m
[32m+[m			[32ms = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );[m
 [m
[31m-			if ( te[ i ] !== me[ i ] ) return false;[m
[32m+[m			[32mthis._w = ( m21 - m12 ) / s;[m
[32m+[m			[32mthis._x = ( m13 + m31 ) / s;[m
[32m+[m			[32mthis._y = ( m23 + m32 ) / s;[m
[32m+[m			[32mthis._z = 0.25 * s;[m
 [m
 		}[m
 [m
[31m-		return true;[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	fromArray: function ( array, offset ) {[m
[31m-[m
[31m-		if ( offset === undefined ) offset = 0;[m
[31m-[m
[31m-		for ( var i = 0; i < 9; i ++ ) {[m
[31m-[m
[31m-			this.elements[ i ] = array[ i + offset ];[m
[31m-[m
[31m-		}[m
[32m+[m		[32mthis._onChangeCallback();[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	toArray: function ( array, offset ) {[m
[31m-[m
[31m-		if ( array === undefined ) array = [];[m
[31m-		if ( offset === undefined ) offset = 0;[m
[31m-[m
[31m-		var te = this.elements;[m
[31m-[m
[31m-		array[ offset ] = te[ 0 ];[m
[31m-		array[ offset + 1 ] = te[ 1 ];[m
[31m-		array[ offset + 2 ] = te[ 2 ];[m
[31m-[m
[31m-		array[ offset + 3 ] = te[ 3 ];[m
[31m-		array[ offset + 4 ] = te[ 4 ];[m
[31m-		array[ offset + 5 ] = te[ 5 ];[m
[31m-[m
[31m-		array[ offset + 6 ] = te[ 6 ];[m
[31m-		array[ offset + 7 ] = te[ 7 ];[m
[31m-		array[ offset + 8 ] = te[ 8 ];[m
[31m-[m
[31m-		return array;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-} );[m
[31m-[m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- * @author alteredq / http://alteredqualia.com/[m
[31m- * @author szimek / https://github.com/szimek/[m
[31m- */[m
[31m-[m
[31m-var _canvas;[m
[31m-[m
[31m-var ImageUtils = {[m
[31m-[m
[31m-	getDataURL: function ( image ) {[m
[31m-[m
[31m-		var canvas;[m
[31m-[m
[31m-		if ( typeof HTMLCanvasElement == 'undefined' ) {[m
[31m-[m
[31m-			return image.src;[m
[31m-[m
[31m-		} else if ( image instanceof HTMLCanvasElement ) {[m
[32m+[m	[32msetFromUnitVectors: function ( vFrom, vTo ) {[m
 [m
[31m-			canvas = image;[m
[32m+[m		[32m// assumes direction vectors vFrom and vTo are normalized[m
 [m
[31m-		} else {[m
[32m+[m		[32mvar EPS = 0.000001;[m
 [m
[31m-			if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );[m
[32m+[m		[32mvar r = vFrom.dot( vTo ) + 1;[m
 [m
[31m-			_canvas.width = image.width;[m
[31m-			_canvas.height = image.height;[m
[32m+[m		[32mif ( r < EPS ) {[m
 [m
[31m-			var context = _canvas.getContext( '2d' );[m
[32m+[m			[32mr = 0;[m
 [m
[31m-			if ( image instanceof ImageData ) {[m
[32m+[m			[32mif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {[m
 [m
[31m-				context.putImageData( image, 0, 0 );[m
[32m+[m				[32mthis._x = - vFrom.y;[m
[32m+[m				[32mthis._y = vFrom.x;[m
[32m+[m				[32mthis._z = 0;[m
[32m+[m				[32mthis._w = r;[m
 [m
 			} else {[m
 [m
[31m-				context.drawImage( image, 0, 0, image.width, image.height );[m
[32m+[m				[32mthis._x = 0;[m
[32m+[m				[32mthis._y = - vFrom.z;[m
[32m+[m				[32mthis._z = vFrom.y;[m
[32m+[m				[32mthis._w = r;[m
 [m
 			}[m
 [m
[31m-			canvas = _canvas;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		if ( canvas.width > 2048 || canvas.height > 2048 ) {[m
[31m-[m
[31m-			return canvas.toDataURL( 'image/jpeg', 0.6 );[m
[31m-[m
 		} else {[m
 [m
[31m-			return canvas.toDataURL( 'image/png' );[m
[32m+[m			[32m// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3[m
[32m+[m
[32m+[m			[32mthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;[m
[32m+[m			[32mthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;[m
[32m+[m			[32mthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;[m
[32m+[m			[32mthis._w = r;[m
 [m
 		}[m
 [m
[31m-	}[m
[32m+[m		[32mreturn this.normalize();[m
 [m
[31m-};[m
[32m+[m	[32m},[m
 [m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- * @author alteredq / http://alteredqualia.com/[m
[31m- * @author szimek / https://github.com/szimek/[m
[31m- */[m
[32m+[m	[32mangleTo: function ( q ) {[m
 [m
[31m-var textureId = 0;[m
[32m+[m		[32mreturn 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );[m
 [m
[31m-function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {[m
[32m+[m	[32m},[m
 [m
[31m-	Object.defineProperty( this, 'id', { value: textureId ++ } );[m
[32m+[m	[32mrotateTowards: function ( q, step ) {[m
 [m
[31m-	this.uuid = _Math.generateUUID();[m
[32m+[m		[32mvar angle = this.angleTo( q );[m
 [m
[31m-	this.name = '';[m
[32m+[m		[32mif ( angle === 0 ) return this;[m
 [m
[31m-	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;[m
[31m-	this.mipmaps = [];[m
[32m+[m		[32mvar t = Math.min( 1, step / angle );[m
 [m
[31m-	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;[m
[32m+[m		[32mthis.slerp( q, t );[m
 [m
[31m-	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;[m
[31m-	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;[m
[31m-	this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;[m
[32m+[m	[32m},[m
 [m
[31m-	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;[m
[32m+[m	[32minverse: function () {[m
 [m
[31m-	this.format = format !== undefined ? format : RGBAFormat;[m
[31m-	this.type = type !== undefined ? type : UnsignedByteType;[m
[32m+[m		[32m// quaternion is assumed to have unit length[m
 [m
[31m-	this.offset = new Vector2( 0, 0 );[m
[31m-	this.repeat = new Vector2( 1, 1 );[m
[31m-	this.center = new Vector2( 0, 0 );[m
[31m-	this.rotation = 0;[m
[32m+[m		[32mreturn this.conjugate();[m
 [m
[31m-	this.matrixAutoUpdate = true;[m
[31m-	this.matrix = new Matrix3();[m
[32m+[m	[32m},[m
 [m
[31m-	this.generateMipmaps = true;[m
[31m-	this.premultiplyAlpha = false;[m
[31m-	this.flipY = true;[m
[31m-	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)[m
[32m+[m	[32mconjugate: function () {[m
 [m
[31m-	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.[m
[31m-	//[m
[31m-	// Also changing the encoding after already used by a Material will not automatically make the Material[m
[31m-	// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.[m
[31m-	this.encoding = encoding !== undefined ? encoding : LinearEncoding;[m
[32m+[m		[32mthis._x *= - 1;[m
[32m+[m		[32mthis._y *= - 1;[m
[32m+[m		[32mthis._z *= - 1;[m
 [m
[31m-	this.version = 0;[m
[31m-	this.onUpdate = null;[m
[32m+[m		[32mthis._onChangeCallback();[m
 [m
[31m-}[m
[32m+[m		[32mreturn this;[m
 [m
[31m-Texture.DEFAULT_IMAGE = undefined;[m
[31m-Texture.DEFAULT_MAPPING = UVMapping;[m
[32m+[m	[32m},[m
 [m
[31m-Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {[m
[32m+[m	[32mdot: function ( v ) {[m
 [m
[31m-	constructor: Texture,[m
[32m+[m		[32mreturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;[m
 [m
[31m-	isTexture: true,[m
[32m+[m	[32m},[m
 [m
[31m-	updateMatrix: function () {[m
[32m+[m	[32mlengthSq: function () {[m
 [m
[31m-		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );[m
[32m+[m		[32mreturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;[m
 [m
 	},[m
 [m
[31m-	clone: function () {[m
[32m+[m	[32mlength: function () {[m
 [m
[31m-		return new this.constructor().copy( this );[m
[32m+[m		[32mreturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );[m
 [m
 	},[m
 [m
[31m-	copy: function ( source ) {[m
[31m-[m
[31m-		this.name = source.name;[m
[31m-[m
[31m-		this.image = source.image;[m
[31m-		this.mipmaps = source.mipmaps.slice( 0 );[m
[32m+[m	[32mnormalize: function () {[m
 [m
[31m-		this.mapping = source.mapping;[m
[32m+[m		[32mvar l = this.length();[m
 [m
[31m-		this.wrapS = source.wrapS;[m
[31m-		this.wrapT = source.wrapT;[m
[32m+[m		[32mif ( l === 0 ) {[m
 [m
[31m-		this.magFilter = source.magFilter;[m
[31m-		this.minFilter = source.minFilter;[m
[32m+[m			[32mthis._x = 0;[m
[32m+[m			[32mthis._y = 0;[m
[32m+[m			[32mthis._z = 0;[m
[32m+[m			[32mthis._w = 1;[m
 [m
[31m-		this.anisotropy = source.anisotropy;[m
[32m+[m		[32m} else {[m
 [m
[31m-		this.format = source.format;[m
[31m-		this.type = source.type;[m
[32m+[m			[32ml = 1 / l;[m
 [m
[31m-		this.offset.copy( source.offset );[m
[31m-		this.repeat.copy( source.repeat );[m
[31m-		this.center.copy( source.center );[m
[31m-		this.rotation = source.rotation;[m
[32m+[m			[32mthis._x = this._x * l;[m
[32m+[m			[32mthis._y = this._y * l;[m
[32m+[m			[32mthis._z = this._z * l;[m
[32m+[m			[32mthis._w = this._w * l;[m
 [m
[31m-		this.matrixAutoUpdate = source.matrixAutoUpdate;[m
[31m-		this.matrix.copy( source.matrix );[m
[32m+[m		[32m}[m
 [m
[31m-		this.generateMipmaps = source.generateMipmaps;[m
[31m-		this.premultiplyAlpha = source.premultiplyAlpha;[m
[31m-		this.flipY = source.flipY;[m
[31m-		this.unpackAlignment = source.unpackAlignment;[m
[31m-		this.encoding = source.encoding;[m
[32m+[m		[32mthis._onChangeCallback();[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	toJSON: function ( meta ) {[m
[31m-[m
[31m-		var isRootObject = ( meta === undefined || typeof meta === 'string' );[m
[32m+[m	[32mmultiply: function ( q, p ) {[m
 [m
[31m-		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {[m
[32m+[m		[32mif ( p !== undefined ) {[m
 [m
[31m-			return meta.textures[ this.uuid ];[m
[32m+[m			[32mconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );[m
[32m+[m			[32mreturn this.multiplyQuaternions( q, p );[m
 [m
 		}[m
 [m
[31m-		var output = {[m
[32m+[m		[32mreturn this.multiplyQuaternions( this, q );[m
 [m
[31m-			metadata: {[m
[31m-				version: 4.5,[m
[31m-				type: 'Texture',[m
[31m-				generator: 'Texture.toJSON'[m
[31m-			},[m
[32m+[m	[32m},[m
 [m
[31m-			uuid: this.uuid,[m
[31m-			name: this.name,[m
[32m+[m	[32mpremultiply: function ( q ) {[m
 [m
[31m-			mapping: this.mapping,[m
[32m+[m		[32mreturn this.multiplyQuaternions( q, this );[m
 [m
[31m-			repeat: [ this.repeat.x, this.repeat.y ],[m
[31m-			offset: [ this.offset.x, this.offset.y ],[m
[31m-			center: [ this.center.x, this.center.y ],[m
[31m-			rotation: this.rotation,[m
[32m+[m	[32m},[m
 [m
[31m-			wrap: [ this.wrapS, this.wrapT ],[m
[32m+[m	[32mmultiplyQuaternions: function ( a, b ) {[m
 [m
[31m-			format: this.format,[m
[31m-			type: this.type,[m
[31m-			encoding: this.encoding,[m
[32m+[m		[32m// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm[m
 [m
[31m-			minFilter: this.minFilter,[m
[31m-			magFilter: this.magFilter,[m
[31m-			anisotropy: this.anisotropy,[m
[32m+[m		[32mvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;[m
[32m+[m		[32mvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;[m
 [m
[31m-			flipY: this.flipY,[m
[32m+[m		[32mthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;[m
[32m+[m		[32mthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;[m
[32m+[m		[32mthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;[m
[32m+[m		[32mthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;[m
 [m
[31m-			premultiplyAlpha: this.premultiplyAlpha,[m
[31m-			unpackAlignment: this.unpackAlignment[m
[32m+[m		[32mthis._onChangeCallback();[m
 [m
[31m-		};[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		if ( this.image !== undefined ) {[m
[32m+[m	[32m},[m
 [m
[31m-			// TODO: Move to THREE.Image[m
[32m+[m	[32mslerp: function ( qb, t ) {[m
 [m
[31m-			var image = this.image;[m
[32m+[m		[32mif ( t === 0 ) return this;[m
[32m+[m		[32mif ( t === 1 ) return this.copy( qb );[m
 [m
[31m-			if ( image.uuid === undefined ) {[m
[32m+[m		[32mvar x = this._x, y = this._y, z = this._z, w = this._w;[m
 [m
[31m-				image.uuid = _Math.generateUUID(); // UGH[m
[32m+[m		[32m// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/[m
 [m
[31m-			}[m
[32m+[m		[32mvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;[m
 [m
[31m-			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {[m
[32m+[m		[32mif ( cosHalfTheta < 0 ) {[m
 [m
[31m-				var url;[m
[32m+[m			[32mthis._w = - qb._w;[m
[32m+[m			[32mthis._x = - qb._x;[m
[32m+[m			[32mthis._y = - qb._y;[m
[32m+[m			[32mthis._z = - qb._z;[m
 [m
[31m-				if ( Array.isArray( image ) ) {[m
[32m+[m			[32mcosHalfTheta = - cosHalfTheta;[m
 [m
[31m-					// process array of images e.g. CubeTexture[m
[32m+[m		[32m} else {[m
 [m
[31m-					url = [];[m
[32m+[m			[32mthis.copy( qb );[m
 [m
[31m-					for ( var i = 0, l = image.length; i < l; i ++ ) {[m
[32m+[m		[32m}[m
 [m
[31m-						url.push( ImageUtils.getDataURL( image[ i ] ) );[m
[32m+[m		[32mif ( cosHalfTheta >= 1.0 ) {[m
 [m
[31m-					}[m
[32m+[m			[32mthis._w = w;[m
[32m+[m			[32mthis._x = x;[m
[32m+[m			[32mthis._y = y;[m
[32m+[m			[32mthis._z = z;[m
 [m
[31m-				} else {[m
[32m+[m			[32mreturn this;[m
 [m
[31m-					// process single image[m
[32m+[m		[32m}[m
 [m
[31m-					url = ImageUtils.getDataURL( image );[m
[32m+[m		[32mvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;[m
 [m
[31m-				}[m
[32m+[m		[32mif ( sqrSinHalfTheta <= Number.EPSILON ) {[m
 [m
[31m-				meta.images[ image.uuid ] = {[m
[31m-					uuid: image.uuid,[m
[31m-					url: url[m
[31m-				};[m
[32m+[m			[32mvar s = 1 - t;[m
[32m+[m			[32mthis._w = s * w + t * this._w;[m
[32m+[m			[32mthis._x = s * x + t * this._x;[m
[32m+[m			[32mthis._y = s * y + t * this._y;[m
[32m+[m			[32mthis._z = s * z + t * this._z;[m
 [m
[31m-			}[m
[32m+[m			[32mthis.normalize();[m
[32m+[m			[32mthis._onChangeCallback();[m
 [m
[31m-			output.image = image.uuid;[m
[32m+[m			[32mreturn this;[m
 [m
 		}[m
 [m
[31m-		if ( ! isRootObject ) {[m
[32m+[m		[32mvar sinHalfTheta = Math.sqrt( sqrSinHalfTheta );[m
[32m+[m		[32mvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );[m
[32m+[m		[32mvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,[m
[32m+[m			[32mratioB = Math.sin( t * halfTheta ) / sinHalfTheta;[m
 [m
[31m-			meta.textures[ this.uuid ] = output;[m
[32m+[m		[32mthis._w = ( w * ratioA + this._w * ratioB );[m
[32m+[m		[32mthis._x = ( x * ratioA + this._x * ratioB );[m
[32m+[m		[32mthis._y = ( y * ratioA + this._y * ratioB );[m
[32m+[m		[32mthis._z = ( z * ratioA + this._z * ratioB );[m
 [m
[31m-		}[m
[32m+[m		[32mthis._onChangeCallback();[m
 [m
[31m-		return output;[m
[32m+[m		[32mreturn this;[m
 [m
 	},[m
 [m
[31m-	dispose: function () {[m
[32m+[m	[32mequals: function ( quaternion ) {[m
 [m
[31m-		this.dispatchEvent( { type: 'dispose' } );[m
[32m+[m		[32mreturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );[m
 [m
 	},[m
 [m
[31m-	transformUv: function ( uv ) {[m
[31m-[m
[31m-		if ( this.mapping !== UVMapping ) return uv;[m
[31m-[m
[31m-		uv.applyMatrix3( this.matrix );[m
[31m-[m
[31m-		if ( uv.x < 0 || uv.x > 1 ) {[m
[31m-[m
[31m-			switch ( this.wrapS ) {[m
[31m-[m
[31m-				case RepeatWrapping:[m
[31m-[m
[31m-					uv.x = uv.x - Math.floor( uv.x );[m
[31m-					break;[m
[31m-[m
[31m-				case ClampToEdgeWrapping:[m
[31m-[m
[31m-					uv.x = uv.x < 0 ? 0 : 1;[m
[31m-					break;[m
[31m-[m
[31m-				case MirroredRepeatWrapping:[m
[31m-[m
[31m-					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {[m
[31m-[m
[31m-						uv.x = Math.ceil( uv.x ) - uv.x;[m
[31m-[m
[31m-					} else {[m
[31m-[m
[31m-						uv.x = uv.x - Math.floor( uv.x );[m
[31m-[m
[31m-					}[m
[31m-					break;[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		if ( uv.y < 0 || uv.y > 1 ) {[m
[31m-[m
[31m-			switch ( this.wrapT ) {[m
[31m-[m
[31m-				case RepeatWrapping:[m
[31m-[m
[31m-					uv.y = uv.y - Math.floor( uv.y );[m
[31m-					break;[m
[31m-[m
[31m-				case ClampToEdgeWrapping:[m
[32m+[m	[32mfromArray: function ( array, offset ) {[m
 [m
[31m-					uv.y = uv.y < 0 ? 0 : 1;[m
[31m-					break;[m
[32m+[m		[32mif ( offset === undefined ) offset = 0;[m
 [m
[31m-				case MirroredRepeatWrapping:[m
[32m+[m		[32mthis._x = array[ offset ];[m
[32m+[m		[32mthis._y = array[ offset + 1 ];[m
[32m+[m		[32mthis._z = array[ offset + 2 ];[m
[32m+[m		[32mthis._w = array[ offset + 3 ];[m
 [m
[31m-					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {[m
[32m+[m		[32mthis._onChangeCallback();[m
 [m
[31m-						uv.y = Math.ceil( uv.y ) - uv.y;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-					} else {[m
[32m+[m	[32m},[m
 [m
[31m-						uv.y = uv.y - Math.floor( uv.y );[m
[32m+[m	[32mtoArray: function ( array, offset ) {[m
 [m
[31m-					}[m
[31m-					break;[m
[32m+[m		[32mif ( array === undefined ) array = [];[m
[32m+[m		[32mif ( offset === undefined ) offset = 0;[m
 [m
[31m-			}[m
[32m+[m		[32marray[ offset ] = this._x;[m
[32m+[m		[32marray[ offset + 1 ] = this._y;[m
[32m+[m		[32marray[ offset + 2 ] = this._z;[m
[32m+[m		[32marray[ offset + 3 ] = this._w;[m
 [m
[31m-		}[m
[32m+[m		[32mreturn array;[m
 [m
[31m-		if ( this.flipY ) {[m
[32m+[m	[32m},[m
 [m
[31m-			uv.y = 1 - uv.y;[m
[32m+[m	[32mfromBufferAttribute: function ( attribute, index ) {[m
 [m
[31m-		}[m
[32m+[m		[32mthis._x = attribute.getX( index );[m
[32m+[m		[32mthis._y = attribute.getY( index );[m
[32m+[m		[32mthis._z = attribute.getZ( index );[m
[32m+[m		[32mthis._w = attribute.getW( index );[m
 [m
[31m-		return uv;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-	}[m
[32m+[m	[32m},[m
 [m
[31m-} );[m
[32m+[m	[32m_onChange: function ( callback ) {[m
 [m
[31m-Object.defineProperty( Texture.prototype, "needsUpdate", {[m
[32m+[m		[32mthis._onChangeCallback = callback;[m
 [m
[31m-	set: function ( value ) {[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		if ( value === true ) this.version ++;[m
[32m+[m	[32m},[m
 [m
[31m-	}[m
[32m+[m	[32m_onChangeCallback: function () {}[m
 [m
 } );[m
 [m
 /**[m
[31m- * @author supereggbert / http://www.paulbrunt.co.uk/[m
[32m+[m[32m * @author mrdoob / http://mrdoob.com/[m
[32m+[m[32m * @author kile / http://kile.stravaganza.org/[m
  * @author philogb / http://blog.thejit.org/[m
  * @author mikael emtinger / http://gomo.se/[m
  * @author egraether / http://egraether.com/[m
  * @author WestLangley / http://github.com/WestLangley[m
  */[m
 [m
[31m-function Vector4( x, y, z, w ) {[m
[32m+[m[32mvar _vector = new Vector3();[m
[32m+[m[32mvar _quaternion = new Quaternion();[m
[32m+[m
[32m+[m[32mfunction Vector3( x, y, z ) {[m
 [m
 	this.x = x || 0;[m
 	this.y = y || 0;[m
 	this.z = z || 0;[m
[31m-	this.w = ( w !== undefined ) ? w : 1;[m
 [m
 }[m
 [m
[31m-Object.defineProperties( Vector4.prototype, {[m
[31m-[m
[31m-	"width": {[m
[31m-[m
[31m-		get: function () {[m
[31m-[m
[31m-			return this.z;[m
[31m-[m
[31m-		},[m
[31m-[m
[31m-		set: function ( value ) {[m
[31m-[m
[31m-			this.z = value;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	"height": {[m
[31m-[m
[31m-		get: function () {[m
[31m-[m
[31m-			return this.w;[m
[31m-[m
[31m-		},[m
[31m-[m
[31m-		set: function ( value ) {[m
[31m-[m
[31m-			this.w = value;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-} );[m
[31m-[m
[31m-Object.assign( Vector4.prototype, {[m
[32m+[m[32mObject.assign( Vector3.prototype, {[m
 [m
[31m-	isVector4: true,[m
[32m+[m	[32misVector3: true,[m
 [m
[31m-	set: function ( x, y, z, w ) {[m
[32m+[m	[32mset: function ( x, y, z ) {[m
 [m
 		this.x = x;[m
 		this.y = y;[m
 		this.z = z;[m
[31m-		this.w = w;[m
 [m
 		return this;[m
 [m
[36m@@ -3139,7 +3254,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = scalar;[m
 		this.y = scalar;[m
 		this.z = scalar;[m
[31m-		this.w = scalar;[m
 [m
 		return this;[m
 [m
[36m@@ -3169,14 +3283,6 @@[m [mObject.assign( Vector4.prototype, {[m
 [m
 	},[m
 [m
[31m-	setW: function ( w ) {[m
[31m-[m
[31m-		this.w = w;[m
[31m-[m
[31m-		return this;[m
[31m-[m
[31m-	},[m
[31m-[m
 	setComponent: function ( index, value ) {[m
 [m
 		switch ( index ) {[m
[36m@@ -3184,7 +3290,6 @@[m [mObject.assign( Vector4.prototype, {[m
 			case 0: this.x = value; break;[m
 			case 1: this.y = value; break;[m
 			case 2: this.z = value; break;[m
[31m-			case 3: this.w = value; break;[m
 			default: throw new Error( 'index is out of range: ' + index );[m
 [m
 		}[m
[36m@@ -3200,7 +3305,6 @@[m [mObject.assign( Vector4.prototype, {[m
 			case 0: return this.x;[m
 			case 1: return this.y;[m
 			case 2: return this.z;[m
[31m-			case 3: return this.w;[m
 			default: throw new Error( 'index is out of range: ' + index );[m
 [m
 		}[m
[36m@@ -3209,7 +3313,7 @@[m [mObject.assign( Vector4.prototype, {[m
 [m
 	clone: function () {[m
 [m
[31m-		return new this.constructor( this.x, this.y, this.z, this.w );[m
[32m+[m		[32mreturn new this.constructor( this.x, this.y, this.z );[m
 [m
 	},[m
 [m
[36m@@ -3218,7 +3322,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = v.x;[m
 		this.y = v.y;[m
 		this.z = v.z;[m
[31m-		this.w = ( v.w !== undefined ) ? v.w : 1;[m
 [m
 		return this;[m
 [m
[36m@@ -3228,7 +3331,7 @@[m [mObject.assign( Vector4.prototype, {[m
 [m
 		if ( w !== undefined ) {[m
 [m
[31m-			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );[m
[32m+[m			[32mconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );[m
 			return this.addVectors( v, w );[m
 [m
 		}[m
[36m@@ -3236,7 +3339,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x += v.x;[m
 		this.y += v.y;[m
 		this.z += v.z;[m
[31m-		this.w += v.w;[m
 [m
 		return this;[m
 [m
[36m@@ -3247,7 +3349,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x += s;[m
 		this.y += s;[m
 		this.z += s;[m
[31m-		this.w += s;[m
 [m
 		return this;[m
 [m
[36m@@ -3258,7 +3359,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = a.x + b.x;[m
 		this.y = a.y + b.y;[m
 		this.z = a.z + b.z;[m
[31m-		this.w = a.w + b.w;[m
 [m
 		return this;[m
 [m
[36m@@ -3269,7 +3369,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x += v.x * s;[m
 		this.y += v.y * s;[m
 		this.z += v.z * s;[m
[31m-		this.w += v.w * s;[m
 [m
 		return this;[m
 [m
[36m@@ -3279,7 +3378,7 @@[m [mObject.assign( Vector4.prototype, {[m
 [m
 		if ( w !== undefined ) {[m
 [m
[31m-			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );[m
[32m+[m			[32mconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );[m
 			return this.subVectors( v, w );[m
 [m
 		}[m
[36m@@ -3287,7 +3386,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x -= v.x;[m
 		this.y -= v.y;[m
 		this.z -= v.z;[m
[31m-		this.w -= v.w;[m
 [m
 		return this;[m
 [m
[36m@@ -3298,7 +3396,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x -= s;[m
 		this.y -= s;[m
 		this.z -= s;[m
[31m-		this.w -= s;[m
 [m
 		return this;[m
 [m
[36m@@ -3309,198 +3406,163 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = a.x - b.x;[m
 		this.y = a.y - b.y;[m
 		this.z = a.z - b.z;[m
[31m-		this.w = a.w - b.w;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	multiplyScalar: function ( scalar ) {[m
[31m-[m
[31m-		this.x *= scalar;[m
[31m-		this.y *= scalar;[m
[31m-		this.z *= scalar;[m
[31m-		this.w *= scalar;[m
[31m-[m
[31m-		return this;[m
[32m+[m	[32mmultiply: function ( v, w ) {[m
 [m
[31m-	},[m
[32m+[m		[32mif ( w !== undefined ) {[m
 [m
[31m-	applyMatrix4: function ( m ) {[m
[32m+[m			[32mconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );[m
[32m+[m			[32mreturn this.multiplyVectors( v, w );[m
 [m
[31m-		var x = this.x, y = this.y, z = this.z, w = this.w;[m
[31m-		var e = m.elements;[m
[32m+[m		[32m}[m
 [m
[31m-		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;[m
[31m-		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;[m
[31m-		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;[m
[31m-		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;[m
[32m+[m		[32mthis.x *= v.x;[m
[32m+[m		[32mthis.y *= v.y;[m
[32m+[m		[32mthis.z *= v.z;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	divideScalar: function ( scalar ) {[m
[31m-[m
[31m-		return this.multiplyScalar( 1 / scalar );[m
[32m+[m	[32mmultiplyScalar: function ( scalar ) {[m
 [m
[31m-	},[m
[32m+[m		[32mthis.x *= scalar;[m
[32m+[m		[32mthis.y *= scalar;[m
[32m+[m		[32mthis.z *= scalar;[m
 [m
[31m-	setAxisAngleFromQuaternion: function ( q ) {[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm[m
[32m+[m	[32m},[m
 [m
[31m-		// q is assumed to be normalized[m
[32m+[m	[32mmultiplyVectors: function ( a, b ) {[m
 [m
[31m-		this.w = 2 * Math.acos( q.w );[m
[32m+[m		[32mthis.x = a.x * b.x;[m
[32m+[m		[32mthis.y = a.y * b.y;[m
[32m+[m		[32mthis.z = a.z * b.z;[m
 [m
[31m-		var s = Math.sqrt( 1 - q.w * q.w );[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		if ( s < 0.0001 ) {[m
[32m+[m	[32m},[m
 [m
[31m-			this.x = 1;[m
[31m-			this.y = 0;[m
[31m-			this.z = 0;[m
[32m+[m	[32mapplyEuler: function ( euler ) {[m
 [m
[31m-		} else {[m
[32m+[m		[32mif ( ! ( euler && euler.isEuler ) ) {[m
 [m
[31m-			this.x = q.x / s;[m
[31m-			this.y = q.y / s;[m
[31m-			this.z = q.z / s;[m
[32m+[m			[32mconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );[m
 [m
 		}[m
 [m
[31m-		return this;[m
[32m+[m		[32mreturn this.applyQuaternion( _quaternion.setFromEuler( euler ) );[m
 [m
 	},[m
 [m
[31m-	setAxisAngleFromRotationMatrix: function ( m ) {[m
[31m-[m
[31m-		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm[m
[31m-[m
[31m-		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)[m
[31m-[m
[31m-		var angle, x, y, z,		// variables for result[m
[31m-			epsilon = 0.01,		// margin to allow for rounding errors[m
[31m-			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees[m
[31m-[m
[31m-			te = m.elements,[m
[32m+[m	[32mapplyAxisAngle: function ( axis, angle ) {[m
 [m
[31m-			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],[m
[31m-			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],[m
[31m-			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];[m
[32m+[m		[32mreturn this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );[m
 [m
[31m-		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&[m
[31m-		     ( Math.abs( m13 - m31 ) < epsilon ) &&[m
[31m-		     ( Math.abs( m23 - m32 ) < epsilon ) ) {[m
[32m+[m	[32m},[m
 [m
[31m-			// singularity found[m
[31m-			// first check for identity matrix which must have +1 for all terms[m
[31m-			// in leading diagonal and zero in other terms[m
[32m+[m	[32mapplyMatrix3: function ( m ) {[m
 [m
[31m-			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&[m
[31m-			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&[m
[31m-			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&[m
[31m-			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {[m
[32m+[m		[32mvar x = this.x, y = this.y, z = this.z;[m
[32m+[m		[32mvar e = m.elements;[m
 [m
[31m-				// this singularity is identity matrix so angle = 0[m
[32m+[m		[32mthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;[m
[32m+[m		[32mthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;[m
[32m+[m		[32mthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;[m
 [m
[31m-				this.set( 1, 0, 0, 0 );[m
[32m+[m		[32mreturn this;[m
 [m
[31m-				return this; // zero angle, arbitrary axis[m
[32m+[m	[32m},[m
 [m
[31m-			}[m
[32m+[m	[32mapplyNormalMatrix: function ( m ) {[m
 [m
[31m-			// otherwise this singularity is angle = 180[m
[32m+[m		[32mreturn this.applyMatrix3( m ).normalize();[m
 [m
[31m-			angle = Math.PI;[m
[32m+[m	[32m},[m
 [m
[31m-			var xx = ( m11 + 1 ) / 2;[m
[31m-			var yy = ( m22 + 1 ) / 2;[m
[31m-			var zz = ( m33 + 1 ) / 2;[m
[31m-			var xy = ( m12 + m21 ) / 4;[m
[31m-			var xz = ( m13 + m31 ) / 4;[m
[31m-			var yz = ( m23 + m32 ) / 4;[m
[32m+[m	[32mapplyMatrix4: function ( m ) {[m
 [m
[31m-			if ( ( xx > yy ) && ( xx > zz ) ) {[m
[32m+[m		[32mvar x = this.x, y = this.y, z = this.z;[m
[32m+[m		[32mvar e = m.elements;[m
 [m
[31m-				// m11 is the largest diagonal term[m
[32m+[m		[32mvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );[m
 [m
[31m-				if ( xx < epsilon ) {[m
[32m+[m		[32mthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;[m
[32m+[m		[32mthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;[m
[32m+[m		[32mthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;[m
 [m
[31m-					x = 0;[m
[31m-					y = 0.707106781;[m
[31m-					z = 0.707106781;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-				} else {[m
[32m+[m	[32m},[m
 [m
[31m-					x = Math.sqrt( xx );[m
[31m-					y = xy / x;[m
[31m-					z = xz / x;[m
[32m+[m	[32mapplyQuaternion: function ( q ) {[m
 [m
[31m-				}[m
[32m+[m		[32mvar x = this.x, y = this.y, z = this.z;[m
[32m+[m		[32mvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;[m
 [m
[31m-			} else if ( yy > zz ) {[m
[32m+[m		[32m// calculate quat * vector[m
 [m
[31m-				// m22 is the largest diagonal term[m
[32m+[m		[32mvar ix = qw * x + qy * z - qz * y;[m
[32m+[m		[32mvar iy = qw * y + qz * x - qx * z;[m
[32m+[m		[32mvar iz = qw * z + qx * y - qy * x;[m
[32m+[m		[32mvar iw = - qx * x - qy * y - qz * z;[m
 [m
[31m-				if ( yy < epsilon ) {[m
[32m+[m		[32m// calculate result * inverse quat[m
 [m
[31m-					x = 0.707106781;[m
[31m-					y = 0;[m
[31m-					z = 0.707106781;[m
[32m+[m		[32mthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;[m
[32m+[m		[32mthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;[m
[32m+[m		[32mthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;[m
 [m
[31m-				} else {[m
[32m+[m		[32mreturn this;[m
 [m
[31m-					y = Math.sqrt( yy );[m
[31m-					x = xy / y;[m
[31m-					z = yz / y;[m
[32m+[m	[32m},[m
 [m
[31m-				}[m
[32m+[m	[32mproject: function ( camera ) {[m
 [m
[31m-			} else {[m
[32m+[m		[32mreturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );[m
 [m
[31m-				// m33 is the largest diagonal term so base result on this[m
[32m+[m	[32m},[m
 [m
[31m-				if ( zz < epsilon ) {[m
[32m+[m	[32munproject: function ( camera ) {[m
 [m
[31m-					x = 0.707106781;[m
[31m-					y = 0.707106781;[m
[31m-					z = 0;[m
[32m+[m		[32mreturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );[m
 [m
[31m-				} else {[m
[32m+[m	[32m},[m
 [m
[31m-					z = Math.sqrt( zz );[m
[31m-					x = xz / z;[m
[31m-					y = yz / z;[m
[32m+[m	[32mtransformDirection: function ( m ) {[m
 [m
[31m-				}[m
[32m+[m		[32m// input: THREE.Matrix4 affine matrix[m
[32m+[m		[32m// vector interpreted as a direction[m
 [m
[31m-			}[m
[32m+[m		[32mvar x = this.x, y = this.y, z = this.z;[m
[32m+[m		[32mvar e = m.elements;[m
 [m
[31m-			this.set( x, y, z, angle );[m
[32m+[m		[32mthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;[m
[32m+[m		[32mthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;[m
[32m+[m		[32mthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;[m
 [m
[31m-			return this; // return 180 deg rotation[m
[32m+[m		[32mreturn this.normalize();[m
 [m
[31m-		}[m
[32m+[m	[32m},[m
 [m
[31m-		// as we have reached here there are no singularities so we can handle normally[m
[32m+[m	[32mdivide: function ( v ) {[m
 [m
[31m-		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +[m
[31m-		                   ( m13 - m31 ) * ( m13 - m31 ) +[m
[31m-		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize[m
[32m+[m		[32mthis.x /= v.x;[m
[32m+[m		[32mthis.y /= v.y;[m
[32m+[m		[32mthis.z /= v.z;[m
 [m
[31m-		if ( Math.abs( s ) < 0.001 ) s = 1;[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		// prevent divide by zero, should not happen if matrix is orthogonal and should be[m
[31m-		// caught by singularity test above, but I've left it in just in case[m
[32m+[m	[32m},[m
 [m
[31m-		this.x = ( m32 - m23 ) / s;[m
[31m-		this.y = ( m13 - m31 ) / s;[m
[31m-		this.z = ( m21 - m12 ) / s;[m
[31m-		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );[m
[32m+[m	[32mdivideScalar: function ( scalar ) {[m
 [m
[31m-		return this;[m
[32m+[m		[32mreturn this.multiplyScalar( 1 / scalar );[m
 [m
 	},[m
 [m
[36m@@ -3509,7 +3571,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = Math.min( this.x, v.x );[m
 		this.y = Math.min( this.y, v.y );[m
 		this.z = Math.min( this.z, v.z );[m
[31m-		this.w = Math.min( this.w, v.w );[m
 [m
 		return this;[m
 [m
[36m@@ -3520,7 +3581,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = Math.max( this.x, v.x );[m
 		this.y = Math.max( this.y, v.y );[m
 		this.z = Math.max( this.z, v.z );[m
[31m-		this.w = Math.max( this.w, v.w );[m
 [m
 		return this;[m
 [m
[36m@@ -3533,7 +3593,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = Math.max( min.x, Math.min( max.x, this.x ) );[m
 		this.y = Math.max( min.y, Math.min( max.y, this.y ) );[m
 		this.z = Math.max( min.z, Math.min( max.z, this.z ) );[m
[31m-		this.w = Math.max( min.w, Math.min( max.w, this.w ) );[m
 [m
 		return this;[m
 [m
[36m@@ -3544,7 +3603,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );[m
 		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );[m
 		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );[m
[31m-		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );[m
 [m
 		return this;[m
 [m
[36m@@ -3563,7 +3621,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = Math.floor( this.x );[m
 		this.y = Math.floor( this.y );[m
 		this.z = Math.floor( this.z );[m
[31m-		this.w = Math.floor( this.w );[m
 [m
 		return this;[m
 [m
[36m@@ -3574,7 +3631,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = Math.ceil( this.x );[m
 		this.y = Math.ceil( this.y );[m
 		this.z = Math.ceil( this.z );[m
[31m-		this.w = Math.ceil( this.w );[m
 [m
 		return this;[m
 [m
[36m@@ -3585,7 +3641,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = Math.round( this.x );[m
 		this.y = Math.round( this.y );[m
 		this.z = Math.round( this.z );[m
[31m-		this.w = Math.round( this.w );[m
 [m
 		return this;[m
 [m
[36m@@ -3596,7 +3651,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );[m
 		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );[m
 		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );[m
[31m-		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );[m
 [m
 		return this;[m
 [m
[36m@@ -3607,7 +3661,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x = - this.x;[m
 		this.y = - this.y;[m
 		this.z = - this.z;[m
[31m-		this.w = - this.w;[m
 [m
 		return this;[m
 [m
[36m@@ -3615,25 +3668,27 @@[m [mObject.assign( Vector4.prototype, {[m
 [m
 	dot: function ( v ) {[m
 [m
[31m-		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;[m
[32m+[m		[32mreturn this.x * v.x + this.y * v.y + this.z * v.z;[m
 [m
 	},[m
 [m
[32m+[m	[32m// TODO lengthSquared?[m
[32m+[m
 	lengthSq: function () {[m
 [m
[31m-		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;[m
[32m+[m		[32mreturn this.x * this.x + this.y * this.y + this.z * this.z;[m
 [m
 	},[m
 [m
 	length: function () {[m
 [m
[31m-		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );[m
[32m+[m		[32mreturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );[m
 [m
 	},[m
 [m
 	manhattanLength: function () {[m
 [m
[31m-		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );[m
[32m+[m		[32mreturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );[m
 [m
 	},[m
 [m
[36m@@ -3654,7 +3709,6 @@[m [mObject.assign( Vector4.prototype, {[m
 		this.x += ( v.x - this.x ) * alpha;[m
 		this.y += ( v.y - this.y ) * alpha;[m
 		this.z += ( v.z - this.z ) * alpha;[m
[31m-		this.w += ( v.w - this.w ) * alpha;[m
 [m
 		return this;[m
 [m
[36m@@ -3666,176 +3720,209 @@[m [mObject.assign( Vector4.prototype, {[m
 [m
 	},[m
 [m
[31m-	equals: function ( v ) {[m
[32m+[m	[32mcross: function ( v, w ) {[m
 [m
[31m-		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );[m
[32m+[m		[32mif ( w !== undefined ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );[m
[32m+[m			[32mreturn this.crossVectors( v, w );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn this.crossVectors( this, v );[m
 [m
 	},[m
 [m
[31m-	fromArray: function ( array, offset ) {[m
[32m+[m	[32mcrossVectors: function ( a, b ) {[m
 [m
[31m-		if ( offset === undefined ) offset = 0;[m
[32m+[m		[32mvar ax = a.x, ay = a.y, az = a.z;[m
[32m+[m		[32mvar bx = b.x, by = b.y, bz = b.z;[m
 [m
[31m-		this.x = array[ offset ];[m
[31m-		this.y = array[ offset + 1 ];[m
[31m-		this.z = array[ offset + 2 ];[m
[31m-		this.w = array[ offset + 3 ];[m
[32m+[m		[32mthis.x = ay * bz - az * by;[m
[32m+[m		[32mthis.y = az * bx - ax * bz;[m
[32m+[m		[32mthis.z = ax * by - ay * bx;[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	toArray: function ( array, offset ) {[m
[32m+[m	[32mprojectOnVector: function ( v ) {[m
 [m
[31m-		if ( array === undefined ) array = [];[m
[31m-		if ( offset === undefined ) offset = 0;[m
[32m+[m		[32mvar denominator = v.lengthSq();[m
 [m
[31m-		array[ offset ] = this.x;[m
[31m-		array[ offset + 1 ] = this.y;[m
[31m-		array[ offset + 2 ] = this.z;[m
[31m-		array[ offset + 3 ] = this.w;[m
[32m+[m		[32mif ( denominator === 0 ) return this.set( 0, 0, 0 );[m
 [m
[31m-		return array;[m
[32m+[m		[32mvar scalar = v.dot( this ) / denominator;[m
[32m+[m
[32m+[m		[32mreturn this.copy( v ).multiplyScalar( scalar );[m
 [m
 	},[m
 [m
[31m-	fromBufferAttribute: function ( attribute, index, offset ) {[m
[32m+[m	[32mprojectOnPlane: function ( planeNormal ) {[m
 [m
[31m-		if ( offset !== undefined ) {[m
[32m+[m		[32m_vector.copy( this ).projectOnVector( planeNormal );[m
 [m
[31m-			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );[m
[32m+[m		[32mreturn this.sub( _vector );[m
 [m
[31m-		}[m
[32m+[m	[32m},[m
 [m
[31m-		this.x = attribute.getX( index );[m
[31m-		this.y = attribute.getY( index );[m
[31m-		this.z = attribute.getZ( index );[m
[31m-		this.w = attribute.getW( index );[m
[32m+[m	[32mreflect: function ( normal ) {[m
 [m
[31m-		return this;[m
[32m+[m		[32m// reflect incident vector off plane orthogonal to normal[m
[32m+[m		[32m// normal is assumed to have unit length[m
 [m
[31m-	}[m
[32m+[m		[32mreturn this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );[m
 [m
[31m-} );[m
[32m+[m	[32m},[m
 [m
[31m-/**[m
[31m- * @author szimek / https://github.com/szimek/[m
[31m- * @author alteredq / http://alteredqualia.com/[m
[31m- * @author Marius Kintel / https://github.com/kintel[m
[31m- */[m
[32m+[m	[32mangleTo: function ( v ) {[m
 [m
[31m-/*[m
[31m- In options, we can specify:[m
[31m- * Texture parameters for an auto-generated target texture[m
[31m- * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers[m
[31m-*/[m
[31m-function WebGLRenderTarget( width, height, options ) {[m
[32m+[m		[32mvar denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );[m
 [m
[31m-	this.width = width;[m
[31m-	this.height = height;[m
[32m+[m		[32mif ( denominator === 0 ) return Math.PI / 2;[m
 [m
[31m-	this.scissor = new Vector4( 0, 0, width, height );[m
[31m-	this.scissorTest = false;[m
[32m+[m		[32mvar theta = this.dot( v ) / denominator;[m
 [m
[31m-	this.viewport = new Vector4( 0, 0, width, height );[m
[32m+[m		[32m// clamp, to handle numerical problems[m
 [m
[31m-	options = options || {};[m
[32m+[m		[32mreturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );[m
 [m
[31m-	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );[m
[32m+[m	[32m},[m
 [m
[31m-	this.texture.image = {};[m
[31m-	this.texture.image.width = width;[m
[31m-	this.texture.image.height = height;[m
[32m+[m	[32mdistanceTo: function ( v ) {[m
 [m
[31m-	this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;[m
[31m-	this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;[m
[32m+[m		[32mreturn Math.sqrt( this.distanceToSquared( v ) );[m
 [m
[31m-	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;[m
[31m-	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;[m
[31m-	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;[m
[32m+[m	[32m},[m
 [m
[31m-}[m
[32m+[m	[32mdistanceToSquared: function ( v ) {[m
 [m
[31m-WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {[m
[32m+[m		[32mvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;[m
 [m
[31m-	constructor: WebGLRenderTarget,[m
[32m+[m		[32mreturn dx * dx + dy * dy + dz * dz;[m
 [m
[31m-	isWebGLRenderTarget: true,[m
[32m+[m	[32m},[m
 [m
[31m-	setSize: function ( width, height ) {[m
[32m+[m	[32mmanhattanDistanceTo: function ( v ) {[m
 [m
[31m-		if ( this.width !== width || this.height !== height ) {[m
[32m+[m		[32mreturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );[m
 [m
[31m-			this.width = width;[m
[31m-			this.height = height;[m
[32m+[m	[32m},[m
 [m
[31m-			this.texture.image.width = width;[m
[31m-			this.texture.image.height = height;[m
[32m+[m	[32msetFromSpherical: function ( s ) {[m
 [m
[31m-			this.dispose();[m
[32m+[m		[32mreturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );[m
 [m
[31m-		}[m
[32m+[m	[32m},[m
 [m
[31m-		this.viewport.set( 0, 0, width, height );[m
[31m-		this.scissor.set( 0, 0, width, height );[m
[32m+[m	[32msetFromSphericalCoords: function ( radius, phi, theta ) {[m
[32m+[m
[32m+[m		[32mvar sinPhiRadius = Math.sin( phi ) * radius;[m
[32m+[m
[32m+[m		[32mthis.x = sinPhiRadius * Math.sin( theta );[m
[32m+[m		[32mthis.y = Math.cos( phi ) * radius;[m
[32m+[m		[32mthis.z = sinPhiRadius * Math.cos( theta );[m
[32m+[m
[32m+[m		[32mreturn this;[m
 [m
 	},[m
 [m
[31m-	clone: function () {[m
[32m+[m	[32msetFromCylindrical: function ( c ) {[m
 [m
[31m-		return new this.constructor().copy( this );[m
[32m+[m		[32mreturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );[m
 [m
 	},[m
 [m
[31m-	copy: function ( source ) {[m
[32m+[m	[32msetFromCylindricalCoords: function ( radius, theta, y ) {[m
 [m
[31m-		this.width = source.width;[m
[31m-		this.height = source.height;[m
[32m+[m		[32mthis.x = radius * Math.sin( theta );[m
[32m+[m		[32mthis.y = y;[m
[32m+[m		[32mthis.z = radius * Math.cos( theta );[m
 [m
[31m-		this.viewport.copy( source.viewport );[m
[32m+[m		[32mreturn this;[m
 [m
[31m-		this.texture = source.texture.clone();[m
[32m+[m	[32m},[m
 [m
[31m-		this.depthBuffer = source.depthBuffer;[m
[31m-		this.stencilBuffer = source.stencilBuffer;[m
[31m-		this.depthTexture = source.depthTexture;[m
[32m+[m	[32msetFromMatrixPosition: function ( m ) {[m
[32m+[m
[32m+[m		[32mvar e = m.elements;[m
[32m+[m
[32m+[m		[32mthis.x = e[ 12 ];[m
[32m+[m		[32mthis.y = e[ 13 ];[m
[32m+[m		[32mthis.z = e[ 14 ];[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	dispose: function () {[m
[32m+[m	[32msetFromMatrixScale: function ( m ) {[m
 [m
[31m-		this.dispatchEvent( { type: 'dispose' } );[m
[32m+[m		[32mvar sx = this.setFromMatrixColumn( m, 0 ).length();[m
[32m+[m		[32mvar sy = this.setFromMatrixColumn( m, 1 ).length();[m
[32m+[m		[32mvar sz = this.setFromMatrixColumn( m, 2 ).length();[m
 [m
[31m-	}[m
[32m+[m		[32mthis.x = sx;[m
[32m+[m		[32mthis.y = sy;[m
[32m+[m		[32mthis.z = sz;[m
 [m
[31m-} );[m
[32m+[m		[32mreturn this;[m
 [m
[31m-/**[m
[31m- * @author Mugen87 / https://github.com/Mugen87[m
[31m- * @author Matt DesLauriers / @mattdesl[m
[31m- */[m
[32m+[m	[32m},[m
 [m
[31m-function WebGLMultisampleRenderTarget( width, height, options ) {[m
[32m+[m	[32msetFromMatrixColumn: function ( m, index ) {[m
 [m
[31m-	WebGLRenderTarget.call( this, width, height, options );[m
[32m+[m		[32mreturn this.fromArray( m.elements, index * 4 );[m
 [m
[31m-	this.samples = 4;[m
[32m+[m	[32m},[m
 [m
[31m-}[m
[32m+[m	[32msetFromMatrix3Column: function ( m, index ) {[m
 [m
[31m-WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {[m
[32m+[m		[32mreturn this.fromArray( m.elements, index * 3 );[m
 [m
[31m-	constructor: WebGLMultisampleRenderTarget,[m
[32m+[m	[32m},[m
 [m
[31m-	isWebGLMultisampleRenderTarget: true,[m
[32m+[m	[32mequals: function ( v ) {[m
 [m
[31m-	copy: function ( source ) {[m
[32m+[m		[32mreturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );[m
 [m
[31m-		WebGLRenderTarget.prototype.copy.call( this, source );[m
[32m+[m	[32m},[m
 [m
[31m-		this.samples = source.samples;[m
[32m+[m	[32mfromArray: function ( array, offset ) {[m
[32m+[m
[32m+[m		[32mif ( offset === undefined ) offset = 0;[m
[32m+[m
[32m+[m		[32mthis.x = array[ offset ];[m
[32m+[m		[32mthis.y = array[ offset + 1 ];[m
[32m+[m		[32mthis.z = array[ offset + 2 ];[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mtoArray: function ( array, offset ) {[m
[32m+[m
[32m+[m		[32mif ( array === undefined ) array = [];[m
[32m+[m		[32mif ( offset === undefined ) offset = 0;[m
[32m+[m
[32m+[m		[32marray[ offset ] = this.x;[m
[32m+[m		[32marray[ offset + 1 ] = this.y;[m
[32m+[m		[32marray[ offset + 2 ] = this.z;[m
[32m+[m
[32m+[m		[32mreturn array;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mfromBufferAttribute: function ( attribute, index, offset ) {[m
[32m+[m
[32m+[m		[32mif ( offset !== undefined ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mthis.x = attribute.getX( index );[m
[32m+[m		[32mthis.y = attribute.getY( index );[m
[32m+[m		[32mthis.z = attribute.getZ( index );[m
 [m
 		return this;[m
 [m
[36m@@ -4258,24 +4345,6 @@[m [mObject.assign( Matrix4.prototype, {[m
 [m
 	},[m
 [m
[31m-	applyToBufferAttribute: function ( attribute ) {[m
[31m-[m
[31m-		for ( var i = 0, l = attribute.count; i < l; i ++ ) {[m
[31m-[m
[31m-			_v1.x = attribute.getX( i );[m
[31m-			_v1.y = attribute.getY( i );[m
[31m-			_v1.z = attribute.getZ( i );[m
[31m-[m
[31m-			_v1.applyMatrix4( this );[m
[31m-[m
[31m-			attribute.setXYZ( i, _v1.x, _v1.y, _v1.z );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		return attribute;[m
[31m-[m
[31m-	},[m
[31m-[m
 	determinant: function () {[m
 [m
 		var te = this.elements;[m
[36m@@ -4367,6 +4436,12 @@[m [mObject.assign( Matrix4.prototype, {[m
 [m
 	getInverse: function ( m, throwOnDegenerate ) {[m
 [m
[32m+[m		[32mif ( throwOnDegenerate !== undefined ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate." );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm[m
 		var te = this.elements,[m
 			me = m.elements,[m
[36m@@ -4383,23 +4458,7 @@[m [mObject.assign( Matrix4.prototype, {[m
 [m
 		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;[m
 [m
[31m-		if ( det === 0 ) {[m
[31m-[m
[31m-			var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";[m
[31m-[m
[31m-			if ( throwOnDegenerate === true ) {[m
[31m-[m
[31m-				throw new Error( msg );[m
[31m-[m
[31m-			} else {[m
[31m-[m
[31m-				console.warn( msg );[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-			return this.identity();[m
[31m-[m
[31m-		}[m
[32m+[m		[32mif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );[m
 [m
 		var detInv = 1 / det;[m
 [m
[36m@@ -4893,7 +4952,7 @@[m [mObject.assign( Euler.prototype, {[m
 [m
 	setFromRotationMatrix: function ( m, order, update ) {[m
 [m
[31m-		var clamp = _Math.clamp;[m
[32m+[m		[32mvar clamp = MathUtils.clamp;[m
 [m
 		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)[m
 [m
[36m@@ -5183,7 +5242,7 @@[m [mfunction Object3D() {[m
 [m
 	Object.defineProperty( this, 'id', { value: _object3DId ++ } );[m
 [m
[31m-	this.uuid = _Math.generateUUID();[m
[32m+[m	[32mthis.uuid = MathUtils.generateUUID();[m
 [m
 	this.name = '';[m
 	this.type = 'Object3D';[m
[36m@@ -5273,7 +5332,7 @@[m [mObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 	onBeforeRender: function () {},[m
 	onAfterRender: function () {},[m
 [m
[31m-	applyMatrix: function ( matrix ) {[m
[32m+[m	[32mapplyMatrix4: function ( matrix ) {[m
 [m
 		if ( this.matrixAutoUpdate ) this.updateMatrix();[m
 [m
[36m@@ -5540,7 +5599,7 @@[m [mObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		}[m
 [m
[31m-		object.applyMatrix( _m1$1 );[m
[32m+[m		[32mobject.applyMatrix4( _m1$1 );[m
 [m
 		object.updateWorldMatrix( false, false );[m
 [m
[36m@@ -5826,7 +5885,13 @@[m [mObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		// object specific properties[m
 [m
[31m-		if ( this.isMesh && this.drawMode !== TrianglesDrawMode ) object.drawMode = this.drawMode;[m
[32m+[m		[32mif ( this.isInstancedMesh ) {[m
[32m+[m
[32m+[m			[32mobject.type = 'InstancedMesh';[m
[32m+[m			[32mobject.count = this.count;[m
[32m+[m			[32mobject.instanceMatrix = this.instanceMatrix.toJSON();[m
[32m+[m
[32m+[m		[32m}[m
 [m
 		//[m
 [m
[36m@@ -6010,7 +6075,9 @@[m [mfunction Scene() {[m
 	this.type = 'Scene';[m
 [m
 	this.background = null;[m
[32m+[m	[32mthis.environment = null;[m
 	this.fog = null;[m
[32m+[m
 	this.overrideMaterial = null;[m
 [m
 	this.autoUpdate = true; // checked by the renderer[m
[36m@@ -6034,7 +6101,9 @@[m [mScene.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 		Object3D.prototype.copy.call( this, source, recursive );[m
 [m
 		if ( source.background !== null ) this.background = source.background.clone();[m
[32m+[m		[32mif ( source.environment !== null ) this.environment = source.environment.clone();[m
 		if ( source.fog !== null ) this.fog = source.fog.clone();[m
[32m+[m
 		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();[m
 [m
 		this.autoUpdate = source.autoUpdate;[m
[36m@@ -6049,6 +6118,7 @@[m [mScene.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 		var data = Object3D.prototype.toJSON.call( this, meta );[m
 [m
 		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );[m
[32m+[m		[32mif ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );[m
 		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();[m
 [m
 		return data;[m
[36m@@ -6073,7 +6143,10 @@[m [mvar _points = [[m
 	new Vector3(),[m
 	new Vector3()[m
 ];[m
[31m-var _vector$2 = new Vector3();[m
[32m+[m
[32m+[m[32mvar _vector$1 = new Vector3();[m
[32m+[m
[32m+[m[32mvar _box = new Box3();[m
 [m
 // triangle centered vertices[m
 [m
[36m@@ -6104,6 +6177,7 @@[m [mfunction Box3( min, max ) {[m
 [m
 }[m
 [m
[32m+[m
 Object.assign( Box3.prototype, {[m
 [m
 	isBox3: true,[m
[36m@@ -6199,7 +6273,7 @@[m [mObject.assign( Box3.prototype, {[m
 [m
 	setFromCenterAndSize: function ( center, size ) {[m
 [m
[31m-		var halfSize = _vector$2.copy( size ).multiplyScalar( 0.5 );[m
[32m+[m		[32mvar halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );[m
 [m
 		this.min.copy( center ).sub( halfSize );[m
 		this.max.copy( center ).add( halfSize );[m
[36m@@ -6303,8 +6377,6 @@[m [mObject.assign( Box3.prototype, {[m
 [m
 	expandByObject: function ( object ) {[m
 [m
[31m-		var i, l;[m
[31m-[m
 		// Computes the world-axis-aligned bounding box of an object (including its children),[m
 		// accounting for both the object's, and children's, world transforms[m
 [m
[36m@@ -6314,44 +6386,22 @@[m [mObject.assign( Box3.prototype, {[m
 [m
 		if ( geometry !== undefined ) {[m
 [m
[31m-			if ( geometry.isGeometry ) {[m
[31m-[m
[31m-				var vertices = geometry.vertices;[m
[31m-[m
[31m-				for ( i = 0, l = vertices.length; i < l; i ++ ) {[m
[31m-[m
[31m-					_vector$2.copy( vertices[ i ] );[m
[31m-					_vector$2.applyMatrix4( object.matrixWorld );[m
[31m-[m
[31m-					this.expandByPoint( _vector$2 );[m
[31m-[m
[31m-				}[m
[31m-[m
[31m-			} else if ( geometry.isBufferGeometry ) {[m
[31m-[m
[31m-				var attribute = geometry.attributes.position;[m
[31m-[m
[31m-				if ( attribute !== undefined ) {[m
[31m-[m
[31m-					for ( i = 0, l = attribute.count; i < l; i ++ ) {[m
[32m+[m			[32mif ( geometry.boundingBox === null ) {[m
 [m
[31m-						_vector$2.fromBufferAttribute( attribute, i ).applyMatrix4( object.matrixWorld );[m
[32m+[m				[32mgeometry.computeBoundingBox();[m
 [m
[31m-						this.expandByPoint( _vector$2 );[m
[31m-[m
[31m-					}[m
[32m+[m			[32m}[m
 [m
[31m-				}[m
[32m+[m			[32m_box.copy( geometry.boundingBox );[m
[32m+[m			[32m_box.applyMatrix4( object.matrixWorld );[m
 [m
[31m-			}[m
[32m+[m			[32mthis.union( _box );[m
 [m
 		}[m
 [m
[31m-		//[m
[31m-[m
 		var children = object.children;[m
 [m
[31m-		for ( i = 0, l = children.length; i < l; i ++ ) {[m
[32m+[m		[32mfor ( var i = 0, l = children.length; i < l; i ++ ) {[m
 [m
 			this.expandByObject( children[ i ] );[m
 [m
[36m@@ -6409,10 +6459,10 @@[m [mObject.assign( Box3.prototype, {[m
 	intersectsSphere: function ( sphere ) {[m
 [m
 		// Find the point on the AABB closest to the sphere center.[m
[31m-		this.clampPoint( sphere.center, _vector$2 );[m
[32m+[m		[32mthis.clampPoint( sphere.center, _vector$1 );[m
 [m
 		// If that point is inside the sphere, the AABB and sphere intersect.[m
[31m-		return _vector$2.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );[m
[32m+[m		[32mreturn _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );[m
 [m
 	},[m
 [m
[36m@@ -6531,7 +6581,7 @@[m [mObject.assign( Box3.prototype, {[m
 [m
 	distanceToPoint: function ( point ) {[m
 [m
[31m-		var clampedPoint = _vector$2.copy( point ).clamp( this.min, this.max );[m
[32m+[m		[32mvar clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );[m
 [m
 		return clampedPoint.sub( point ).length();[m
 [m
[36m@@ -6548,7 +6598,7 @@[m [mObject.assign( Box3.prototype, {[m
 [m
 		this.getCenter( target.center );[m
 [m
[31m-		target.radius = this.getSize( _vector$2 ).length() * 0.5;[m
[32m+[m		[32mtarget.radius = this.getSize( _vector$1 ).length() * 0.5;[m
 [m
 		return target;[m
 [m
[36m@@ -6641,7 +6691,7 @@[m [mfunction satForAxes( axes, v0, v1, v2, extents ) {[m
 [m
 }[m
 [m
[31m-var _box = new Box3();[m
[32m+[m[32mvar _box$1 = new Box3();[m
 [m
 /**[m
  * @author bhouston / http://clara.io[m
[36m@@ -6676,7 +6726,7 @@[m [mObject.assign( Sphere.prototype, {[m
 [m
 		} else {[m
 [m
[31m-			_box.setFromPoints( points ).getCenter( center );[m
[32m+[m			[32m_box$1.setFromPoints( points ).getCenter( center );[m
 [m
 		}[m
 [m
[36m@@ -6812,7 +6862,7 @@[m [mObject.assign( Sphere.prototype, {[m
 [m
 } );[m
 [m
[31m-var _vector$3 = new Vector3();[m
[32m+[m[32mvar _vector$2 = new Vector3();[m
 var _segCenter = new Vector3();[m
 var _segDir = new Vector3();[m
 var _diff = new Vector3();[m
[36m@@ -6828,7 +6878,7 @@[m [mvar _normal = new Vector3();[m
 function Ray( origin, direction ) {[m
 [m
 	this.origin = ( origin !== undefined ) ? origin : new Vector3();[m
[31m-	this.direction = ( direction !== undefined ) ? direction : new Vector3();[m
[32m+[m	[32mthis.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );[m
 [m
 }[m
 [m
[36m@@ -6881,7 +6931,7 @@[m [mObject.assign( Ray.prototype, {[m
 [m
 	recast: function ( t ) {[m
 [m
[31m-		this.origin.copy( this.at( t, _vector$3 ) );[m
[32m+[m		[32mthis.origin.copy( this.at( t, _vector$2 ) );[m
 [m
 		return this;[m
 [m
[36m@@ -6918,7 +6968,7 @@[m [mObject.assign( Ray.prototype, {[m
 [m
 	distanceSqToPoint: function ( point ) {[m
 [m
[31m-		var directionDistance = _vector$3.subVectors( point, this.origin ).dot( this.direction );[m
[32m+[m		[32mvar directionDistance = _vector$2.subVectors( point, this.origin ).dot( this.direction );[m
 [m
 		// point behind the ray[m
 [m
[36m@@ -6928,9 +6978,9 @@[m [mObject.assign( Ray.prototype, {[m
 [m
 		}[m
 [m
[31m-		_vector$3.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );[m
[32m+[m		[32m_vector$2.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );[m
 [m
[31m-		return _vector$3.distanceToSquared( point );[m
[32m+[m		[32mreturn _vector$2.distanceToSquared( point );[m
 [m
 	},[m
 [m
[36m@@ -7055,9 +7105,9 @@[m [mObject.assign( Ray.prototype, {[m
 [m
 	intersectSphere: function ( sphere, target ) {[m
 [m
[31m-		_vector$3.subVectors( sphere.center, this.origin );[m
[31m-		var tca = _vector$3.dot( this.direction );[m
[31m-		var d2 = _vector$3.dot( _vector$3 ) - tca * tca;[m
[32m+[m		[32m_vector$2.subVectors( sphere.center, this.origin );[m
[32m+[m		[32mvar tca = _vector$2.dot( this.direction );[m
[32m+[m		[32mvar d2 = _vector$2.dot( _vector$2 ) - tca * tca;[m
 		var radius2 = sphere.radius * sphere.radius;[m
 [m
 		if ( d2 > radius2 ) return null;[m
[36m@@ -7227,7 +7277,7 @@[m [mObject.assign( Ray.prototype, {[m
 [m
 	intersectsBox: function ( box ) {[m
 [m
[31m-		return this.intersectBox( box, _vector$3 ) !== null;[m
[32m+[m		[32mreturn this.intersectBox( box, _vector$2 ) !== null;[m
 [m
 	},[m
 [m
[36m@@ -7323,6 +7373,232 @@[m [mObject.assign( Ray.prototype, {[m
 [m
 } );[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * @author bhouston / http://clara.io[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mvar _vector1 = new Vector3();[m
[32m+[m[32mvar _vector2 = new Vector3();[m
[32m+[m[32mvar _normalMatrix = new Matrix3();[m
[32m+[m
[32m+[m[32mfunction Plane( normal, constant ) {[m
[32m+[m
[32m+[m	[32m// normal is assumed to be normalized[m
[32m+[m
[32m+[m	[32mthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );[m
[32m+[m	[32mthis.constant = ( constant !== undefined ) ? constant : 0;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mObject.assign( Plane.prototype, {[m
[32m+[m
[32m+[m	[32misPlane: true,[m
[32m+[m
[32m+[m	[32mset: function ( normal, constant ) {[m
[32m+[m
[32m+[m		[32mthis.normal.copy( normal );[m
[32m+[m		[32mthis.constant = constant;[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32msetComponents: function ( x, y, z, w ) {[m
[32m+[m
[32m+[m		[32mthis.normal.set( x, y, z );[m
[32m+[m		[32mthis.constant = w;[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32msetFromNormalAndCoplanarPoint: function ( normal, point ) {[m
[32m+[m
[32m+[m		[32mthis.normal.copy( normal );[m
[32m+[m		[32mthis.constant = - point.dot( this.normal );[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32msetFromCoplanarPoints: function ( a, b, c ) {[m
[32m+[m
[32m+[m		[32mvar normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();[m
[32m+[m
[32m+[m		[32m// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?[m
[32m+[m
[32m+[m		[32mthis.setFromNormalAndCoplanarPoint( normal, a );[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mclone: function () {[m
[32m+[m
[32m+[m		[32mreturn new this.constructor().copy( this );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mcopy: function ( plane ) {[m
[32m+[m
[32m+[m		[32mthis.normal.copy( plane.normal );[m
[32m+[m		[32mthis.constant = plane.constant;[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mnormalize: function () {[m
[32m+[m
[32m+[m		[32m// Note: will lead to a divide by zero if the plane is invalid.[m
[32m+[m
[32m+[m		[32mvar inverseNormalLength = 1.0 / this.normal.length();[m
[32m+[m		[32mthis.normal.multiplyScalar( inverseNormalLength );[m
[32m+[m		[32mthis.constant *= inverseNormalLength;[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mnegate: function () {[m
[32m+[m
[32m+[m		[32mthis.constant *= - 1;[m
[32m+[m		[32mthis.normal.negate();[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mdistanceToPoint: function ( point ) {[m
[32m+[m
[32m+[m		[32mreturn this.normal.dot( point ) + this.constant;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mdistanceToSphere: function ( sphere ) {[m
[32m+[m
[32m+[m		[32mreturn this.distanceToPoint( sphere.center ) - sphere.radius;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mprojectPoint: function ( point, target ) {[m
[32m+[m
[32m+[m		[32mif ( target === undefined ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );[m
[32m+[m			[32mtarget = new Vector3();[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mintersectLine: function ( line, target ) {[m
[32m+[m
[32m+[m		[32mif ( target === undefined ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );[m
[32m+[m			[32mtarget = new Vector3();[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mvar direction = line.delta( _vector1 );[m
[32m+[m
[32m+[m		[32mvar denominator = this.normal.dot( direction );[m
[32m+[m
[32m+[m		[32mif ( denominator === 0 ) {[m
[32m+[m
[32m+[m			[32m// line is coplanar, return origin[m
[32m+[m			[32mif ( this.distanceToPoint( line.start ) === 0 ) {[m
[32m+[m
[32m+[m				[32mreturn target.copy( line.start );[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32m// Unsure if this is the correct method to handle this case.[m
[32m+[m			[32mreturn undefined;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;[m
[32m+[m
[32m+[m		[32mif ( t < 0 || t > 1 ) {[m
[32m+[m
[32m+[m			[32mreturn undefined;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn target.copy( direction ).multiplyScalar( t ).add( line.start );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mintersectsLine: function ( line ) {[m
[32m+[m
[32m+[m		[32m// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.[m
[32m+[m
[32m+[m		[32mvar startSign = this.distanceToPoint( line.start );[m
[32m+[m		[32mvar endSign = this.distanceToPoint( line.end );[m
[32m+[m
[32m+[m		[32mreturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mintersectsBox: function ( box ) {[m
[32m+[m
[32m+[m		[32mreturn box.intersectsPlane( this );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mintersectsSphere: function ( sphere ) {[m
[32m+[m
[32m+[m		[32mreturn sphere.intersectsPlane( this );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mcoplanarPoint: function ( target ) {[m
[32m+[m
[32m+[m		[32mif ( target === undefined ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );[m
[32m+[m			[32mtarget = new Vector3();[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn target.copy( this.normal ).multiplyScalar( - this.constant );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mapplyMatrix4: function ( matrix, optionalNormalMatrix ) {[m
[32m+[m
[32m+[m		[32mvar normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );[m
[32m+[m
[32m+[m		[32mvar referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );[m
[32m+[m
[32m+[m		[32mvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();[m
[32m+[m
[32m+[m		[32mthis.constant = - referencePoint.dot( normal );[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mtranslate: function ( offset ) {[m
[32m+[m
[32m+[m		[32mthis.constant -= offset.dot( this.normal );[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mequals: function ( plane ) {[m
[32m+[m
[32m+[m		[32mreturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m[32m} );[m
[32m+[m
 /**[m
  * @author bhouston / http://clara.io[m
  * @author mrdoob / http://mrdoob.com/[m
[36m@@ -7519,7 +7795,7 @@[m [mObject.assign( Triangle.prototype, {[m
 		if ( target === undefined ) {[m
 [m
 			console.warn( 'THREE.Triangle: .getPlane() target is now required' );[m
[31m-			target = new Vector3();[m
[32m+[m			[32mtarget = new Plane();[m
 [m
 		}[m
 [m
[36m@@ -7782,9 +8058,9 @@[m [mObject.assign( Color.prototype, {[m
 	setHSL: function ( h, s, l ) {[m
 [m
 		// h,s,l ranges are in 0.0 - 1.0[m
[31m-		h = _Math.euclideanModulo( h, 1 );[m
[31m-		s = _Math.clamp( s, 0, 1 );[m
[31m-		l = _Math.clamp( l, 0, 1 );[m
[32m+[m		[32mh = MathUtils.euclideanModulo( h, 1 );[m
[32m+[m		[32ms = MathUtils.clamp( s, 0, 1 );[m
[32m+[m		[32ml = MathUtils.clamp( l, 0, 1 );[m
 [m
 		if ( s === 0 ) {[m
 [m
[36m@@ -7914,20 +8190,28 @@[m [mObject.assign( Color.prototype, {[m
 [m
 		if ( style && style.length > 0 ) {[m
 [m
[31m-			// color keywords[m
[31m-			var hex = _colorKeywords[ style ];[m
[32m+[m			[32mreturn this.setColorName( style );[m
 [m
[31m-			if ( hex !== undefined ) {[m
[32m+[m		[32m}[m
 [m
[31m-				// red[m
[31m-				this.setHex( hex );[m
[32m+[m		[32mreturn this;[m
 [m
[31m-			} else {[m
[32m+[m	[32m},[m
 [m
[31m-				// unknown color[m
[31m-				console.warn( 'THREE.Color: Unknown color ' + style );[m
[32m+[m	[32msetColorName: function ( style ) {[m
 [m
[31m-			}[m
[32m+[m		[32m// color keywords[m
[32m+[m		[32mvar hex = _colorKeywords[ style ];[m
[32m+[m
[32m+[m		[32mif ( hex !== undefined ) {[m
[32m+[m
[32m+[m			[32m// red[m
[32m+[m			[32mthis.setHex( hex );[m
[32m+[m
[32m+[m		[32m} else {[m
[32m+[m
[32m+[m			[32m// unknown color[m
[32m+[m			[32mconsole.warn( 'THREE.Color: Unknown color ' + style );[m
 [m
 		}[m
 [m
[36m@@ -8184,9 +8468,9 @@[m [mObject.assign( Color.prototype, {[m
 		this.getHSL( _hslA );[m
 		color.getHSL( _hslB );[m
 [m
[31m-		var h = _Math.lerp( _hslA.h, _hslB.h, alpha );[m
[31m-		var s = _Math.lerp( _hslA.s, _hslB.s, alpha );[m
[31m-		var l = _Math.lerp( _hslA.l, _hslB.l, alpha );[m
[32m+[m		[32mvar h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );[m
[32m+[m		[32mvar s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );[m
[32m+[m		[32mvar l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );[m
 [m
 		this.setHSL( h, s, l );[m
 [m
[36m@@ -8233,6 +8517,8 @@[m [mObject.assign( Color.prototype, {[m
 [m
 } );[m
 [m
[32m+[m[32mColor.NAMES = _colorKeywords;[m
[32m+[m
 /**[m
  * @author mrdoob / http://mrdoob.com/[m
  * @author alteredq / http://alteredqualia.com/[m
[36m@@ -8302,7 +8588,7 @@[m [mfunction Material() {[m
 [m
 	Object.defineProperty( this, 'id', { value: materialId ++ } );[m
 [m
[31m-	this.uuid = _Math.generateUUID();[m
[32m+[m	[32mthis.uuid = MathUtils.generateUUID();[m
 [m
 	this.name = '';[m
 	this.type = 'Material';[m
[36m@@ -8312,8 +8598,7 @@[m [mfunction Material() {[m
 	this.blending = NormalBlending;[m
 	this.side = FrontSide;[m
 	this.flatShading = false;[m
[31m-	this.vertexTangents = false;[m
[31m-	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors[m
[32m+[m	[32mthis.vertexColors = false;[m
 [m
 	this.opacity = 1;[m
 	this.transparent = false;[m
[36m@@ -8363,7 +8648,7 @@[m [mfunction Material() {[m
 [m
 	this.userData = {};[m
 [m
[31m-	this.needsUpdate = true;[m
[32m+[m	[32mthis.version = 0;[m
 [m
 }[m
 [m
[36m@@ -8467,6 +8752,18 @@[m [mMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;[m
 		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;[m
 [m
[32m+[m		[32mif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {[m
[32m+[m
[32m+[m			[32mdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {[m
[32m+[m
[32m+[m			[32mdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {[m
 [m
 			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;[m
[36m@@ -8538,7 +8835,7 @@[m [mMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 		if ( this.blending !== NormalBlending ) data.blending = this.blending;[m
 		if ( this.flatShading === true ) data.flatShading = this.flatShading;[m
 		if ( this.side !== FrontSide ) data.side = this.side;[m
[31m-		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;[m
[32m+[m		[32mif ( this.vertexColors ) data.vertexColors = true;[m
 [m
 		if ( this.opacity < 1 ) data.opacity = this.opacity;[m
 		if ( this.transparent === true ) data.transparent = this.transparent;[m
[36m@@ -8651,7 +8948,6 @@[m [mMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 		this.depthTest = source.depthTest;[m
 		this.depthWrite = source.depthWrite;[m
 [m
[31m-		this.stencilWrite = source.stencilWrite;[m
 		this.stencilWriteMask = source.stencilWriteMask;[m
 		this.stencilFunc = source.stencilFunc;[m
 		this.stencilRef = source.stencilRef;[m
[36m@@ -8659,6 +8955,26 @@[m [mMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 		this.stencilFail = source.stencilFail;[m
 		this.stencilZFail = source.stencilZFail;[m
 		this.stencilZPass = source.stencilZPass;[m
[32m+[m		[32mthis.stencilWrite = source.stencilWrite;[m
[32m+[m
[32m+[m		[32mvar srcPlanes = source.clippingPlanes,[m
[32m+[m			[32mdstPlanes = null;[m
[32m+[m
[32m+[m		[32mif ( srcPlanes !== null ) {[m
[32m+[m
[32m+[m			[32mvar n = srcPlanes.length;[m
[32m+[m			[32mdstPlanes = new Array( n );[m
[32m+[m
[32m+[m			[32mfor ( var i = 0; i !== n; ++ i )[m
[32m+[m				[32mdstPlanes[ i ] = srcPlanes[ i ].clone();[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mthis.clippingPlanes = dstPlanes;[m
[32m+[m		[32mthis.clipIntersection = source.clipIntersection;[m
[32m+[m		[32mthis.clipShadows = source.clipShadows;[m
[32m+[m
[32m+[m		[32mthis.shadowSide = source.shadowSide;[m
 [m
 		this.colorWrite = source.colorWrite;[m
 [m
[36m@@ -8679,33 +8995,23 @@[m [mMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		this.userData = JSON.parse( JSON.stringify( source.userData ) );[m
 [m
[31m-		this.clipShadows = source.clipShadows;[m
[31m-		this.clipIntersection = source.clipIntersection;[m
[31m-[m
[31m-		var srcPlanes = source.clippingPlanes,[m
[31m-			dstPlanes = null;[m
[31m-[m
[31m-		if ( srcPlanes !== null ) {[m
[31m-[m
[31m-			var n = srcPlanes.length;[m
[31m-			dstPlanes = new Array( n );[m
[32m+[m		[32mreturn this;[m
 [m
[31m-			for ( var i = 0; i !== n; ++ i )[m
[31m-				dstPlanes[ i ] = srcPlanes[ i ].clone();[m
[32m+[m	[32m},[m
 [m
[31m-		}[m
[32m+[m	[32mdispose: function () {[m
 [m
[31m-		this.clippingPlanes = dstPlanes;[m
[32m+[m		[32mthis.dispatchEvent( { type: 'dispose' } );[m
 [m
[31m-		this.shadowSide = source.shadowSide;[m
[32m+[m	[32m}[m
 [m
[31m-		return this;[m
[32m+[m[32m} );[m
 [m
[31m-	},[m
[32m+[m[32mObject.defineProperty( Material.prototype, 'needsUpdate', {[m
 [m
[31m-	dispose: function () {[m
[32m+[m	[32mset: function ( value ) {[m
 [m
[31m-		this.dispatchEvent( { type: 'dispose' } );[m
[32m+[m		[32mif ( value === true ) this.version ++;[m
 [m
 	}[m
 [m
[36m@@ -8827,6 +9133,8 @@[m [mMeshBasicMaterial.prototype.copy = function ( source ) {[m
  * @author mrdoob / http://mrdoob.com/[m
  */[m
 [m
[32m+[m[32mvar _vector$3 = new Vector3();[m
[32m+[m
 function BufferAttribute( array, itemSize, normalized ) {[m
 [m
 	if ( Array.isArray( array ) ) {[m
[36m@@ -8842,7 +9150,7 @@[m [mfunction BufferAttribute( array, itemSize, normalized ) {[m
 	this.count = array !== undefined ? array.length / itemSize : 0;[m
 	this.normalized = normalized === true;[m
 [m
[31m-	this.dynamic = false;[m
[32m+[m	[32mthis.usage = StaticDrawUsage;[m
 	this.updateRange = { offset: 0, count: - 1 };[m
 [m
 	this.version = 0;[m
[36m@@ -8865,9 +9173,9 @@[m [mObject.assign( BufferAttribute.prototype, {[m
 [m
 	onUploadCallback: function () {},[m
 [m
[31m-	setDynamic: function ( value ) {[m
[32m+[m	[32msetUsage: function ( value ) {[m
 [m
[31m-		this.dynamic = value;[m
[32m+[m		[32mthis.usage = value;[m
 [m
 		return this;[m
 [m
[36m@@ -8881,7 +9189,7 @@[m [mObject.assign( BufferAttribute.prototype, {[m
 		this.count = source.count;[m
 		this.normalized = source.normalized;[m
 [m
[31m-		this.dynamic = source.dynamic;[m
[32m+[m		[32mthis.usage = source.usage;[m
 [m
 		return this;[m
 [m
[36m@@ -9010,6 +9318,78 @@[m [mObject.assign( BufferAttribute.prototype, {[m
 [m
 	},[m
 [m
[32m+[m	[32mapplyMatrix3: function ( m ) {[m
[32m+[m
[32m+[m		[32mfor ( var i = 0, l = this.count; i < l; i ++ ) {[m
[32m+[m
[32m+[m			[32m_vector$3.x = this.getX( i );[m
[32m+[m			[32m_vector$3.y = this.getY( i );[m
[32m+[m			[32m_vector$3.z = this.getZ( i );[m
[32m+[m
[32m+[m			[32m_vector$3.applyMatrix3( m );[m
[32m+[m
[32m+[m			[32mthis.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mapplyMatrix4: function ( m ) {[m
[32m+[m
[32m+[m		[32mfor ( var i = 0, l = this.count; i < l; i ++ ) {[m
[32m+[m
[32m+[m			[32m_vector$3.x = this.getX( i );[m
[32m+[m			[32m_vector$3.y = this.getY( i );[m
[32m+[m			[32m_vector$3.z = this.getZ( i );[m
[32m+[m
[32m+[m			[32m_vector$3.applyMatrix4( m );[m
[32m+[m
[32m+[m			[32mthis.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mapplyNormalMatrix: function ( m ) {[m
[32m+[m
[32m+[m		[32mfor ( var i = 0, l = this.count; i < l; i ++ ) {[m
[32m+[m
[32m+[m			[32m_vector$3.x = this.getX( i );[m
[32m+[m			[32m_vector$3.y = this.getY( i );[m
[32m+[m			[32m_vector$3.z = this.getZ( i );[m
[32m+[m
[32m+[m			[32m_vector$3.applyNormalMatrix( m );[m
[32m+[m
[32m+[m			[32mthis.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mtransformDirection: function ( m ) {[m
[32m+[m
[32m+[m		[32mfor ( var i = 0, l = this.count; i < l; i ++ ) {[m
[32m+[m
[32m+[m			[32m_vector$3.x = this.getX( i );[m
[32m+[m			[32m_vector$3.y = this.getY( i );[m
[32m+[m			[32m_vector$3.z = this.getZ( i );[m
[32m+[m
[32m+[m			[32m_vector$3.transformDirection( m );[m
[32m+[m
[32m+[m			[32mthis.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
 	set: function ( value, offset ) {[m
 [m
 		if ( offset === undefined ) offset = 0;[m
[36m@@ -9542,7 +9922,7 @@[m [mvar _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id[m
 var _m1$2 = new Matrix4();[m
 var _obj = new Object3D();[m
 var _offset = new Vector3();[m
[31m-var _box$1 = new Box3();[m
[32m+[m[32mvar _box$2 = new Box3();[m
 var _boxMorphTargets = new Box3();[m
 var _vector$4 = new Vector3();[m
 [m
[36m@@ -9550,7 +9930,7 @@[m [mfunction BufferGeometry() {[m
 [m
 	Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );[m
 [m
[31m-	this.uuid = _Math.generateUUID();[m
[32m+[m	[32mthis.uuid = MathUtils.generateUUID();[m
 [m
 	this.name = '';[m
 	this.type = 'BufferGeometry';[m
[36m@@ -9559,6 +9939,7 @@[m [mfunction BufferGeometry() {[m
 	this.attributes = {};[m
 [m
 	this.morphAttributes = {};[m
[32m+[m	[32mthis.morphTargetsRelative = false;[m
 [m
 	this.groups = [];[m
 [m
[36m@@ -9597,29 +9978,6 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 	},[m
 [m
[31m-	addAttribute: function ( name, attribute ) {[m
[31m-[m
[31m-		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {[m
[31m-[m
[31m-			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );[m
[31m-[m
[31m-			return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		if ( name === 'index' ) {[m
[31m-[m
[31m-			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );[m
[31m-			this.setIndex( attribute );[m
[31m-[m
[31m-			return this;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		return this.setAttribute( name, attribute );[m
[31m-[m
[31m-	},[m
[31m-[m
 	getAttribute: function ( name ) {[m
 [m
 		return this.attributes[ name ];[m
[36m@@ -9634,7 +9992,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 	},[m
 [m
[31m-	removeAttribute: function ( name ) {[m
[32m+[m	[32mdeleteAttribute: function ( name ) {[m
 [m
 		delete this.attributes[ name ];[m
 [m
[36m@@ -9667,13 +10025,14 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 	},[m
 [m
[31m-	applyMatrix: function ( matrix ) {[m
[32m+[m	[32mapplyMatrix4: function ( matrix ) {[m
 [m
 		var position = this.attributes.position;[m
 [m
 		if ( position !== undefined ) {[m
 [m
[31m-			matrix.applyToBufferAttribute( position );[m
[32m+[m			[32mposition.applyMatrix4( matrix );[m
[32m+[m
 			position.needsUpdate = true;[m
 [m
 		}[m
[36m@@ -9684,7 +10043,8 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 			var normalMatrix = new Matrix3().getNormalMatrix( matrix );[m
 [m
[31m-			normalMatrix.applyToBufferAttribute( normal );[m
[32m+[m			[32mnormal.applyNormalMatrix( normalMatrix );[m
[32m+[m
 			normal.needsUpdate = true;[m
 [m
 		}[m
[36m@@ -9693,10 +10053,8 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		if ( tangent !== undefined ) {[m
 [m
[31m-			var normalMatrix = new Matrix3().getNormalMatrix( matrix );[m
[32m+[m			[32mtangent.transformDirection( matrix );[m
 [m
[31m-			// Tangent is vec4, but the '.w' component is a sign value (+1/-1).[m
[31m-			normalMatrix.applyToBufferAttribute( tangent );[m
 			tangent.needsUpdate = true;[m
 [m
 		}[m
[36m@@ -9723,7 +10081,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		_m1$2.makeRotationX( angle );[m
 [m
[31m-		this.applyMatrix( _m1$2 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$2 );[m
 [m
 		return this;[m
 [m
[36m@@ -9735,7 +10093,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		_m1$2.makeRotationY( angle );[m
 [m
[31m-		this.applyMatrix( _m1$2 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$2 );[m
 [m
 		return this;[m
 [m
[36m@@ -9747,7 +10105,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		_m1$2.makeRotationZ( angle );[m
 [m
[31m-		this.applyMatrix( _m1$2 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$2 );[m
 [m
 		return this;[m
 [m
[36m@@ -9759,7 +10117,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		_m1$2.makeTranslation( x, y, z );[m
 [m
[31m-		this.applyMatrix( _m1$2 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$2 );[m
 [m
 		return this;[m
 [m
[36m@@ -9771,7 +10129,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		_m1$2.makeScale( x, y, z );[m
 [m
[31m-		this.applyMatrix( _m1$2 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$2 );[m
 [m
 		return this;[m
 [m
[36m@@ -9783,7 +10141,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		_obj.updateMatrix();[m
 [m
[31m-		this.applyMatrix( _obj.matrix );[m
[32m+[m		[32mthis.applyMatrix4( _obj.matrix );[m
 [m
 		return this;[m
 [m
[36m@@ -9812,14 +10170,14 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );[m
 			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );[m
 [m
[31m-			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );[m
[31m-			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );[m
[32m+[m			[32mthis.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );[m
[32m+[m			[32mthis.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );[m
 [m
 			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {[m
 [m
 				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );[m
 [m
[31m-				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );[m
[32m+[m				[32mthis.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );[m
 [m
 			}[m
 [m
[36m@@ -9860,7 +10218,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		}[m
 [m
[31m-		this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );[m
[32m+[m		[32mthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );[m
 [m
 		return this;[m
 [m
[36m@@ -10004,33 +10362,33 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 	fromDirectGeometry: function ( geometry ) {[m
 [m
 		var positions = new Float32Array( geometry.vertices.length * 3 );[m
[31m-		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );[m
[32m+[m		[32mthis.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );[m
 [m
 		if ( geometry.normals.length > 0 ) {[m
 [m
 			var normals = new Float32Array( geometry.normals.length * 3 );[m
[31m-			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );[m
[32m+[m			[32mthis.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );[m
 [m
 		}[m
 [m
 		if ( geometry.colors.length > 0 ) {[m
 [m
 			var colors = new Float32Array( geometry.colors.length * 3 );[m
[31m-			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );[m
[32m+[m			[32mthis.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );[m
 [m
 		}[m
 [m
 		if ( geometry.uvs.length > 0 ) {[m
 [m
 			var uvs = new Float32Array( geometry.uvs.length * 2 );[m
[31m-			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );[m
[32m+[m			[32mthis.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );[m
 [m
 		}[m
 [m
 		if ( geometry.uvs2.length > 0 ) {[m
 [m
 			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );[m
[31m-			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );[m
[32m+[m			[32mthis.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );[m
 [m
 		}[m
 [m
[36m@@ -10065,14 +10423,14 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 		if ( geometry.skinIndices.length > 0 ) {[m
 [m
 			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );[m
[31m-			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );[m
[32m+[m			[32mthis.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );[m
 [m
 		}[m
 [m
 		if ( geometry.skinWeights.length > 0 ) {[m
 [m
 			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );[m
[31m-			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );[m
[32m+[m			[32mthis.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );[m
 [m
 		}[m
 [m
[36m@@ -10116,10 +10474,22 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 				for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {[m
 [m
 					var morphAttribute = morphAttributesPosition[ i ];[m
[31m-					_box$1.setFromBufferAttribute( morphAttribute );[m
[32m+[m					[32m_box$2.setFromBufferAttribute( morphAttribute );[m
[32m+[m
[32m+[m					[32mif ( this.morphTargetsRelative ) {[m
 [m
[31m-					this.boundingBox.expandByPoint( _box$1.min );[m
[31m-					this.boundingBox.expandByPoint( _box$1.max );[m
[32m+[m						[32m_vector$4.addVectors( this.boundingBox.min, _box$2.min );[m
[32m+[m						[32mthis.boundingBox.expandByPoint( _vector$4 );[m
[32m+[m
[32m+[m						[32m_vector$4.addVectors( this.boundingBox.max, _box$2.max );[m
[32m+[m						[32mthis.boundingBox.expandByPoint( _vector$4 );[m
[32m+[m
[32m+[m					[32m} else {[m
[32m+[m
[32m+[m						[32mthis.boundingBox.expandByPoint( _box$2.min );[m
[32m+[m						[32mthis.boundingBox.expandByPoint( _box$2.max );[m
[32m+[m
[32m+[m					[32m}[m
 [m
 				}[m
 [m
[36m@@ -10156,7 +10526,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 			var center = this.boundingSphere.center;[m
 [m
[31m-			_box$1.setFromBufferAttribute( position );[m
[32m+[m			[32m_box$2.setFromBufferAttribute( position );[m
 [m
 			// process morph attributes if present[m
 [m
[36m@@ -10167,14 +10537,26 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 					var morphAttribute = morphAttributesPosition[ i ];[m
 					_boxMorphTargets.setFromBufferAttribute( morphAttribute );[m
 [m
[31m-					_box$1.expandByPoint( _boxMorphTargets.min );[m
[31m-					_box$1.expandByPoint( _boxMorphTargets.max );[m
[32m+[m					[32mif ( this.morphTargetsRelative ) {[m
[32m+[m
[32m+[m						[32m_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );[m
[32m+[m						[32m_box$2.expandByPoint( _vector$4 );[m
[32m+[m
[32m+[m						[32m_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );[m
[32m+[m						[32m_box$2.expandByPoint( _vector$4 );[m
[32m+[m
[32m+[m					[32m} else {[m
[32m+[m
[32m+[m						[32m_box$2.expandByPoint( _boxMorphTargets.min );[m
[32m+[m						[32m_box$2.expandByPoint( _boxMorphTargets.max );[m
[32m+[m
[32m+[m					[32m}[m
 [m
 				}[m
 [m
 			}[m
 [m
[31m-			_box$1.getCenter( center );[m
[32m+[m			[32m_box$2.getCenter( center );[m
 [m
 			// second, try to find a boundingSphere with a radius smaller than the[m
 			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case[m
[36m@@ -10196,11 +10578,19 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 				for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {[m
 [m
 					var morphAttribute = morphAttributesPosition[ i ];[m
[32m+[m					[32mvar morphTargetsRelative = this.morphTargetsRelative;[m
 [m
 					for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {[m
 [m
 						_vector$4.fromBufferAttribute( morphAttribute, j );[m
 [m
[32m+[m						[32mif ( morphTargetsRelative ) {[m
[32m+[m
[32m+[m							[32m_offset.fromBufferAttribute( position, j );[m
[32m+[m							[32m_vector$4.add( _offset );[m
[32m+[m
[32m+[m						[32m}[m
[32m+[m
 						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );[m
 [m
 					}[m
[36m@@ -10238,7 +10628,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 			if ( attributes.normal === undefined ) {[m
 [m
[31m-				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );[m
[32m+[m				[32mthis.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );[m
 [m
 			} else {[m
 [m
[36m@@ -10446,7 +10836,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 			var newAttribute = convertBufferAttribute( attribute, indices );[m
 [m
[31m-			geometry2.addAttribute( name, newAttribute );[m
[32m+[m			[32mgeometry2.setAttribute( name, newAttribute );[m
 [m
 		}[m
 [m
[36m@@ -10473,6 +10863,8 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		}[m
 [m
[32m+[m		[32mgeometry2.morphTargetsRelative = this.morphTargetsRelative;[m
[32m+[m
 		// groups[m
 [m
 		var groups = this.groups;[m
[36m@@ -10577,7 +10969,12 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		}[m
 [m
[31m-		if ( hasMorphAttributes ) data.data.morphAttributes = morphAttributes;[m
[32m+[m		[32mif ( hasMorphAttributes ) {[m
[32m+[m
[32m+[m			[32mdata.data.morphAttributes = morphAttributes;[m
[32m+[m			[32mdata.data.morphTargetsRelative = this.morphTargetsRelative;[m
[32m+[m
[32m+[m		[32m}[m
 [m
 		var groups = this.groups;[m
 [m
[36m@@ -10666,7 +11063,7 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 		for ( name in attributes ) {[m
 [m
 			var attribute = attributes[ name ];[m
[31m-			this.addAttribute( name, attribute.clone() );[m
[32m+[m			[32mthis.setAttribute( name, attribute.clone() );[m
 [m
 		}[m
 [m
[36m@@ -10689,6 +11086,8 @@[m [mBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototy[m
 [m
 		}[m
 [m
[32m+[m		[32mthis.morphTargetsRelative = source.morphTargetsRelative;[m
[32m+[m
 		// groups[m
 [m
 		var groups = source.groups;[m
[36m@@ -10778,9 +11177,7 @@[m [mfunction Mesh( geometry, material ) {[m
 	this.type = 'Mesh';[m
 [m
 	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();[m
[31m-	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );[m
[31m-[m
[31m-	this.drawMode = TrianglesDrawMode;[m
[32m+[m	[32mthis.material = material !== undefined ? material : new MeshBasicMaterial();[m
 [m
 	this.updateMorphTargets();[m
 [m
[36m@@ -10792,18 +11189,10 @@[m [mMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 	isMesh: true,[m
 [m
[31m-	setDrawMode: function ( value ) {[m
[31m-[m
[31m-		this.drawMode = value;[m
[31m-[m
[31m-	},[m
[31m-[m
 	copy: function ( source ) {[m
 [m
 		Object3D.prototype.copy.call( this, source );[m
 [m
[31m-		this.drawMode = source.drawMode;[m
[31m-[m
 		if ( source.morphTargetInfluences !== undefined ) {[m
 [m
 			this.morphTargetInfluences = source.morphTargetInfluences.slice();[m
[36m@@ -10904,6 +11293,7 @@[m [mMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 			var index = geometry.index;[m
 			var position = geometry.attributes.position;[m
 			var morphPosition = geometry.morphAttributes.position;[m
[32m+[m			[32mvar morphTargetsRelative = geometry.morphTargetsRelative;[m
 			var uv = geometry.attributes.uv;[m
 			var uv2 = geometry.attributes.uv2;[m
 			var groups = geometry.groups;[m
[36m@@ -10932,7 +11322,7 @@[m [mMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 							b = index.getX( j + 1 );[m
 							c = index.getX( j + 2 );[m
 [m
[31m-							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, uv, uv2, a, b, c );[m
[32m+[m							[32mintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );[m
 [m
 							if ( intersection ) {[m
 [m
[36m@@ -10957,7 +11347,7 @@[m [mMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 						b = index.getX( i + 1 );[m
 						c = index.getX( i + 2 );[m
 [m
[31m-						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, uv, uv2, a, b, c );[m
[32m+[m						[32mintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );[m
 [m
 						if ( intersection ) {[m
 [m
[36m@@ -10990,7 +11380,7 @@[m [mMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 							b = j + 1;[m
 							c = j + 2;[m
 [m
[31m-							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, uv, uv2, a, b, c );[m
[32m+[m							[32mintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );[m
 [m
 							if ( intersection ) {[m
 [m
[36m@@ -11015,7 +11405,7 @@[m [mMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 						b = i + 1;[m
 						c = i + 2;[m
 [m
[31m-						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, uv, uv2, a, b, c );[m
[32m+[m						[32mintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );[m
 [m
 						if ( intersection ) {[m
 [m
[36m@@ -11119,7 +11509,7 @@[m [mfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point[m
 [m
 }[m
 [m
[31m-function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, uv, uv2, a, b, c ) {[m
[32m+[m[32mfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {[m
 [m
 	_vA.fromBufferAttribute( position, a );[m
 	_vB.fromBufferAttribute( position, b );[m
[36m@@ -11144,9 +11534,19 @@[m [mfunction checkBufferGeometryIntersection( object, material, raycaster, ray, posi[m
 			_tempB.fromBufferAttribute( morphAttribute, b );[m
 			_tempC.fromBufferAttribute( morphAttribute, c );[m
 [m
[31m-			_morphA.addScaledVector( _tempA.sub( _vA ), influence );[m
[31m-			_morphB.addScaledVector( _tempB.sub( _vB ), influence );[m
[31m-			_morphC.addScaledVector( _tempC.sub( _vC ), influence );[m
[32m+[m			[32mif ( morphTargetsRelative ) {[m
[32m+[m
[32m+[m				[32m_morphA.addScaledVector( _tempA, influence );[m
[32m+[m				[32m_morphB.addScaledVector( _tempB, influence );[m
[32m+[m				[32m_morphC.addScaledVector( _tempC, influence );[m
[32m+[m
[32m+[m			[32m} else {[m
[32m+[m
[32m+[m				[32m_morphA.addScaledVector( _tempA.sub( _vA ), influence );[m
[32m+[m				[32m_morphB.addScaledVector( _tempB.sub( _vB ), influence );[m
[32m+[m				[32m_morphC.addScaledVector( _tempC.sub( _vC ), influence );[m
[32m+[m
[32m+[m			[32m}[m
 [m
 		}[m
 [m
[36m@@ -11209,7 +11609,7 @@[m [mfunction Geometry() {[m
 [m
 	Object.defineProperty( this, 'id', { value: _geometryId += 2 } );[m
 [m
[31m-	this.uuid = _Math.generateUUID();[m
[32m+[m	[32mthis.uuid = MathUtils.generateUUID();[m
 [m
 	this.name = '';[m
 	this.type = 'Geometry';[m
[36m@@ -11248,7 +11648,7 @@[m [mGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 	isGeometry: true,[m
 [m
[31m-	applyMatrix: function ( matrix ) {[m
[32m+[m	[32mapplyMatrix4: function ( matrix ) {[m
 [m
 		var normalMatrix = new Matrix3().getNormalMatrix( matrix );[m
 [m
[36m@@ -11297,7 +11697,7 @@[m [mGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		_m1$3.makeRotationX( angle );[m
 [m
[31m-		this.applyMatrix( _m1$3 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$3 );[m
 [m
 		return this;[m
 [m
[36m@@ -11309,7 +11709,7 @@[m [mGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		_m1$3.makeRotationY( angle );[m
 [m
[31m-		this.applyMatrix( _m1$3 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$3 );[m
 [m
 		return this;[m
 [m
[36m@@ -11321,7 +11721,7 @@[m [mGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		_m1$3.makeRotationZ( angle );[m
 [m
[31m-		this.applyMatrix( _m1$3 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$3 );[m
 [m
 		return this;[m
 [m
[36m@@ -11333,7 +11733,7 @@[m [mGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		_m1$3.makeTranslation( x, y, z );[m
 [m
[31m-		this.applyMatrix( _m1$3 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$3 );[m
 [m
 		return this;[m
 [m
[36m@@ -11345,7 +11745,7 @@[m [mGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		_m1$3.makeScale( x, y, z );[m
 [m
[31m-		this.applyMatrix( _m1$3 );[m
[32m+[m		[32mthis.applyMatrix4( _m1$3 );[m
 [m
 		return this;[m
 [m
[36m@@ -11357,7 +11757,7 @@[m [mGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 [m
 		_obj$1.updateMatrix();[m
 [m
[31m-		this.applyMatrix( _obj$1.matrix );[m
[32m+[m		[32mthis.applyMatrix4( _obj$1.matrix );[m
 [m
 		return this;[m
 [m
[36m@@ -11532,7 +11932,7 @@[m [mGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ),[m
 			0, 0, 0, 1[m
 		);[m
 [m
[31m-		this.applyMatrix( matrix );[m
[32m+[m		[32mthis.applyMatrix4( matrix );[m
 [m
 		return this;[m
 [m
[36m@@ -12668,9 +13068,9 @@[m [mclass BoxBufferGeometry extends BufferGeometry {[m
 		// build geometry[m
 [m
 		this.setIndex( indices );[m
[31m-		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m		[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m		[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m		[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {[m
 [m
[36m@@ -13114,6 +13514,14 @@[m [mCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 	},[m
 [m
[32m+[m	[32mupdateWorldMatrix: function ( updateParents, updateChildren ) {[m
[32m+[m
[32m+[m		[32mObject3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );[m
[32m+[m
[32m+[m		[32mthis.matrixWorldInverse.getInverse( this.matrixWorld );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
 	clone: function () {[m
 [m
 		return new this.constructor().copy( this );[m
[36m@@ -13192,7 +13600,7 @@[m [mPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ),[m
 		// see http://www.bobatkins.com/photography/technical/field_of_view.html[m
 		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;[m
 [m
[31m-		this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );[m
[32m+[m		[32mthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );[m
 		this.updateProjectionMatrix();[m
 [m
 	},[m
[36m@@ -13202,7 +13610,7 @@[m [mPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ),[m
 	 */[m
 	getFocalLength: function () {[m
 [m
[31m-		var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );[m
[32m+[m		[32mvar vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );[m
 [m
 		return 0.5 * this.getFilmHeight() / vExtentSlope;[m
 [m
[36m@@ -13210,8 +13618,8 @@[m [mPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ),[m
 [m
 	getEffectiveFOV: function () {[m
 [m
[31m-		return _Math.RAD2DEG * 2 * Math.atan([m
[31m-			Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );[m
[32m+[m		[32mreturn MathUtils.RAD2DEG * 2 * Math.atan([m
[32m+[m			[32mMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );[m
 [m
 	},[m
 [m
[36m@@ -13309,7 +13717,7 @@[m [mPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ),[m
 	updateProjectionMatrix: function () {[m
 [m
 		var near = this.near,[m
[31m-			top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,[m
[32m+[m			[32mtop = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom,[m
 			height = 2 * top,[m
 			width = this.aspect * height,[m
 			left = - 0.5 * width,[m
[36m@@ -13407,7 +13815,7 @@[m [mfunction CubeCamera( near, far, cubeResolution, options ) {[m
 [m
 	options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };[m
 [m
[31m-	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );[m
[32m+[m	[32mthis.renderTarget = new WebGLCubeRenderTarget( cubeResolution, options );[m
 	this.renderTarget.texture.name = "CubeCamera";[m
 [m
 	this.update = function ( renderer, scene ) {[m
[36m@@ -13473,18 +13881,26 @@[m [mCubeCamera.prototype.constructor = CubeCamera;[m
  * @author WestLangley / http://github.com/WestLangley[m
  */[m
 [m
[31m-function WebGLRenderTargetCube( width, height, options ) {[m
[32m+[m[32mfunction WebGLCubeRenderTarget( size, options, dummy ) {[m
 [m
[31m-	WebGLRenderTarget.call( this, width, height, options );[m
[32m+[m	[32mif ( Number.isInteger( options ) ) {[m
[32m+[m
[32m+[m		[32mconsole.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );[m
[32m+[m
[32m+[m		[32moptions = dummy;[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mWebGLRenderTarget.call( this, size, size, options );[m
 [m
 }[m
 [m
[31m-WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );[m
[31m-WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;[m
[32m+[m[32mWebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );[m
[32m+[m[32mWebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;[m
 [m
[31m-WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;[m
[32m+[m[32mWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;[m
 [m
[31m-WebGLRenderTargetCube.prototype.fromEquirectangularTexture = function ( renderer, texture ) {[m
[32m+[m[32mWebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {[m
 [m
 	this.texture.type = texture.type;[m
 	this.texture.format = texture.format;[m
[36m@@ -13604,401 +14020,709 @@[m [mDataTexture.prototype.constructor = DataTexture;[m
 DataTexture.prototype.isDataTexture = true;[m
 [m
 /**[m
[32m+[m[32m * @author mrdoob / http://mrdoob.com/[m
[32m+[m[32m * @author alteredq / http://alteredqualia.com/[m
  * @author bhouston / http://clara.io[m
  */[m
 [m
[31m-var _vector1 = new Vector3();[m
[31m-var _vector2 = new Vector3();[m
[31m-var _normalMatrix = new Matrix3();[m
[32m+[m[32mvar _sphere$1 = new Sphere();[m
[32m+[m[32mvar _vector$5 = new Vector3();[m
 [m
[31m-function Plane( normal, constant ) {[m
[32m+[m[32mfunction Frustum( p0, p1, p2, p3, p4, p5 ) {[m
 [m
[31m-	// normal is assumed to be normalized[m
[32m+[m	[32mthis.planes = [[m
 [m
[31m-	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );[m
[31m-	this.constant = ( constant !== undefined ) ? constant : 0;[m
[32m+[m		[32m( p0 !== undefined ) ? p0 : new Plane(),[m
[32m+[m		[32m( p1 !== undefined ) ? p1 : new Plane(),[m
[32m+[m		[32m( p2 !== undefined ) ? p2 : new Plane(),[m
[32m+[m		[32m( p3 !== undefined ) ? p3 : new Plane(),[m
[32m+[m		[32m( p4 !== undefined ) ? p4 : new Plane(),[m
[32m+[m		[32m( p5 !== undefined ) ? p5 : new Plane()[m
[32m+[m
[32m+[m	[32m];[m
 [m
 }[m
 [m
[31m-Object.assign( Plane.prototype, {[m
[32m+[m[32mObject.assign( Frustum.prototype, {[m
 [m
[31m-	isPlane: true,[m
[32m+[m	[32mset: function ( p0, p1, p2, p3, p4, p5 ) {[m
 [m
[31m-	set: function ( normal, constant ) {[m
[32m+[m		[32mvar planes = this.planes;[m
 [m
[31m-		this.normal.copy( normal );[m
[31m-		this.constant = constant;[m
[32m+[m		[32mplanes[ 0 ].copy( p0 );[m
[32m+[m		[32mplanes[ 1 ].copy( p1 );[m
[32m+[m		[32mplanes[ 2 ].copy( p2 );[m
[32m+[m		[32mplanes[ 3 ].copy( p3 );[m
[32m+[m		[32mplanes[ 4 ].copy( p4 );[m
[32m+[m		[32mplanes[ 5 ].copy( p5 );[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setComponents: function ( x, y, z, w ) {[m
[32m+[m	[32mclone: function () {[m
 [m
[31m-		this.normal.set( x, y, z );[m
[31m-		this.constant = w;[m
[32m+[m		[32mreturn new this.constructor().copy( this );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mcopy: function ( frustum ) {[m
[32m+[m
[32m+[m		[32mvar planes = this.planes;[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < 6; i ++ ) {[m
[32m+[m
[32m+[m			[32mplanes[ i ].copy( frustum.planes[ i ] );[m
[32m+[m
[32m+[m		[32m}[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setFromNormalAndCoplanarPoint: function ( normal, point ) {[m
[32m+[m	[32msetFromProjectionMatrix: function ( m ) {[m
 [m
[31m-		this.normal.copy( normal );[m
[31m-		this.constant = - point.dot( this.normal );[m
[32m+[m		[32mvar planes = this.planes;[m
[32m+[m		[32mvar me = m.elements;[m
[32m+[m		[32mvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];[m
[32m+[m		[32mvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];[m
[32m+[m		[32mvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];[m
[32m+[m		[32mvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];[m
[32m+[m
[32m+[m		[32mplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();[m
[32m+[m		[32mplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();[m
[32m+[m		[32mplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();[m
[32m+[m		[32mplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();[m
[32m+[m		[32mplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();[m
[32m+[m		[32mplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();[m
 [m
 		return this;[m
 [m
 	},[m
 [m
[31m-	setFromCoplanarPoints: function ( a, b, c ) {[m
[32m+[m	[32mintersectsObject: function ( object ) {[m
 [m
[31m-		var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();[m
[32m+[m		[32mvar geometry = object.geometry;[m
 [m
[31m-		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?[m
[32m+[m		[32mif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();[m
 [m
[31m-		this.setFromNormalAndCoplanarPoint( normal, a );[m
[32m+[m		[32m_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );[m
 [m
[31m-		return this;[m
[32m+[m		[32mreturn this.intersectsSphere( _sphere$1 );[m
 [m
 	},[m
 [m
[31m-	clone: function () {[m
[32m+[m	[32mintersectsSprite: function ( sprite ) {[m
 [m
[31m-		return new this.constructor().copy( this );[m
[32m+[m		[32m_sphere$1.center.set( 0, 0, 0 );[m
[32m+[m		[32m_sphere$1.radius = 0.7071067811865476;[m
[32m+[m		[32m_sphere$1.applyMatrix4( sprite.matrixWorld );[m
[32m+[m
[32m+[m		[32mreturn this.intersectsSphere( _sphere$1 );[m
 [m
 	},[m
 [m
[31m-	copy: function ( plane ) {[m
[32m+[m	[32mintersectsSphere: function ( sphere ) {[m
 [m
[31m-		this.normal.copy( plane.normal );[m
[31m-		this.constant = plane.constant;[m
[32m+[m		[32mvar planes = this.planes;[m
[32m+[m		[32mvar center = sphere.center;[m
[32m+[m		[32mvar negRadius = - sphere.radius;[m
 [m
[31m-		return this;[m
[32m+[m		[32mfor ( var i = 0; i < 6; i ++ ) {[m
[32m+[m
[32m+[m			[32mvar distance = planes[ i ].distanceToPoint( center );[m
[32m+[m
[32m+[m			[32mif ( distance < negRadius ) {[m
[32m+[m
[32m+[m				[32mreturn false;[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn true;[m
 [m
 	},[m
 [m
[31m-	normalize: function () {[m
[32m+[m	[32mintersectsBox: function ( box ) {[m
 [m
[31m-		// Note: will lead to a divide by zero if the plane is invalid.[m
[32m+[m		[32mvar planes = this.planes;[m
 [m
[31m-		var inverseNormalLength = 1.0 / this.normal.length();[m
[31m-		this.normal.multiplyScalar( inverseNormalLength );[m
[31m-		this.constant *= inverseNormalLength;[m
[32m+[m		[32mfor ( var i = 0; i < 6; i ++ ) {[m
 [m
[31m-		return this;[m
[32m+[m			[32mvar plane = planes[ i ];[m
[32m+[m
[32m+[m			[32m// corner at max distance[m
[32m+[m
[32m+[m			[32m_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;[m
[32m+[m			[32m_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;[m
[32m+[m			[32m_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;[m
[32m+[m
[32m+[m			[32mif ( plane.distanceToPoint( _vector$5 ) < 0 ) {[m
[32m+[m
[32m+[m				[32mreturn false;[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn true;[m
 [m
 	},[m
 [m
[31m-	negate: function () {[m
[32m+[m	[32mcontainsPoint: function ( point ) {[m
 [m
[31m-		this.constant *= - 1;[m
[31m-		this.normal.negate();[m
[32m+[m		[32mvar planes = this.planes;[m
 [m
[31m-		return this;[m
[32m+[m		[32mfor ( var i = 0; i < 6; i ++ ) {[m
[32m+[m
[32m+[m			[32mif ( planes[ i ].distanceToPoint( point ) < 0 ) {[m
[32m+[m
[32m+[m				[32mreturn false;[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn true;[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m[32m} );[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Uniforms library for shared webgl shaders[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mvar UniformsLib = {[m
[32m+[m
[32m+[m	[32mcommon: {[m
[32m+[m
[32m+[m		[32mdiffuse: { value: new Color( 0xeeeeee ) },[m
[32m+[m		[32mopacity: { value: 1.0 },[m
[32m+[m
[32m+[m		[32mmap: { value: null },[m
[32m+[m		[32muvTransform: { value: new Matrix3() },[m
[32m+[m		[32muv2Transform: { value: new Matrix3() },[m
[32m+[m
[32m+[m		[32malphaMap: { value: null },[m
 [m
 	},[m
 [m
[31m-	distanceToPoint: function ( point ) {[m
[32m+[m	[32mspecularmap: {[m
 [m
[31m-		return this.normal.dot( point ) + this.constant;[m
[32m+[m		[32mspecularMap: { value: null },[m
 [m
 	},[m
 [m
[31m-	distanceToSphere: function ( sphere ) {[m
[32m+[m	[32menvmap: {[m
 [m
[31m-		return this.distanceToPoint( sphere.center ) - sphere.radius;[m
[32m+[m		[32menvMap: { value: null },[m
[32m+[m		[32mflipEnvMap: { value: - 1 },[m
[32m+[m		[32mreflectivity: { value: 1.0 },[m
[32m+[m		[32mrefractionRatio: { value: 0.98 },[m
[32m+[m		[32mmaxMipLevel: { value: 0 }[m
 [m
 	},[m
 [m
[31m-	projectPoint: function ( point, target ) {[m
[32m+[m	[32maomap: {[m
 [m
[31m-		if ( target === undefined ) {[m
[32m+[m		[32maoMap: { value: null },[m
[32m+[m		[32maoMapIntensity: { value: 1 }[m
 [m
[31m-			console.warn( 'THREE.Plane: .projectPoint() target is now required' );[m
[31m-			target = new Vector3();[m
[32m+[m	[32m},[m
 [m
[31m-		}[m
[32m+[m	[32mlightmap: {[m
 [m
[31m-		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );[m
[32m+[m		[32mlightMap: { value: null },[m
[32m+[m		[32mlightMapIntensity: { value: 1 }[m
 [m
 	},[m
 [m
[31m-	intersectLine: function ( line, target ) {[m
[32m+[m	[32memissivemap: {[m
 [m
[31m-		if ( target === undefined ) {[m
[32m+[m		[32memissiveMap: { value: null }[m
 [m
[31m-			console.warn( 'THREE.Plane: .intersectLine() target is now required' );[m
[31m-			target = new Vector3();[m
[32m+[m	[32m},[m
 [m
[31m-		}[m
[32m+[m	[32mbumpmap: {[m
 [m
[31m-		var direction = line.delta( _vector1 );[m
[32m+[m		[32mbumpMap: { value: null },[m
[32m+[m		[32mbumpScale: { value: 1 }[m
 [m
[31m-		var denominator = this.normal.dot( direction );[m
[32m+[m	[32m},[m
 [m
[31m-		if ( denominator === 0 ) {[m
[32m+[m	[32mnormalmap: {[m
 [m
[31m-			// line is coplanar, return origin[m
[31m-			if ( this.distanceToPoint( line.start ) === 0 ) {[m
[32m+[m		[32mnormalMap: { value: null },[m
[32m+[m		[32mnormalScale: { value: new Vector2( 1, 1 ) }[m
 [m
[31m-				return target.copy( line.start );[m
[32m+[m	[32m},[m
 [m
[31m-			}[m
[32m+[m	[32mdisplacementmap: {[m
 [m
[31m-			// Unsure if this is the correct method to handle this case.[m
[31m-			return undefined;[m
[32m+[m		[32mdisplacementMap: { value: null },[m
[32m+[m		[32mdisplacementScale: { value: 1 },[m
[32m+[m		[32mdisplacementBias: { value: 0 }[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mroughnessmap: {[m
[32m+[m
[32m+[m		[32mroughnessMap: { value: null }[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mmetalnessmap: {[m
[32m+[m
[32m+[m		[32mmetalnessMap: { value: null }[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mgradientmap: {[m
[32m+[m
[32m+[m		[32mgradientMap: { value: null }[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mfog: {[m
[32m+[m
[32m+[m		[32mfogDensity: { value: 0.00025 },[m
[32m+[m		[32mfogNear: { value: 1 },[m
[32m+[m		[32mfogFar: { value: 2000 },[m
[32m+[m		[32mfogColor: { value: new Color( 0xffffff ) }[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mlights: {[m
[32m+[m
[32m+[m		[32mambientLightColor: { value: [] },[m
[32m+[m
[32m+[m		[32mlightProbe: { value: [] },[m
[32m+[m
[32m+[m		[32mdirectionalLights: { value: [], properties: {[m
[32m+[m			[32mdirection: {},[m
[32m+[m			[32mcolor: {}[m
[32m+[m		[32m} },[m
[32m+[m
[32m+[m		[32mdirectionalLightShadows: { value: [], properties: {[m
[32m+[m			[32mshadowBias: {},[m
[32m+[m			[32mshadowRadius: {},[m
[32m+[m			[32mshadowMapSize: {}[m
[32m+[m		[32m} },[m
[32m+[m
[32m+[m		[32mdirectionalShadowMap: { value: [] },[m
[32m+[m		[32mdirectionalShadowMatrix: { value: [] },[m
[32m+[m
[32m+[m		[32mspotLights: { value: [], properties: {[m
[32m+[m			[32mcolor: {},[m
[32m+[m			[32mposition: {},[m
[32m+[m			[32mdirection: {},[m
[32m+[m			[32mdistance: {},[m
[32m+[m			[32mconeCos: {},[m
[32m+[m			[32mpenumbraCos: {},[m
[32m+[m			[32mdecay: {}[m
[32m+[m		[32m} },[m
[32m+[m
[32m+[m		[32mspotLightShadows: { value: [], properties: {[m
[32m+[m			[32mshadowBias: {},[m
[32m+[m			[32mshadowRadius: {},[m
[32m+[m			[32mshadowMapSize: {}[m
[32m+[m		[32m} },[m
[32m+[m
[32m+[m		[32mspotShadowMap: { value: [] },[m
[32m+[m		[32mspotShadowMatrix: { value: [] },[m
[32m+[m
[32m+[m		[32mpointLights: { value: [], properties: {[m
[32m+[m			[32mcolor: {},[m
[32m+[m			[32mposition: {},[m
[32m+[m			[32mdecay: {},[m
[32m+[m			[32mdistance: {}[m
[32m+[m		[32m} },[m
[32m+[m
[32m+[m		[32mpointLightShadows: { value: [], properties: {[m
[32m+[m			[32mshadowBias: {},[m
[32m+[m			[32mshadowRadius: {},[m
[32m+[m			[32mshadowMapSize: {},[m
[32m+[m			[32mshadowCameraNear: {},[m
[32m+[m			[32mshadowCameraFar: {}[m
[32m+[m		[32m} },[m
[32m+[m
[32m+[m		[32mpointShadowMap: { value: [] },[m
[32m+[m		[32mpointShadowMatrix: { value: [] },[m
[32m+[m
[32m+[m		[32mhemisphereLights: { value: [], properties: {[m
[32m+[m			[32mdirection: {},[m
[32m+[m			[32mskyColor: {},[m
[32m+[m			[32mgroundColor: {}[m
[32m+[m		[32m} },[m
[32m+[m
[32m+[m		[32m// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src[m
[32m+[m		[32mrectAreaLights: { value: [], properties: {[m
[32m+[m			[32mcolor: {},[m
[32m+[m			[32mposition: {},[m
[32m+[m			[32mwidth: {},[m
[32m+[m			[32mheight: {}[m
[32m+[m		[32m} }[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mpoints: {[m
[32m+[m
[32m+[m		[32mdiffuse: { value: new Color( 0xeeeeee ) },[m
[32m+[m		[32mopacity: { value: 1.0 },[m
[32m+[m		[32msize: { value: 1.0 },[m
[32m+[m		[32mscale: { value: 1.0 },[m
[32m+[m		[32mmap: { value: null },[m
[32m+[m		[32malphaMap: { value: null },[m
[32m+[m		[32muvTransform: { value: new Matrix3() }[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32msprite: {[m
[32m+[m
[32m+[m		[32mdiffuse: { value: new Color( 0xeeeeee ) },[m
[32m+[m		[32mopacity: { value: 1.0 },[m
[32m+[m		[32mcenter: { value: new Vector2( 0.5, 0.5 ) },[m
[32m+[m		[32mrotation: { value: 0.0 },[m
[32m+[m		[32mmap: { value: null },[m
[32m+[m		[32malphaMap: { value: null },[m
[32m+[m		[32muvTransform: { value: new Matrix3() }[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @author mrdoob / http://mrdoob.com/[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mfunction WebGLAnimation() {[m
[32m+[m
[32m+[m	[32mvar context = null;[m
[32m+[m	[32mvar isAnimating = false;[m
[32m+[m	[32mvar animationLoop = null;[m
[32m+[m
[32m+[m	[32mfunction onAnimationFrame( time, frame ) {[m
[32m+[m
[32m+[m		[32mif ( isAnimating === false ) return;[m
[32m+[m
[32m+[m		[32manimationLoop( time, frame );[m
[32m+[m
[32m+[m		[32mcontext.requestAnimationFrame( onAnimationFrame );[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mreturn {[m
[32m+[m
[32m+[m		[32mstart: function () {[m
[32m+[m
[32m+[m			[32mif ( isAnimating === true ) return;[m
[32m+[m			[32mif ( animationLoop === null ) return;[m
[32m+[m
[32m+[m			[32mcontext.requestAnimationFrame( onAnimationFrame );[m
[32m+[m
[32m+[m			[32misAnimating = true;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m
[32m+[m		[32mstop: function () {[m
[32m+[m
[32m+[m			[32misAnimating = false;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m
[32m+[m		[32msetAnimationLoop: function ( callback ) {[m
[32m+[m
[32m+[m			[32manimationLoop = callback;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m
[32m+[m		[32msetContext: function ( value ) {[m
[32m+[m
[32m+[m			[32mcontext = value;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m};[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @author mrdoob / http://mrdoob.com/[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mfunction WebGLAttributes( gl, capabilities ) {[m
[32m+[m
[32m+[m	[32mvar isWebGL2 = capabilities.isWebGL2;[m
[32m+[m
[32m+[m	[32mvar buffers = new WeakMap();[m
 [m
[31m-		}[m
[32m+[m	[32mfunction createBuffer( attribute, bufferType ) {[m
 [m
[31m-		var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;[m
[32m+[m		[32mvar array = attribute.array;[m
[32m+[m		[32mvar usage = attribute.usage;[m
 [m
[31m-		if ( t < 0 || t > 1 ) {[m
[32m+[m		[32mvar buffer = gl.createBuffer();[m
 [m
[31m-			return undefined;[m
[32m+[m		[32mgl.bindBuffer( bufferType, buffer );[m
[32m+[m		[32mgl.bufferData( bufferType, array, usage );[m
 [m
[31m-		}[m
[32m+[m		[32mattribute.onUploadCallback();[m
 [m
[31m-		return target.copy( direction ).multiplyScalar( t ).add( line.start );[m
[32m+[m		[32mvar type = 5126;[m
 [m
[31m-	},[m
[32m+[m		[32mif ( array instanceof Float32Array ) {[m
 [m
[31m-	intersectsLine: function ( line ) {[m
[32m+[m			[32mtype = 5126;[m
 [m
[31m-		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.[m
[32m+[m		[32m} else if ( array instanceof Float64Array ) {[m
 [m
[31m-		var startSign = this.distanceToPoint( line.start );[m
[31m-		var endSign = this.distanceToPoint( line.end );[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );[m
 [m
[31m-		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );[m
[32m+[m		[32m} else if ( array instanceof Uint16Array ) {[m
 [m
[31m-	},[m
[32m+[m			[32mtype = 5123;[m
 [m
[31m-	intersectsBox: function ( box ) {[m
[32m+[m		[32m} else if ( array instanceof Int16Array ) {[m
 [m
[31m-		return box.intersectsPlane( this );[m
[32m+[m			[32mtype = 5122;[m
 [m
[31m-	},[m
[32m+[m		[32m} else if ( array instanceof Uint32Array ) {[m
 [m
[31m-	intersectsSphere: function ( sphere ) {[m
[32m+[m			[32mtype = 5125;[m
 [m
[31m-		return sphere.intersectsPlane( this );[m
[32m+[m		[32m} else if ( array instanceof Int32Array ) {[m
 [m
[31m-	},[m
[32m+[m			[32mtype = 5124;[m
 [m
[31m-	coplanarPoint: function ( target ) {[m
[32m+[m		[32m} else if ( array instanceof Int8Array ) {[m
 [m
[31m-		if ( target === undefined ) {[m
[32m+[m			[32mtype = 5120;[m
 [m
[31m-			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );[m
[31m-			target = new Vector3();[m
[32m+[m		[32m} else if ( array instanceof Uint8Array ) {[m
[32m+[m
[32m+[m			[32mtype = 5121;[m
 [m
 		}[m
 [m
[31m-		return target.copy( this.normal ).multiplyScalar( - this.constant );[m
[32m+[m		[32mreturn {[m
[32m+[m			[32mbuffer: buffer,[m
[32m+[m			[32mtype: type,[m
[32m+[m			[32mbytesPerElement: array.BYTES_PER_ELEMENT,[m
[32m+[m			[32mversion: attribute.version[m
[32m+[m		[32m};[m
 [m
[31m-	},[m
[32m+[m	[32m}[m
 [m
[31m-	applyMatrix4: function ( matrix, optionalNormalMatrix ) {[m
[32m+[m	[32mfunction updateBuffer( buffer, attribute, bufferType ) {[m
 [m
[31m-		var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );[m
[32m+[m		[32mvar array = attribute.array;[m
[32m+[m		[32mvar updateRange = attribute.updateRange;[m
 [m
[31m-		var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );[m
[32m+[m		[32mgl.bindBuffer( bufferType, buffer );[m
 [m
[31m-		var normal = this.normal.applyMatrix3( normalMatrix ).normalize();[m
[32m+[m		[32mif ( updateRange.count === - 1 ) {[m
 [m
[31m-		this.constant = - referencePoint.dot( normal );[m
[32m+[m			[32m// Not using update ranges[m
 [m
[31m-		return this;[m
[32m+[m			[32mgl.bufferSubData( bufferType, 0, array );[m
 [m
[31m-	},[m
[32m+[m		[32m} else {[m
 [m
[31m-	translate: function ( offset ) {[m
[32m+[m			[32mif ( isWebGL2 ) {[m
 [m
[31m-		this.constant -= offset.dot( this.normal );[m
[32m+[m				[32mgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,[m
[32m+[m					[32marray, updateRange.offset, updateRange.count );[m
 [m
[31m-		return this;[m
[32m+[m			[32m} else {[m
 [m
[31m-	},[m
[32m+[m				[32mgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,[m
[32m+[m					[32marray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );[m
 [m
[31m-	equals: function ( plane ) {[m
[32m+[m			[32m}[m
 [m
[31m-		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );[m
[32m+[m			[32mupdateRange.count = - 1; // reset range[m
[32m+[m
[32m+[m		[32m}[m
 [m
 	}[m
 [m
[31m-} );[m
[32m+[m	[32m//[m
 [m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- * @author alteredq / http://alteredqualia.com/[m
[31m- * @author bhouston / http://clara.io[m
[31m- */[m
[32m+[m	[32mfunction get( attribute ) {[m
 [m
[31m-var _sphere$1 = new Sphere();[m
[31m-var _vector$5 = new Vector3();[m
[32m+[m		[32mif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;[m
 [m
[31m-function Frustum( p0, p1, p2, p3, p4, p5 ) {[m
[32m+[m		[32mreturn buffers.get( attribute );[m
 [m
[31m-	this.planes = [[m
[32m+[m	[32m}[m
 [m
[31m-		( p0 !== undefined ) ? p0 : new Plane(),[m
[31m-		( p1 !== undefined ) ? p1 : new Plane(),[m
[31m-		( p2 !== undefined ) ? p2 : new Plane(),[m
[31m-		( p3 !== undefined ) ? p3 : new Plane(),[m
[31m-		( p4 !== undefined ) ? p4 : new Plane(),[m
[31m-		( p5 !== undefined ) ? p5 : new Plane()[m
[32m+[m	[32mfunction remove( attribute ) {[m
 [m
[31m-	];[m
[32m+[m		[32mif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;[m
 [m
[31m-}[m
[32m+[m		[32mvar data = buffers.get( attribute );[m
 [m
[31m-Object.assign( Frustum.prototype, {[m
[32m+[m		[32mif ( data ) {[m
 [m
[31m-	set: function ( p0, p1, p2, p3, p4, p5 ) {[m
[32m+[m			[32mgl.deleteBuffer( data.buffer );[m
 [m
[31m-		var planes = this.planes;[m
[32m+[m			[32mbuffers.delete( attribute );[m
 [m
[31m-		planes[ 0 ].copy( p0 );[m
[31m-		planes[ 1 ].copy( p1 );[m
[31m-		planes[ 2 ].copy( p2 );[m
[31m-		planes[ 3 ].copy( p3 );[m
[31m-		planes[ 4 ].copy( p4 );[m
[31m-		planes[ 5 ].copy( p5 );[m
[32m+[m		[32m}[m
 [m
[31m-		return this;[m
[32m+[m	[32m}[m
 [m
[31m-	},[m
[32m+[m	[32mfunction update( attribute, bufferType ) {[m
 [m
[31m-	clone: function () {[m
[32m+[m		[32mif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;[m
 [m
[31m-		return new this.constructor().copy( this );[m
[32m+[m		[32mvar data = buffers.get( attribute );[m
 [m
[31m-	},[m
[32m+[m		[32mif ( data === undefined ) {[m
 [m
[31m-	copy: function ( frustum ) {[m
[32m+[m			[32mbuffers.set( attribute, createBuffer( attribute, bufferType ) );[m
 [m
[31m-		var planes = this.planes;[m
[32m+[m		[32m} else if ( data.version < attribute.version ) {[m
 [m
[31m-		for ( var i = 0; i < 6; i ++ ) {[m
[32m+[m			[32mupdateBuffer( data.buffer, attribute, bufferType );[m
 [m
[31m-			planes[ i ].copy( frustum.planes[ i ] );[m
[32m+[m			[32mdata.version = attribute.version;[m
 [m
 		}[m
 [m
[31m-		return this;[m
[31m-[m
[31m-	},[m
[32m+[m	[32m}[m
 [m
[31m-	setFromMatrix: function ( m ) {[m
[32m+[m	[32mreturn {[m
 [m
[31m-		var planes = this.planes;[m
[31m-		var me = m.elements;[m
[31m-		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];[m
[31m-		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];[m
[31m-		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];[m
[31m-		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];[m
[32m+[m		[32mget: get,[m
[32m+[m		[32mremove: remove,[m
[32m+[m		[32mupdate: update[m
 [m
[31m-		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();[m
[31m-		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();[m
[31m-		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();[m
[31m-		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();[m
[31m-		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();[m
[31m-		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();[m
[32m+[m	[32m};[m
 [m
[31m-		return this;[m
[32m+[m[32m}[m
 [m
[31m-	},[m
[32m+[m[32m/**[m
[32m+[m[32m * @author mrdoob / http://mrdoob.com/[m
[32m+[m[32m * @author Mugen87 / https://github.com/Mugen87[m
[32m+[m[32m */[m
 [m
[31m-	intersectsObject: function ( object ) {[m
[32m+[m[32m// PlaneGeometry[m
 [m
[31m-		var geometry = object.geometry;[m
[32m+[m[32mfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {[m
 [m
[31m-		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();[m
[32m+[m	[32mGeometry.call( this );[m
 [m
[31m-		_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );[m
[32m+[m	[32mthis.type = 'PlaneGeometry';[m
 [m
[31m-		return this.intersectsSphere( _sphere$1 );[m
[32m+[m	[32mthis.parameters = {[m
[32m+[m		[32mwidth: width,[m
[32m+[m		[32mheight: height,[m
[32m+[m		[32mwidthSegments: widthSegments,[m
[32m+[m		[32mheightSegments: heightSegments[m
[32m+[m	[32m};[m
 [m
[31m-	},[m
[32m+[m	[32mthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );[m
[32m+[m	[32mthis.mergeVertices();[m
 [m
[31m-	intersectsSprite: function ( sprite ) {[m
[32m+[m[32m}[m
 [m
[31m-		_sphere$1.center.set( 0, 0, 0 );[m
[31m-		_sphere$1.radius = 0.7071067811865476;[m
[31m-		_sphere$1.applyMatrix4( sprite.matrixWorld );[m
[32m+[m[32mPlaneGeometry.prototype = Object.create( Geometry.prototype );[m
[32m+[m[32mPlaneGeometry.prototype.constructor = PlaneGeometry;[m
 [m
[31m-		return this.intersectsSphere( _sphere$1 );[m
[32m+[m[32m// PlaneBufferGeometry[m
 [m
[31m-	},[m
[32m+[m[32mfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {[m
 [m
[31m-	intersectsSphere: function ( sphere ) {[m
[32m+[m	[32mBufferGeometry.call( this );[m
 [m
[31m-		var planes = this.planes;[m
[31m-		var center = sphere.center;[m
[31m-		var negRadius = - sphere.radius;[m
[32m+[m	[32mthis.type = 'PlaneBufferGeometry';[m
 [m
[31m-		for ( var i = 0; i < 6; i ++ ) {[m
[32m+[m	[32mthis.parameters = {[m
[32m+[m		[32mwidth: width,[m
[32m+[m		[32mheight: height,[m
[32m+[m		[32mwidthSegments: widthSegments,[m
[32m+[m		[32mheightSegments: heightSegments[m
[32m+[m	[32m};[m
 [m
[31m-			var distance = planes[ i ].distanceToPoint( center );[m
[32m+[m	[32mwidth = width || 1;[m
[32m+[m	[32mheight = height || 1;[m
 [m
[31m-			if ( distance < negRadius ) {[m
[32m+[m	[32mvar width_half = width / 2;[m
[32m+[m	[32mvar height_half = height / 2;[m
 [m
[31m-				return false;[m
[32m+[m	[32mvar gridX = Math.floor( widthSegments ) || 1;[m
[32m+[m	[32mvar gridY = Math.floor( heightSegments ) || 1;[m
 [m
[31m-			}[m
[32m+[m	[32mvar gridX1 = gridX + 1;[m
[32m+[m	[32mvar gridY1 = gridY + 1;[m
 [m
[31m-		}[m
[32m+[m	[32mvar segment_width = width / gridX;[m
[32m+[m	[32mvar segment_height = height / gridY;[m
 [m
[31m-		return true;[m
[32m+[m	[32mvar ix, iy;[m
 [m
[31m-	},[m
[32m+[m	[32m// buffers[m
 [m
[31m-	intersectsBox: function ( box ) {[m
[32m+[m	[32mvar indices = [];[m
[32m+[m	[32mvar vertices = [];[m
[32m+[m	[32mvar normals = [];[m
[32m+[m	[32mvar uvs = [];[m
 [m
[31m-		var planes = this.planes;[m
[32m+[m	[32m// generate vertices, normals and uvs[m
 [m
[31m-		for ( var i = 0; i < 6; i ++ ) {[m
[32m+[m	[32mfor ( iy = 0; iy < gridY1; iy ++ ) {[m
 [m
[31m-			var plane = planes[ i ];[m
[32m+[m		[32mvar y = iy * segment_height - height_half;[m
 [m
[31m-			// corner at max distance[m
[32m+[m		[32mfor ( ix = 0; ix < gridX1; ix ++ ) {[m
 [m
[31m-			_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;[m
[31m-			_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;[m
[31m-			_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;[m
[32m+[m			[32mvar x = ix * segment_width - width_half;[m
 [m
[31m-			if ( plane.distanceToPoint( _vector$5 ) < 0 ) {[m
[32m+[m			[32mvertices.push( x, - y, 0 );[m
 [m
[31m-				return false;[m
[32m+[m			[32mnormals.push( 0, 0, 1 );[m
 [m
[31m-			}[m
[32m+[m			[32muvs.push( ix / gridX );[m
[32m+[m			[32muvs.push( 1 - ( iy / gridY ) );[m
 [m
 		}[m
 [m
[31m-		return true;[m
[31m-[m
[31m-	},[m
[32m+[m	[32m}[m
 [m
[31m-	containsPoint: function ( point ) {[m
[32m+[m	[32m// indices[m
 [m
[31m-		var planes = this.planes;[m
[32m+[m	[32mfor ( iy = 0; iy < gridY; iy ++ ) {[m
 [m
[31m-		for ( var i = 0; i < 6; i ++ ) {[m
[32m+[m		[32mfor ( ix = 0; ix < gridX; ix ++ ) {[m
 [m
[31m-			if ( planes[ i ].distanceToPoint( point ) < 0 ) {[m
[32m+[m			[32mvar a = ix + gridX1 * iy;[m
[32m+[m			[32mvar b = ix + gridX1 * ( iy + 1 );[m
[32m+[m			[32mvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );[m
[32m+[m			[32mvar d = ( ix + 1 ) + gridX1 * iy;[m
 [m
[31m-				return false;[m
[32m+[m			[32m// faces[m
 [m
[31m-			}[m
[32m+[m			[32mindices.push( a, b, d );[m
[32m+[m			[32mindices.push( b, c, d );[m
 [m
 		}[m
 [m
[31m-		return true;[m
[31m-[m
 	}[m
 [m
[31m-} );[m
[32m+[m	[32m// build geometry[m
[32m+[m
[32m+[m	[32mthis.setIndex( indices );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );[m
[32m+[m[32mPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;[m
 [m
 var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";[m
 [m
[36m@@ -14018,13 +14742,13 @@[m [mvar bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float ro[m
 [m
 var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";[m
 [m
[31m-var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";[m
[32m+[m[32mvar clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";[m
 [m
[31m-var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";[m
[32m+[m[32mvar clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";[m
 [m
[31m-var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";[m
[32m+[m[32mvar clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";[m
 [m
[31m-var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";[m
[32m+[m[32mvar clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";[m
 [m
 var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";[m
 [m
[36m@@ -14036,9 +14760,9 @@[m [mvar color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";[m
 [m
 var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";[m
 [m
[31m-var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif";[m
[32m+[m[32mvar cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";[m
 [m
[31m-var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";[m
[32m+[m[32mvar defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";[m
 [m
 var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";[m
 [m
[36m@@ -14050,9 +14774,9 @@[m [mvar emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emi[m
 [m
 var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";[m
 [m
[31m-var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";[m
[32m+[m[32mvar encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";[m
 [m
[31m-var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";[m
[32m+[m[32mvar envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";[m
 [m
 var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";[m
 [m
[36m@@ -14060,7 +14784,7 @@[m [mvar envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t[m
 [m
 var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";[m
 [m
[31m-var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";[m
[32m+[m[32mvar envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";[m
 [m
 var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";[m
 [m
[36m@@ -14070,33 +14794,37 @@[m [mvar fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0[m
 [m
 var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";[m
 [m
[31m-var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif";[m
[32m+[m[32mvar gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";[m
 [m
[31m-var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";[m
[32m+[m[32mvar lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";[m
 [m
 var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";[m
 [m
[31m-var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";[m
[32m+[m[32mvar lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";[m
[32m+[m
[32m+[m[32mvar lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";[m
[32m+[m
[32m+[m[32mvar envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";[m
 [m
[31m-var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";[m
[32m+[m[32mvar lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";[m
 [m
[31m-var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";[m
[32m+[m[32mvar lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";[m
 [m
 var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";[m
 [m
[31m-var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";[m
[32m+[m[32mvar lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";[m
 [m
[31m-var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";[m
[32m+[m[32mvar lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";[m
 [m
 var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";[m
 [m
[31m-var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";[m
[32m+[m[32mvar lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";[m
 [m
[31m-var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";[m
[32m+[m[32mvar lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";[m
 [m
 var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";[m
 [m
[31m-var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif";[m
[32m+[m[32mvar logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";[m
 [m
 var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";[m
 [m
[36m@@ -14108,33 +14836,33 @@[m [mvar map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n[m
 [m
 var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";[m
 [m
[31m-var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif";[m
[32m+[m[32mvar map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";[m
 [m
[31m-var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif";[m
[32m+[m[32mvar map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";[m
 [m
 var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";[m
 [m
 var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";[m
 [m
[31m-var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";[m
[32m+[m[32mvar morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";[m
 [m
[31m-var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";[m
[32m+[m[32mvar morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";[m
 [m
[31m-var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";[m
[32m+[m[32mvar morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";[m
 [m
[31m-var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";[m
[32m+[m[32mvar normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";[m
 [m
[31m-var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";[m
[32m+[m[32mvar normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";[m
 [m
[31m-var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";[m
[32m+[m[32mvar normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";[m
 [m
 var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";[m
 [m
[31m-var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif";[m
[32m+[m[32mvar clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";[m
 [m
[31m-var clearcoat_normalmap_pars_fragment = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";[m
[32m+[m[32mvar clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";[m
 [m
[31m-var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";[m
[32m+[m[32mvar packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";[m
 [m
 var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";[m
 [m
[36m@@ -14148,13 +14876,13 @@[m [mvar roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUG[m
 [m
 var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";[m
 [m
[31m-var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";[m
[32m+[m[32mvar shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";[m
 [m
 var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";[m
 [m
[31m-var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";[m
[32m+[m[32mvar shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";[m
 [m
[31m-var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";[m
[32m+[m[32mvar shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";[m
 [m
 var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";[m
 [m
[36m@@ -14172,17 +14900,17 @@[m [mvar tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = to[m
 [m
 var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";[m
 [m
[31m-var uv_pars_fragment = "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif";[m
[32m+[m[32mvar uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";[m
 [m
[31m-var uv_pars_vertex = "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif";[m
[32m+[m[32mvar uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";[m
 [m
 var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";[m
 [m
 var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";[m
 [m
[31m-var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";[m
[32m+[m[32mvar uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";[m
 [m
[31m-var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";[m
[32m+[m[32mvar uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";[m
 [m
 var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";[m
 [m
[36m@@ -14190,13 +14918,13 @@[m [mvar background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\[m
 [m
 var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";[m
 [m
[31m-var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";[m
[32m+[m[32mvar cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";[m
 [m
 var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";[m
 [m
[31m-var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";[m
[32m+[m[32mvar depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";[m
 [m
[31m-var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";[m
[32m+[m[32mvar depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";[m
 [m
 var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";[m
 [m
[36m@@ -14206,43 +14934,47 @@[m [mvar equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;[m
 [m
 var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";[m
 [m
[31m-var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";[m
[32m+[m[32mvar linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";[m
 [m
[31m-var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";[m
[32m+[m[32mvar linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";[m
 [m
[31m-var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";[m
[32m+[m[32mvar meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
 [m
 var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";[m
 [m
[31m-var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
[32m+[m[32mvar meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
 [m
 var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";[m
 [m
[31m-var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";[m
[32m+[m[32mvar meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
 [m
[31m-var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";[m
[32m+[m[32mvar meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";[m
 [m
[31m-var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
[32m+[m[32mvar meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
[32m+[m
[32m+[m[32mvar meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";[m
[32m+[m
[32m+[m[32mvar meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
 [m
 var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";[m
 [m
[31m-var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
[32m+[m[32mvar meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";[m
 [m
 var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";[m
 [m
 var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";[m
 [m
[31m-var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";[m
[32m+[m[32mvar normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";[m
 [m
[31m-var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";[m
[32m+[m[32mvar points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";[m
 [m
 var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";[m
 [m
[31m-var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}";[m
[32m+[m[32mvar shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";[m
 [m
 var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";[m
 [m
[31m-var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";[m
[32m+[m[32mvar sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";[m
 [m
 var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";[m
 [m
[36m@@ -14288,6 +15020,8 @@[m [mvar ShaderChunk = {[m
 	lightmap_pars_fragment: lightmap_pars_fragment,[m
 	lights_lambert_vertex: lights_lambert_vertex,[m
 	lights_pars_begin: lights_pars_begin,[m
[32m+[m	[32mlights_toon_fragment: lights_toon_fragment,[m
[32m+[m	[32mlights_toon_pars_fragment: lights_toon_pars_fragment,[m
 	lights_phong_fragment: lights_phong_fragment,[m
 	lights_phong_pars_fragment: lights_phong_pars_fragment,[m
 	lights_physical_fragment: lights_physical_fragment,[m
[36m@@ -14313,7 +15047,7 @@[m [mvar ShaderChunk = {[m
 	normalmap_pars_fragment: normalmap_pars_fragment,[m
 	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,[m
 	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,[m
[31m-	clearcoat_normalmap_pars_fragment: clearcoat_normalmap_pars_fragment,[m
[32m+[m	[32mclearcoat_pars_fragment: clearcoat_pars_fragment,[m
 	packing: packing,[m
 	premultiplied_alpha_fragment: premultiplied_alpha_fragment,[m
 	project_vertex: project_vertex,[m
[36m@@ -14359,6 +15093,8 @@[m [mvar ShaderChunk = {[m
 	meshlambert_vert: meshlambert_vert,[m
 	meshmatcap_frag: meshmatcap_frag,[m
 	meshmatcap_vert: meshmatcap_vert,[m
[32m+[m	[32mmeshtoon_frag: meshtoon_frag,[m
[32m+[m	[32mmeshtoon_vert: meshtoon_vert,[m
 	meshphong_frag: meshphong_frag,[m
 	meshphong_vert: meshphong_vert,[m
 	meshphysical_frag: meshphysical_frag,[m
[36m@@ -14373,203 +15109,6 @@[m [mvar ShaderChunk = {[m
 	sprite_vert: sprite_vert[m
 };[m
 [m
[31m-/**[m
[31m- * Uniforms library for shared webgl shaders[m
[31m- */[m
[31m-[m
[31m-var UniformsLib = {[m
[31m-[m
[31m-	common: {[m
[31m-[m
[31m-		diffuse: { value: new Color( 0xeeeeee ) },[m
[31m-		opacity: { value: 1.0 },[m
[31m-[m
[31m-		map: { value: null },[m
[31m-		uvTransform: { value: new Matrix3() },[m
[31m-[m
[31m-		alphaMap: { value: null },[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	specularmap: {[m
[31m-[m
[31m-		specularMap: { value: null },[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	envmap: {[m
[31m-[m
[31m-		envMap: { value: null },[m
[31m-		flipEnvMap: { value: - 1 },[m
[31m-		reflectivity: { value: 1.0 },[m
[31m-		refractionRatio: { value: 0.98 },[m
[31m-		maxMipLevel: { value: 0 }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	aomap: {[m
[31m-[m
[31m-		aoMap: { value: null },[m
[31m-		aoMapIntensity: { value: 1 }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	lightmap: {[m
[31m-[m
[31m-		lightMap: { value: null },[m
[31m-		lightMapIntensity: { value: 1 }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	emissivemap: {[m
[31m-[m
[31m-		emissiveMap: { value: null }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	bumpmap: {[m
[31m-[m
[31m-		bumpMap: { value: null },[m
[31m-		bumpScale: { value: 1 }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	normalmap: {[m
[31m-[m
[31m-		normalMap: { value: null },[m
[31m-		normalScale: { value: new Vector2( 1, 1 ) }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	displacementmap: {[m
[31m-[m
[31m-		displacementMap: { value: null },[m
[31m-		displacementScale: { value: 1 },[m
[31m-		displacementBias: { value: 0 }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	roughnessmap: {[m
[31m-[m
[31m-		roughnessMap: { value: null }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	metalnessmap: {[m
[31m-[m
[31m-		metalnessMap: { value: null }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	gradientmap: {[m
[31m-[m
[31m-		gradientMap: { value: null }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	fog: {[m
[31m-[m
[31m-		fogDensity: { value: 0.00025 },[m
[31m-		fogNear: { value: 1 },[m
[31m-		fogFar: { value: 2000 },[m
[31m-		fogColor: { value: new Color( 0xffffff ) }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	lights: {[m
[31m-[m
[31m-		ambientLightColor: { value: [] },[m
[31m-[m
[31m-		lightProbe: { value: [] },[m
[31m-[m
[31m-		directionalLights: { value: [], properties: {[m
[31m-			direction: {},[m
[31m-			color: {},[m
[31m-[m
[31m-			shadow: {},[m
[31m-			shadowBias: {},[m
[31m-			shadowRadius: {},[m
[31m-			shadowMapSize: {}[m
[31m-		} },[m
[31m-[m
[31m-		directionalShadowMap: { value: [] },[m
[31m-		directionalShadowMatrix: { value: [] },[m
[31m-[m
[31m-		spotLights: { value: [], properties: {[m
[31m-			color: {},[m
[31m-			position: {},[m
[31m-			direction: {},[m
[31m-			distance: {},[m
[31m-			coneCos: {},[m
[31m-			penumbraCos: {},[m
[31m-			decay: {},[m
[31m-[m
[31m-			shadow: {},[m
[31m-			shadowBias: {},[m
[31m-			shadowRadius: {},[m
[31m-			shadowMapSize: {}[m
[31m-		} },[m
[31m-[m
[31m-		spotShadowMap: { value: [] },[m
[31m-		spotShadowMatrix: { value: [] },[m
[31m-[m
[31m-		pointLights: { value: [], properties: {[m
[31m-			color: {},[m
[31m-			position: {},[m
[31m-			decay: {},[m
[31m-			distance: {},[m
[31m-[m
[31m-			shadow: {},[m
[31m-			shadowBias: {},[m
[31m-			shadowRadius: {},[m
[31m-			shadowMapSize: {},[m
[31m-			shadowCameraNear: {},[m
[31m-			shadowCameraFar: {}[m
[31m-		} },[m
[31m-[m
[31m-		pointShadowMap: { value: [] },[m
[31m-		pointShadowMatrix: { value: [] },[m
[31m-[m
[31m-		hemisphereLights: { value: [], properties: {[m
[31m-			direction: {},[m
[31m-			skyColor: {},[m
[31m-			groundColor: {}[m
[31m-		} },[m
[31m-[m
[31m-		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src[m
[31m-		rectAreaLights: { value: [], properties: {[m
[31m-			color: {},[m
[31m-			position: {},[m
[31m-			width: {},[m
[31m-			height: {}[m
[31m-		} }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	points: {[m
[31m-[m
[31m-		diffuse: { value: new Color( 0xeeeeee ) },[m
[31m-		opacity: { value: 1.0 },[m
[31m-		size: { value: 1.0 },[m
[31m-		scale: { value: 1.0 },[m
[31m-		map: { value: null },[m
[31m-		uvTransform: { value: new Matrix3() }[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	sprite: {[m
[31m-[m
[31m-		diffuse: { value: new Color( 0xeeeeee ) },[m
[31m-		opacity: { value: 1.0 },[m
[31m-		center: { value: new Vector2( 0.5, 0.5 ) },[m
[31m-		rotation: { value: 0.0 },[m
[31m-		map: { value: null },[m
[31m-		uvTransform: { value: new Matrix3() }[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-};[m
[31m-[m
 /**[m
  * @author alteredq / http://alteredqualia.com/[m
  * @author mrdoob / http://mrdoob.com/[m
[36m@@ -14627,7 +15166,6 @@[m [mvar ShaderLib = {[m
 			UniformsLib.bumpmap,[m
 			UniformsLib.normalmap,[m
 			UniformsLib.displacementmap,[m
[31m-			UniformsLib.gradientmap,[m
 			UniformsLib.fog,[m
 			UniformsLib.lights,[m
 			{[m
[36m@@ -14670,6 +15208,32 @@[m [mvar ShaderLib = {[m
 [m
 	},[m
 [m
[32m+[m	[32mtoon: {[m
[32m+[m
[32m+[m		[32muniforms: mergeUniforms( [[m
[32m+[m			[32mUniformsLib.common,[m
[32m+[m			[32mUniformsLib.specularmap,[m
[32m+[m			[32mUniformsLib.aomap,[m
[32m+[m			[32mUniformsLib.lightmap,[m
[32m+[m			[32mUniformsLib.emissivemap,[m
[32m+[m			[32mUniformsLib.bumpmap,[m
[32m+[m			[32mUniformsLib.normalmap,[m
[32m+[m			[32mUniformsLib.displacementmap,[m
[32m+[m			[32mUniformsLib.gradientmap,[m
[32m+[m			[32mUniformsLib.fog,[m
[32m+[m			[32mUniformsLib.lights,[m
[32m+[m			[32m{[m
[32m+[m				[32memissive: { value: new Color( 0x000000 ) },[m
[32m+[m				[32mspecular: { value: new Color( 0x111111 ) },[m
[32m+[m				[32mshininess: { value: 30 }[m
[32m+[m			[32m}[m
[32m+[m		[32m] ),[m
[32m+[m
[32m+[m		[32mvertexShader: ShaderChunk.meshtoon_vert,[m
[32m+[m		[32mfragmentShader: ShaderChunk.meshtoon_frag[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
 	matcap: {[m
 [m
 		uniforms: mergeUniforms( [[m
[36m@@ -14775,11 +15339,12 @@[m [mvar ShaderLib = {[m
 [m
 	cube: {[m
 [m
[31m-		uniforms: {[m
[31m-			tCube: { value: null },[m
[31m-			tFlip: { value: - 1 },[m
[31m-			opacity: { value: 1.0 }[m
[31m-		},[m
[32m+[m		[32muniforms: mergeUniforms( [[m
[32m+[m			[32mUniformsLib.envmap,[m
[32m+[m			[32m{[m
[32m+[m				[32mopacity: { value: 1.0 }[m
[32m+[m			[32m}[m
[32m+[m		[32m] ),[m
 [m
 		vertexShader: ShaderChunk.cube_vert,[m
 		fragmentShader: ShaderChunk.cube_frag[m
[36m@@ -14837,12 +15402,14 @@[m [mShaderLib.physical = {[m
 	uniforms: mergeUniforms( [[m
 		ShaderLib.standard.uniforms,[m
 		{[m
[31m-			transparency: { value: 0 },[m
 			clearcoat: { value: 0 },[m
[32m+[m			[32mclearcoatMap: { value: null },[m
 			clearcoatRoughness: { value: 0 },[m
[31m-			sheen: { value: new Color( 0x000000 ) },[m
[32m+[m			[32mclearcoatRoughnessMap: { value: null },[m
 			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },[m
 			clearcoatNormalMap: { value: null },[m
[32m+[m			[32msheen: { value: new Color( 0x000000 ) },[m
[32m+[m			[32mtransparency: { value: 0 },[m
 		}[m
 	] ),[m
 [m
[36m@@ -14851,334 +15418,6 @@[m [mShaderLib.physical = {[m
 [m
 };[m
 [m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- */[m
[31m-[m
[31m-function WebGLAnimation() {[m
[31m-[m
[31m-	var context = null;[m
[31m-	var isAnimating = false;[m
[31m-	var animationLoop = null;[m
[31m-[m
[31m-	function onAnimationFrame( time, frame ) {[m
[31m-[m
[31m-		if ( isAnimating === false ) return;[m
[31m-[m
[31m-		animationLoop( time, frame );[m
[31m-[m
[31m-		context.requestAnimationFrame( onAnimationFrame );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	return {[m
[31m-[m
[31m-		start: function () {[m
[31m-[m
[31m-			if ( isAnimating === true ) return;[m
[31m-			if ( animationLoop === null ) return;[m
[31m-[m
[31m-			context.requestAnimationFrame( onAnimationFrame );[m
[31m-[m
[31m-			isAnimating = true;[m
[31m-[m
[31m-		},[m
[31m-[m
[31m-		stop: function () {[m
[31m-[m
[31m-			isAnimating = false;[m
[31m-[m
[31m-		},[m
[31m-[m
[31m-		setAnimationLoop: function ( callback ) {[m
[31m-[m
[31m-			animationLoop = callback;[m
[31m-[m
[31m-		},[m
[31m-[m
[31m-		setContext: function ( value ) {[m
[31m-[m
[31m-			context = value;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	};[m
[31m-[m
[31m-}[m
[31m-[m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- */[m
[31m-[m
[31m-function WebGLAttributes( gl ) {[m
[31m-[m
[31m-	var buffers = new WeakMap();[m
[31m-[m
[31m-	function createBuffer( attribute, bufferType ) {[m
[31m-[m
[31m-		var array = attribute.array;[m
[31m-		var usage = attribute.dynamic ? 35048 : 35044;[m
[31m-[m
[31m-		var buffer = gl.createBuffer();[m
[31m-[m
[31m-		gl.bindBuffer( bufferType, buffer );[m
[31m-		gl.bufferData( bufferType, array, usage );[m
[31m-[m
[31m-		attribute.onUploadCallback();[m
[31m-[m
[31m-		var type = 5126;[m
[31m-[m
[31m-		if ( array instanceof Float32Array ) {[m
[31m-[m
[31m-			type = 5126;[m
[31m-[m
[31m-		} else if ( array instanceof Float64Array ) {[m
[31m-[m
[31m-			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );[m
[31m-[m
[31m-		} else if ( array instanceof Uint16Array ) {[m
[31m-[m
[31m-			type = 5123;[m
[31m-[m
[31m-		} else if ( array instanceof Int16Array ) {[m
[31m-[m
[31m-			type = 5122;[m
[31m-[m
[31m-		} else if ( array instanceof Uint32Array ) {[m
[31m-[m
[31m-			type = 5125;[m
[31m-[m
[31m-		} else if ( array instanceof Int32Array ) {[m
[31m-[m
[31m-			type = 5124;[m
[31m-[m
[31m-		} else if ( array instanceof Int8Array ) {[m
[31m-[m
[31m-			type = 5120;[m
[31m-[m
[31m-		} else if ( array instanceof Uint8Array ) {[m
[31m-[m
[31m-			type = 5121;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		return {[m
[31m-			buffer: buffer,[m
[31m-			type: type,[m
[31m-			bytesPerElement: array.BYTES_PER_ELEMENT,[m
[31m-			version: attribute.version[m
[31m-		};[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function updateBuffer( buffer, attribute, bufferType ) {[m
[31m-[m
[31m-		var array = attribute.array;[m
[31m-		var updateRange = attribute.updateRange;[m
[31m-[m
[31m-		gl.bindBuffer( bufferType, buffer );[m
[31m-[m
[31m-		if ( attribute.dynamic === false ) {[m
[31m-[m
[31m-			gl.bufferData( bufferType, array, 35044 );[m
[31m-[m
[31m-		} else if ( updateRange.count === - 1 ) {[m
[31m-[m
[31m-			// Not using update ranges[m
[31m-[m
[31m-			gl.bufferSubData( bufferType, 0, array );[m
[31m-[m
[31m-		} else if ( updateRange.count === 0 ) {[m
[31m-[m
[31m-			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );[m
[31m-[m
[31m-		} else {[m
[31m-[m
[31m-			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,[m
[31m-				array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );[m
[31m-[m
[31m-			updateRange.count = - 1; // reset range[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	function get( attribute ) {[m
[31m-[m
[31m-		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;[m
[31m-[m
[31m-		return buffers.get( attribute );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function remove( attribute ) {[m
[31m-[m
[31m-		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;[m
[31m-[m
[31m-		var data = buffers.get( attribute );[m
[31m-[m
[31m-		if ( data ) {[m
[31m-[m
[31m-			gl.deleteBuffer( data.buffer );[m
[31m-[m
[31m-			buffers.delete( attribute );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function update( attribute, bufferType ) {[m
[31m-[m
[31m-		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;[m
[31m-[m
[31m-		var data = buffers.get( attribute );[m
[31m-[m
[31m-		if ( data === undefined ) {[m
[31m-[m
[31m-			buffers.set( attribute, createBuffer( attribute, bufferType ) );[m
[31m-[m
[31m-		} else if ( data.version < attribute.version ) {[m
[31m-[m
[31m-			updateBuffer( data.buffer, attribute, bufferType );[m
[31m-[m
[31m-			data.version = attribute.version;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	return {[m
[31m-[m
[31m-		get: get,[m
[31m-		remove: remove,[m
[31m-		update: update[m
[31m-[m
[31m-	};[m
[31m-[m
[31m-}[m
[31m-[m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- * @author Mugen87 / https://github.com/Mugen87[m
[31m- */[m
[31m-[m
[31m-// PlaneGeometry[m
[31m-[m
[31m-function PlaneGeometry( width, height, widthSegments, heightSegments ) {[m
[31m-[m
[31m-	Geometry.call( this );[m
[31m-[m
[31m-	this.type = 'PlaneGeometry';[m
[31m-[m
[31m-	this.parameters = {[m
[31m-		width: width,[m
[31m-		height: height,[m
[31m-		widthSegments: widthSegments,[m
[31m-		heightSegments: heightSegments[m
[31m-	};[m
[31m-[m
[31m-	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );[m
[31m-	this.mergeVertices();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-PlaneGeometry.prototype = Object.create( Geometry.prototype );[m
[31m-PlaneGeometry.prototype.constructor = PlaneGeometry;[m
[31m-[m
[31m-// PlaneBufferGeometry[m
[31m-[m
[31m-function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {[m
[31m-[m
[31m-	BufferGeometry.call( this );[m
[31m-[m
[31m-	this.type = 'PlaneBufferGeometry';[m
[31m-[m
[31m-	this.parameters = {[m
[31m-		width: width,[m
[31m-		height: height,[m
[31m-		widthSegments: widthSegments,[m
[31m-		heightSegments: heightSegments[m
[31m-	};[m
[31m-[m
[31m-	width = width || 1;[m
[31m-	height = height || 1;[m
[31m-[m
[31m-	var width_half = width / 2;[m
[31m-	var height_half = height / 2;[m
[31m-[m
[31m-	var gridX = Math.floor( widthSegments ) || 1;[m
[31m-	var gridY = Math.floor( heightSegments ) || 1;[m
[31m-[m
[31m-	var gridX1 = gridX + 1;[m
[31m-	var gridY1 = gridY + 1;[m
[31m-[m
[31m-	var segment_width = width / gridX;[m
[31m-	var segment_height = height / gridY;[m
[31m-[m
[31m-	var ix, iy;[m
[31m-[m
[31m-	// buffers[m
[31m-[m
[31m-	var indices = [];[m
[31m-	var vertices = [];[m
[31m-	var normals = [];[m
[31m-	var uvs = [];[m
[31m-[m
[31m-	// generate vertices, normals and uvs[m
[31m-[m
[31m-	for ( iy = 0; iy < gridY1; iy ++ ) {[m
[31m-[m
[31m-		var y = iy * segment_height - height_half;[m
[31m-[m
[31m-		for ( ix = 0; ix < gridX1; ix ++ ) {[m
[31m-[m
[31m-			var x = ix * segment_width - width_half;[m
[31m-[m
[31m-			vertices.push( x, - y, 0 );[m
[31m-[m
[31m-			normals.push( 0, 0, 1 );[m
[31m-[m
[31m-			uvs.push( ix / gridX );[m
[31m-			uvs.push( 1 - ( iy / gridY ) );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	// indices[m
[31m-[m
[31m-	for ( iy = 0; iy < gridY; iy ++ ) {[m
[31m-[m
[31m-		for ( ix = 0; ix < gridX; ix ++ ) {[m
[31m-[m
[31m-			var a = ix + gridX1 * iy;[m
[31m-			var b = ix + gridX1 * ( iy + 1 );[m
[31m-			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );[m
[31m-			var d = ( ix + 1 ) + gridX1 * iy;[m
[31m-[m
[31m-			// faces[m
[31m-[m
[31m-			indices.push( a, b, d );[m
[31m-			indices.push( b, c, d );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	// build geometry[m
[31m-[m
[31m-	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[31m-[m
[31m-}[m
[31m-[m
[31m-PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );[m
[31m-PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;[m
[31m-[m
 /**[m
  * @author mrdoob / http://mrdoob.com/[m
  */[m
[36m@@ -15190,10 +15429,10 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 [m
 	var planeMesh;[m
 	var boxMesh;[m
[31m-	// Store the current background texture and its `version`[m
[31m-	// so we can recompile the material accordingly.[m
[32m+[m
 	var currentBackground = null;[m
 	var currentBackgroundVersion = 0;[m
[32m+[m	[32mvar currentTonemapping = null;[m
 [m
 	function render( renderList, scene, camera, forceClear ) {[m
 [m
[36m@@ -15202,8 +15441,8 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 		// Ignore background in AR[m
 		// TODO: Reconsider this.[m
 [m
[31m-		var vr = renderer.vr;[m
[31m-		var session = vr.getSession && vr.getSession();[m
[32m+[m		[32mvar xr = renderer.xr;[m
[32m+[m		[32mvar session = xr.getSession && xr.getSession();[m
 [m
 		if ( session && session.environmentBlendMode === 'additive' ) {[m
 [m
[36m@@ -15214,15 +15453,11 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 		if ( background === null ) {[m
 [m
 			setClear( clearColor, clearAlpha );[m
[31m-			currentBackground = null;[m
[31m-			currentBackgroundVersion = 0;[m
 [m
 		} else if ( background && background.isColor ) {[m
 [m
 			setClear( background, 1 );[m
 			forceClear = true;[m
[31m-			currentBackground = null;[m
[31m-			currentBackgroundVersion = 0;[m
 [m
 		}[m
 [m
[36m@@ -15232,7 +15467,7 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 [m
 		}[m
 [m
[31m-		if ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {[m
[32m+[m		[32mif ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {[m
 [m
 			if ( boxMesh === undefined ) {[m
 [m
[36m@@ -15250,8 +15485,8 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 					} )[m
 				);[m
 [m
[31m-				boxMesh.geometry.removeAttribute( 'normal' );[m
[31m-				boxMesh.geometry.removeAttribute( 'uv' );[m
[32m+[m				[32mboxMesh.geometry.deleteAttribute( 'normal' );[m
[32m+[m				[32mboxMesh.geometry.deleteAttribute( 'uv' );[m
 [m
 				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {[m
 [m
[36m@@ -15260,11 +15495,11 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 				};[m
 [m
 				// enable code injection for non-built-in material[m
[31m-				Object.defineProperty( boxMesh.material, 'map', {[m
[32m+[m				[32mObject.defineProperty( boxMesh.material, 'envMap', {[m
 [m
 					get: function () {[m
 [m
[31m-						return this.uniforms.tCube.value;[m
[32m+[m						[32mreturn this.uniforms.envMap.value;[m
 [m
 					}[m
 [m
[36m@@ -15274,17 +15509,20 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 [m
 			}[m
 [m
[31m-			var texture = background.isWebGLRenderTargetCube ? background.texture : background;[m
[31m-			boxMesh.material.uniforms.tCube.value = texture;[m
[31m-			boxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;[m
[32m+[m			[32mvar texture = background.isWebGLCubeRenderTarget ? background.texture : background;[m
[32m+[m
[32m+[m			[32mboxMesh.material.uniforms.envMap.value = texture;[m
[32m+[m			[32mboxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? - 1 : 1;[m
 [m
 			if ( currentBackground !== background ||[m
[31m-			     currentBackgroundVersion !== texture.version ) {[m
[32m+[m				[32mcurrentBackgroundVersion !== texture.version ||[m
[32m+[m				[32mcurrentTonemapping !== renderer.toneMapping ) {[m
 [m
 				boxMesh.material.needsUpdate = true;[m
 [m
 				currentBackground = background;[m
 				currentBackgroundVersion = texture.version;[m
[32m+[m				[32mcurrentTonemapping = renderer.toneMapping;[m
 [m
 			}[m
 [m
[36m@@ -15309,7 +15547,7 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 					} )[m
 				);[m
 [m
[31m-				planeMesh.geometry.removeAttribute( 'normal' );[m
[32m+[m				[32mplaneMesh.geometry.deleteAttribute( 'normal' );[m
 [m
 				// enable code injection for non-built-in material[m
 				Object.defineProperty( planeMesh.material, 'map', {[m
[36m@@ -15337,12 +15575,14 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );[m
 [m
 			if ( currentBackground !== background ||[m
[31m-				   currentBackgroundVersion !== background.version ) {[m
[32m+[m				[32mcurrentBackgroundVersion !== background.version ||[m
[32m+[m				[32mcurrentTonemapping !== renderer.toneMapping ) {[m
 [m
 				planeMesh.material.needsUpdate = true;[m
 [m
 				currentBackground = background;[m
 				currentBackgroundVersion = background.version;[m
[32m+[m				[32mcurrentTonemapping = renderer.toneMapping;[m
 [m
 			}[m
 [m
[36m@@ -15397,6 +15637,8 @@[m [mfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {[m
 [m
 function WebGLBufferRenderer( gl, extensions, info, capabilities ) {[m
 [m
[32m+[m	[32mvar isWebGL2 = capabilities.isWebGL2;[m
[32m+[m
 	var mode;[m
 [m
 	function setMode( value ) {[m
[36m@@ -15419,7 +15661,7 @@[m [mfunction WebGLBufferRenderer( gl, extensions, info, capabilities ) {[m
 [m
 		var extension, methodName;[m
 [m
[31m-		if ( capabilities.isWebGL2 ) {[m
[32m+[m		[32mif ( isWebGL2 ) {[m
 [m
 			extension = gl;[m
 			methodName = 'drawArraysInstanced';[m
[36m@@ -15485,7 +15727,7 @@[m [mfunction WebGLCapabilities( gl, extensions, parameters ) {[m
 		if ( precision === 'highp' ) {[m
 [m
 			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&[m
[31m-			     gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {[m
[32m+[m				[32mgl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {[m
 [m
 				return 'highp';[m
 [m
[36m@@ -15498,7 +15740,7 @@[m [mfunction WebGLCapabilities( gl, extensions, parameters ) {[m
 		if ( precision === 'mediump' ) {[m
 [m
 			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&[m
[31m-			     gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {[m
[32m+[m				[32mgl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {[m
 [m
 				return 'mediump';[m
 [m
[36m@@ -15510,7 +15752,10 @@[m [mfunction WebGLCapabilities( gl, extensions, parameters ) {[m
 [m
 	}[m
 [m
[31m-	var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;[m
[32m+[m	[32m/* eslint-disable no-undef */[m
[32m+[m	[32mvar isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||[m
[32m+[m		[32m( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );[m
[32m+[m	[32m/* eslint-enable no-undef */[m
 [m
 	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';[m
 	var maxPrecision = getMaxPrecision( precision );[m
[36m@@ -15722,6 +15967,7 @@[m [mfunction WebGLClipping() {[m
 		}[m
 [m
 		scope.numPlanes = nPlanes;[m
[32m+[m		[32mscope.numIntersection = 0;[m
 [m
 		return dstArray;[m
 [m
[36m@@ -16004,6 +16250,8 @@[m [mfunction WebGLGeometries( gl, attributes, info ) {[m
 [m
 function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {[m
 [m
[32m+[m	[32mvar isWebGL2 = capabilities.isWebGL2;[m
[32m+[m
 	var mode;[m
 [m
 	function setMode( value ) {[m
[36m@@ -16035,7 +16283,7 @@[m [mfunction WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {[m
 [m
 		var extension, methodName;[m
 [m
[31m-		if ( capabilities.isWebGL2 ) {[m
[32m+[m		[32mif ( isWebGL2 ) {[m
 [m
 			extension = gl;[m
 			methodName = 'drawElementsInstanced';[m
[36m@@ -16100,11 +16348,6 @@[m [mfunction WebGLInfo( gl ) {[m
 				render.triangles += instanceCount * ( count / 3 );[m
 				break;[m
 [m
[31m-			case 5:[m
[31m-			case 6:[m
[31m-				render.triangles += instanceCount * ( count - 2 );[m
[31m-				break;[m
[31m-[m
 			case 1:[m
 				render.lines += instanceCount * ( count / 2 );[m
 				break;[m
[36m@@ -16169,7 +16412,10 @@[m [mfunction WebGLMorphtargets( gl ) {[m
 [m
 		var objectInfluences = object.morphTargetInfluences;[m
 [m
[31m-		var length = objectInfluences.length;[m
[32m+[m		[32m// When object doesn't have morph target influences defined, we treat it as a 0-length array[m
[32m+[m		[32m// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences[m
[32m+[m
[32m+[m		[32mvar length = objectInfluences === undefined ? 0 : objectInfluences.length;[m
 [m
 		var influences = influencesList[ geometry.id ];[m
 [m
[36m@@ -16200,8 +16446,8 @@[m [mfunction WebGLMorphtargets( gl ) {[m
 [m
 			if ( influence[ 1 ] !== 0 ) {[m
 [m
[31m-				if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );[m
[31m-				if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );[m
[32m+[m				[32mif ( morphTargets ) geometry.deleteAttribute( 'morphTarget' + i );[m
[32m+[m				[32mif ( morphNormals ) geometry.deleteAttribute( 'morphNormal' + i );[m
 [m
 			}[m
 [m
[36m@@ -16222,6 +16468,8 @@[m [mfunction WebGLMorphtargets( gl ) {[m
 [m
 		// Add morphAttributes[m
 [m
[32m+[m		[32mvar morphInfluencesSum = 0;[m
[32m+[m
 		for ( var i = 0; i < 8; i ++ ) {[m
 [m
 			var influence = influences[ i ];[m
[36m@@ -16233,10 +16481,11 @@[m [mfunction WebGLMorphtargets( gl ) {[m
 [m
 				if ( value ) {[m
 [m
[31m-					if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );[m
[31m-					if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );[m
[32m+[m					[32mif ( morphTargets ) geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );[m
[32m+[m					[32mif ( morphNormals ) geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );[m
 [m
 					morphInfluences[ i ] = value;[m
[32m+[m					[32mmorphInfluencesSum += value;[m
 					continue;[m
 [m
 				}[m
[36m@@ -16247,6 +16496,12 @@[m [mfunction WebGLMorphtargets( gl ) {[m
 [m
 		}[m
 [m
[32m+[m		[32m// GLSL shader uses formula baseinfluence * base + sum(target * influence)[m
[32m+[m		[32m// This allows us to switch between absolute morphs and relative morphs without changing shader code[m
[32m+[m		[32m// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)[m
[32m+[m		[32mvar morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;[m
[32m+[m
[32m+[m		[32mprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );[m
 		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );[m
 [m
 	}[m
[36m@@ -16265,7 +16520,7 @@[m [mfunction WebGLMorphtargets( gl ) {[m
 [m
 function WebGLObjects( gl, geometries, attributes, info ) {[m
 [m
[31m-	var updateList = {};[m
[32m+[m	[32mvar updateMap = new WeakMap();[m
 [m
 	function update( object ) {[m
 [m
[36m@@ -16276,7 +16531,7 @@[m [mfunction WebGLObjects( gl, geometries, attributes, info ) {[m
 [m
 		// Update once per frame[m
 [m
[31m-		if ( updateList[ buffergeometry.id ] !== frame ) {[m
[32m+[m		[32mif ( updateMap.get( buffergeometry ) !== frame ) {[m
 [m
 			if ( geometry.isGeometry ) {[m
 [m
[36m@@ -16286,7 +16541,7 @@[m [mfunction WebGLObjects( gl, geometries, attributes, info ) {[m
 [m
 			geometries.update( buffergeometry );[m
 [m
[31m-			updateList[ buffergeometry.id ] = frame;[m
[32m+[m			[32mupdateMap.set( buffergeometry, frame );[m
 [m
 		}[m
 [m
[36m@@ -16302,7 +16557,7 @@[m [mfunction WebGLObjects( gl, geometries, attributes, info ) {[m
 [m
 	function dispose() {[m
 [m
[31m-		updateList = {};[m
[32m+[m		[32mupdateMap = new WeakMap();[m
 [m
 	}[m
 [m
[36m@@ -16875,6 +17130,20 @@[m [mfunction setValueV4i( gl, v ) {[m
 [m
 }[m
 [m
[32m+[m[32m// uint[m
[32m+[m
[32m+[m[32mfunction setValueV1ui( gl, v ) {[m
[32m+[m
[32m+[m	[32mvar cache = this.cache;[m
[32m+[m
[32m+[m	[32mif ( cache[ 0 ] === v ) return;[m
[32m+[m
[32m+[m	[32mgl.uniform1ui( this.addr, v );[m
[32m+[m
[32m+[m	[32mcache[ 0 ] = v;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
 // Helper to pick the right setter for the singular case[m
 [m
 function getSingularSetter( type ) {[m
[36m@@ -16890,16 +17159,37 @@[m [mfunction getSingularSetter( type ) {[m
 		case 0x8b5b: return setValueM3; // _MAT3[m
 		case 0x8b5c: return setValueM4; // _MAT4[m
 [m
[31m-		case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES[m
[31m-		case 0x8b5f: return setValueT3D1; // SAMPLER_3D[m
[31m-		case 0x8b60: return setValueT6; // SAMPLER_CUBE[m
[31m-		case 0x8DC1: return setValueT2DArray1; // SAMPLER_2D_ARRAY[m
[31m-[m
 		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL[m
 		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2[m
 		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3[m
 		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4[m
 [m
[32m+[m		[32mcase 0x1405: return setValueV1ui; // UINT[m
[32m+[m
[32m+[m		[32mcase 0x8b5e: // SAMPLER_2D[m
[32m+[m		[32mcase 0x8d66: // SAMPLER_EXTERNAL_OES[m
[32m+[m		[32mcase 0x8dca: // INT_SAMPLER_2D[m
[32m+[m		[32mcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D[m
[32m+[m		[32mcase 0x8b62: // SAMPLER_2D_SHADOW[m
[32m+[m			[32mreturn setValueT1;[m
[32m+[m
[32m+[m		[32mcase 0x8b5f: // SAMPLER_3D[m
[32m+[m		[32mcase 0x8dcb: // INT_SAMPLER_3D[m
[32m+[m		[32mcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D[m
[32m+[m			[32mreturn setValueT3D1;[m
[32m+[m
[32m+[m		[32mcase 0x8b60: // SAMPLER_CUBE[m
[32m+[m		[32mcase 0x8dcc: // INT_SAMPLER_CUBE[m
[32m+[m		[32mcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE[m
[32m+[m		[32mcase 0x8dc5: // SAMPLER_CUBE_SHADOW[m
[32m+[m			[32mreturn setValueT6;[m
[32m+[m
[32m+[m		[32mcase 0x8dc1: // SAMPLER_2D_ARRAY[m
[32m+[m		[32mcase 0x8dcf: // INT_SAMPLER_2D_ARRAY[m
[32m+[m		[32mcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY[m
[32m+[m		[32mcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW[m
[32m+[m			[32mreturn setValueT2DArray1;[m
[32m+[m
 	}[m
 [m
 }[m
[36m@@ -17038,14 +17328,24 @@[m [mfunction getPureArraySetter( type ) {[m
 		case 0x8b5b: return setValueM3Array; // _MAT3[m
 		case 0x8b5c: return setValueM4Array; // _MAT4[m
 [m
[31m-		case 0x8b5e: return setValueT1Array; // SAMPLER_2D[m
[31m-		case 0x8b60: return setValueT6Array; // SAMPLER_CUBE[m
[31m-[m
 		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL[m
 		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2[m
 		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3[m
 		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4[m
 [m
[32m+[m		[32mcase 0x8b5e: // SAMPLER_2D[m
[32m+[m		[32mcase 0x8d66: // SAMPLER_EXTERNAL_OES[m
[32m+[m		[32mcase 0x8dca: // INT_SAMPLER_2D[m
[32m+[m		[32mcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D[m
[32m+[m		[32mcase 0x8b62: // SAMPLER_2D_SHADOW[m
[32m+[m			[32mreturn setValueT1Array;[m
[32m+[m
[32m+[m		[32mcase 0x8b60: // SAMPLER_CUBE[m
[32m+[m		[32mcase 0x8dcc: // INT_SAMPLER_CUBE[m
[32m+[m		[32mcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE[m
[32m+[m		[32mcase 0x8dc5: // SAMPLER_CUBE_SHADOW[m
[32m+[m			[32mreturn setValueT6Array;[m
[32m+[m
 	}[m
 [m
 }[m
[36m@@ -17382,15 +17682,13 @@[m [mfunction getToneMappingFunction( functionName, toneMapping ) {[m
 [m
 }[m
 [m
[31m-function generateExtensions( extensions, parameters, rendererExtensions ) {[m
[31m-[m
[31m-	extensions = extensions || {};[m
[32m+[m[32mfunction generateExtensions( parameters ) {[m
 [m
 	var chunks = [[m
[31m-		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',[m
[31m-		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',[m
[31m-		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',[m
[31m-		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''[m
[32m+[m		[32m( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',[m
[32m+[m		[32m( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',[m
[32m+[m		[32m( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',[m
[32m+[m		[32m( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''[m
 	];[m
 [m
 	return chunks.filter( filterEmptyLine ).join( '\n' );[m
[36m@@ -17490,11 +17788,21 @@[m [mfunction includeReplacer( match, include ) {[m
 [m
 // Unroll Loops[m
 [m
[31m-var loopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;[m
[32m+[m[32mvar deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;[m
[32m+[m[32mvar unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;[m
 [m
 function unrollLoops( string ) {[m
 [m
[31m-	return string.replace( loopPattern, loopReplacer );[m
[32m+[m	[32mreturn string[m
[32m+[m		[32m.replace( unrollLoopPattern, loopReplacer )[m
[32m+[m		[32m.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction deprecatedLoopReplacer( match, start, end, snippet ) {[m
[32m+[m
[32m+[m	[32mconsole.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );[m
[32m+[m	[32mreturn loopReplacer( match, start, end, snippet );[m
 [m
 }[m
 [m
[36m@@ -17560,13 +17868,13 @@[m [mfunction generateShadowMapTypeDefine( parameters ) {[m
 [m
 }[m
 [m
[31m-function generateEnvMapTypeDefine( parameters, material ) {[m
[32m+[m[32mfunction generateEnvMapTypeDefine( parameters ) {[m
 [m
 	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';[m
 [m
 	if ( parameters.envMap ) {[m
 [m
[31m-		switch ( material.envMap.mapping ) {[m
[32m+[m		[32mswitch ( parameters.envMapMode ) {[m
 [m
 			case CubeReflectionMapping:[m
 			case CubeRefractionMapping:[m
[36m@@ -17595,13 +17903,13 @@[m [mfunction generateEnvMapTypeDefine( parameters, material ) {[m
 [m
 }[m
 [m
[31m-function generateEnvMapModeDefine( parameters, material ) {[m
[32m+[m[32mfunction generateEnvMapModeDefine( parameters ) {[m
 [m
 	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';[m
 [m
 	if ( parameters.envMap ) {[m
 [m
[31m-		switch ( material.envMap.mapping ) {[m
[32m+[m		[32mswitch ( parameters.envMapMode ) {[m
 [m
 			case CubeRefractionMapping:[m
 			case EquirectangularRefractionMapping:[m
[36m@@ -17616,13 +17924,13 @@[m [mfunction generateEnvMapModeDefine( parameters, material ) {[m
 [m
 }[m
 [m
[31m-function generateEnvMapBlendingDefine( parameters, material ) {[m
[32m+[m[32mfunction generateEnvMapBlendingDefine( parameters ) {[m
 [m
[31m-	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';[m
[32m+[m	[32mvar envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';[m
 [m
 	if ( parameters.envMap ) {[m
 [m
[31m-		switch ( material.combine ) {[m
[32m+[m		[32mswitch ( parameters.combine ) {[m
 [m
 			case MultiplyOperation:[m
 				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';[m
[36m@@ -17644,23 +17952,23 @@[m [mfunction generateEnvMapBlendingDefine( parameters, material ) {[m
 [m
 }[m
 [m
[31m-function WebGLProgram( renderer, extensions, code, material, shader, parameters ) {[m
[32m+[m[32mfunction WebGLProgram( renderer, cacheKey, parameters ) {[m
 [m
 	var gl = renderer.getContext();[m
 [m
[31m-	var defines = material.defines;[m
[32m+[m	[32mvar defines = parameters.defines;[m
 [m
[31m-	var vertexShader = shader.vertexShader;[m
[31m-	var fragmentShader = shader.fragmentShader;[m
[32m+[m	[32mvar vertexShader = parameters.vertexShader;[m
[32m+[m	[32mvar fragmentShader = parameters.fragmentShader;[m
 	var shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );[m
[31m-	var envMapTypeDefine = generateEnvMapTypeDefine( parameters, material );[m
[31m-	var envMapModeDefine = generateEnvMapModeDefine( parameters, material );[m
[31m-	var envMapBlendingDefine = generateEnvMapBlendingDefine( parameters, material );[m
[32m+[m	[32mvar envMapTypeDefine = generateEnvMapTypeDefine( parameters );[m
[32m+[m	[32mvar envMapModeDefine = generateEnvMapModeDefine( parameters );[m
[32m+[m	[32mvar envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );[m
 [m
 [m
 	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;[m
 [m
[31m-	var customExtensions = parameters.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );[m
[32m+[m	[32mvar customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );[m
 [m
 	var customDefines = generateDefines( defines );[m
 [m
[36m@@ -17668,10 +17976,7 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 [m
 	var prefixVertex, prefixFragment;[m
 [m
[31m-	var renderTarget = renderer.getRenderTarget();[m
[31m-	var numMultiviewViews = renderTarget && renderTarget.isWebGLMultiviewRenderTarget ? renderTarget.numViews : 0;[m
[31m-[m
[31m-	if ( material.isRawShaderMaterial ) {[m
[32m+[m	[32mif ( parameters.isRawShaderMaterial ) {[m
 [m
 		prefixVertex = [[m
 [m
[36m@@ -17704,7 +18009,7 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 [m
 			generatePrecision( parameters ),[m
 [m
[31m-			'#define SHADER_NAME ' + shader.name,[m
[32m+[m			[32m'#define SHADER_NAME ' + parameters.shaderName,[m
 [m
 			customDefines,[m
 [m
[36m@@ -17728,6 +18033,8 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',[m
 			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',[m
 [m
[32m+[m			[32mparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',[m
[32m+[m			[32mparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',[m
 			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',[m
 			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',[m
 			parameters.specularMap ? '#define USE_SPECULARMAP' : '',[m
[36m@@ -17738,6 +18045,7 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			parameters.vertexTangents ? '#define USE_TANGENT' : '',[m
 			parameters.vertexColors ? '#define USE_COLOR' : '',[m
 			parameters.vertexUvs ? '#define USE_UV' : '',[m
[32m+[m			[32mparameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',[m
 [m
 			parameters.flatShading ? '#define FLAT_SHADED' : '',[m
 [m
[36m@@ -17755,7 +18063,7 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',[m
 [m
 			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',[m
[31m-			parameters.logarithmicDepthBuffer && ( parameters.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',[m
[32m+[m			[32m( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',[m
 [m
 			'uniform mat4 modelMatrix;',[m
 			'uniform mat4 modelViewMatrix;',[m
[36m@@ -17763,6 +18071,7 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			'uniform mat4 viewMatrix;',[m
 			'uniform mat3 normalMatrix;',[m
 			'uniform vec3 cameraPosition;',[m
[32m+[m			[32m'uniform bool isOrthographic;',[m
 [m
 			'#ifdef USE_INSTANCING',[m
 [m
[36m@@ -17828,7 +18137,7 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 [m
 			generatePrecision( parameters ),[m
 [m
[31m-			'#define SHADER_NAME ' + shader.name,[m
[32m+[m			[32m'#define SHADER_NAME ' + parameters.shaderName,[m
 [m
 			customDefines,[m
 [m
[36m@@ -17852,6 +18161,8 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			parameters.normalMap ? '#define USE_NORMALMAP' : '',[m
 			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',[m
 			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',[m
[32m+[m			[32mparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',[m
[32m+[m			[32mparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',[m
 			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',[m
 			parameters.specularMap ? '#define USE_SPECULARMAP' : '',[m
 			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',[m
[36m@@ -17863,6 +18174,7 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			parameters.vertexTangents ? '#define USE_TANGENT' : '',[m
 			parameters.vertexColors ? '#define USE_COLOR' : '',[m
 			parameters.vertexUvs ? '#define USE_UV' : '',[m
[32m+[m			[32mparameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',[m
 [m
 			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',[m
 [m
[36m@@ -17879,12 +18191,13 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',[m
 [m
 			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',[m
[31m-			parameters.logarithmicDepthBuffer && ( parameters.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',[m
[32m+[m			[32m( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',[m
 [m
[31m-			( ( material.extensions ? material.extensions.shaderTextureLOD : false ) || parameters.envMap ) && ( parameters.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',[m
[32m+[m			[32m( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',[m
 [m
 			'uniform mat4 viewMatrix;',[m
 			'uniform vec3 cameraPosition;',[m
[32m+[m			[32m'uniform bool isOrthographic;',[m
 [m
 			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',[m
 			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below[m
[36m@@ -17892,15 +18205,16 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 [m
 			parameters.dithering ? '#define DITHERING' : '',[m
 [m
[31m-			( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?[m
[32m+[m			[32m( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ) ?[m
 				ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below[m
 			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',[m
 			parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',[m
 			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',[m
 			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',[m
[32m+[m			[32mparameters.lightMapEncoding ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',[m
 			parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',[m
 [m
[31m-			parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',[m
[32m+[m			[32mparameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',[m
 [m
 			'\n'[m
 [m
[36m@@ -17919,13 +18233,13 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 	vertexShader = unrollLoops( vertexShader );[m
 	fragmentShader = unrollLoops( fragmentShader );[m
 [m
[31m-	if ( parameters.isWebGL2 && ! material.isRawShaderMaterial ) {[m
[32m+[m	[32mif ( parameters.isWebGL2 && ! parameters.isRawShaderMaterial ) {[m
 [m
 		var isGLSL3ShaderMaterial = false;[m
 [m
 		var versionRegex = /^\s*#version\s+300\s+es\s*\n/;[m
 [m
[31m-		if ( material.isShaderMaterial &&[m
[32m+[m		[32mif ( parameters.isShaderMaterial &&[m
 			vertexShader.match( versionRegex ) !== null &&[m
 			fragmentShader.match( versionRegex ) !== null ) {[m
 [m
[36m@@ -17962,59 +18276,6 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			'#define textureCubeGradEXT textureGrad'[m
 		].join( '\n' ) + '\n' + prefixFragment;[m
 [m
[31m-		// Multiview[m
[31m-[m
[31m-		if ( numMultiviewViews > 0 ) {[m
[31m-[m
[31m-			prefixVertex = prefixVertex.replace([m
[31m-				'#version 300 es\n',[m
[31m-				[[m
[31m-					'#version 300 es\n',[m
[31m-					'#extension GL_OVR_multiview2 : require',[m
[31m-					'layout(num_views = ' + numMultiviewViews + ') in;',[m
[31m-					'#define VIEW_ID gl_ViewID_OVR'[m
[31m-				].join( '\n' )[m
[31m-			);[m
[31m-[m
[31m-			prefixVertex = prefixVertex.replace([m
[31m-				[[m
[31m-					'uniform mat4 modelViewMatrix;',[m
[31m-					'uniform mat4 projectionMatrix;',[m
[31m-					'uniform mat4 viewMatrix;',[m
[31m-					'uniform mat3 normalMatrix;'[m
[31m-				].join( '\n' ),[m
[31m-				[[m
[31m-					'uniform mat4 modelViewMatrices[' + numMultiviewViews + '];',[m
[31m-					'uniform mat4 projectionMatrices[' + numMultiviewViews + '];',[m
[31m-					'uniform mat4 viewMatrices[' + numMultiviewViews + '];',[m
[31m-					'uniform mat3 normalMatrices[' + numMultiviewViews + '];',[m
[31m-[m
[31m-					'#define modelViewMatrix modelViewMatrices[VIEW_ID]',[m
[31m-					'#define projectionMatrix projectionMatrices[VIEW_ID]',[m
[31m-					'#define viewMatrix viewMatrices[VIEW_ID]',[m
[31m-					'#define normalMatrix normalMatrices[VIEW_ID]'[m
[31m-				].join( '\n' )[m
[31m-			);[m
[31m-[m
[31m-			prefixFragment = prefixFragment.replace([m
[31m-				'#version 300 es\n',[m
[31m-				[[m
[31m-					'#version 300 es\n',[m
[31m-					'#extension GL_OVR_multiview2 : require',[m
[31m-					'#define VIEW_ID gl_ViewID_OVR'[m
[31m-				].join( '\n' )[m
[31m-			);[m
[31m-[m
[31m-			prefixFragment = prefixFragment.replace([m
[31m-				'uniform mat4 viewMatrix;',[m
[31m-				[[m
[31m-					'uniform mat4 viewMatrices[' + numMultiviewViews + '];',[m
[31m-					'#define viewMatrix viewMatrices[VIEW_ID]'[m
[31m-				].join( '\n' )[m
[31m-			);[m
[31m-[m
[31m-		}[m
[31m-[m
 	}[m
 [m
 	var vertexGlsl = prefixVertex + vertexShader;[m
[36m@@ -18031,9 +18292,9 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 [m
 	// Force a particular attribute to index 0.[m
 [m
[31m-	if ( material.index0AttributeName !== undefined ) {[m
[32m+[m	[32mif ( parameters.index0AttributeName !== undefined ) {[m
 [m
[31m-		gl.bindAttribLocation( program, 0, material.index0AttributeName );[m
[32m+[m		[32mgl.bindAttribLocation( program, 0, parameters.index0AttributeName );[m
 [m
 	} else if ( parameters.morphTargets === true ) {[m
 [m
[36m@@ -18078,7 +18339,6 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 			this.diagnostics = {[m
 [m
 				runnable: runnable,[m
[31m-				material: material,[m
 [m
 				programLog: programLog,[m
 [m
[36m@@ -18104,6 +18364,9 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 [m
 	// clean up[m
 [m
[32m+[m	[32mgl.detachShader( program, glVertexShader );[m
[32m+[m	[32mgl.detachShader( program, glFragmentShader );[m
[32m+[m
 	gl.deleteShader( glVertexShader );[m
 	gl.deleteShader( glFragmentShader );[m
 [m
[36m@@ -18150,14 +18413,13 @@[m [mfunction WebGLProgram( renderer, extensions, code, material, shader, parameters[m
 [m
 	//[m
 [m
[31m-	this.name = shader.name;[m
[32m+[m	[32mthis.name = parameters.shaderName;[m
 	this.id = programIdCount ++;[m
[31m-	this.code = code;[m
[32m+[m	[32mthis.cacheKey = cacheKey;[m
 	this.usedTimes = 1;[m
 	this.program = program;[m
 	this.vertexShader = glVertexShader;[m
 	this.fragmentShader = glFragmentShader;[m
[31m-	this.numMultiviewViews = numMultiviewViews;[m
 [m
 	return this;[m
 [m
[36m@@ -18171,6 +18433,13 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 [m
 	var programs = [];[m
 [m
[32m+[m	[32mvar isWebGL2 = capabilities.isWebGL2;[m
[32m+[m	[32mvar logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;[m
[32m+[m	[32mvar floatVertexTextures = capabilities.floatVertexTextures;[m
[32m+[m	[32mvar precision = capabilities.precision;[m
[32m+[m	[32mvar maxVertexUniforms = capabilities.maxVertexUniforms;[m
[32m+[m	[32mvar vertexTextures = capabilities.vertexTextures;[m
[32m+[m
 	var shaderIDs = {[m
 		MeshDepthMaterial: 'depth',[m
 		MeshDistanceMaterial: 'distanceRGBA',[m
[36m@@ -18178,7 +18447,7 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 		MeshBasicMaterial: 'basic',[m
 		MeshLambertMaterial: 'lambert',[m
 		MeshPhongMaterial: 'phong',[m
[31m-		MeshToonMaterial: 'phong',[m
[32m+[m		[32mMeshToonMaterial: 'toon',[m
 		MeshStandardMaterial: 'physical',[m
 		MeshPhysicalMaterial: 'physical',[m
 		MeshMatcapMaterial: 'matcap',[m
[36m@@ -18190,27 +18459,57 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 	};[m
 [m
 	var parameterNames = [[m
[31m-		"precision", "supportsVertexTextures", "instancing",[m
[31m-		"map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding",[m
[31m-		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap",[m
[32m+[m		[32m"precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing",[m
[32m+[m		[32m"map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV",[m
[32m+[m		[32m"lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap",[m
 		"roughnessMap", "metalnessMap", "gradientMap",[m
[31m-		"alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp2",[m
[32m+[m		[32m"alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2",[m
 		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",[m
 		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",[m
 		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",[m
 		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",[m
[32m+[m		[32m"numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",[m
 		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',[m
 		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering",[m
 		"sheen"[m
 	];[m
 [m
[32m+[m	[32mfunction getShaderObject( material, shaderID ) {[m
[32m+[m
[32m+[m		[32mvar shaderobject;[m
[32m+[m
[32m+[m		[32mif ( shaderID ) {[m
[32m+[m
[32m+[m			[32mvar shader = ShaderLib[ shaderID ];[m
[32m+[m
[32m+[m			[32mshaderobject = {[m
[32m+[m				[32mname: material.type,[m
[32m+[m				[32muniforms: UniformsUtils.clone( shader.uniforms ),[m
[32m+[m				[32mvertexShader: shader.vertexShader,[m
[32m+[m				[32mfragmentShader: shader.fragmentShader[m
[32m+[m			[32m};[m
[32m+[m
[32m+[m		[32m} else {[m
[32m+[m
[32m+[m			[32mshaderobject = {[m
[32m+[m				[32mname: material.type,[m
[32m+[m				[32muniforms: material.uniforms,[m
[32m+[m				[32mvertexShader: material.vertexShader,[m
[32m+[m				[32mfragmentShader: material.fragmentShader[m
[32m+[m			[32m};[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn shaderobject;[m
[32m+[m
[32m+[m	[32m}[m
 [m
 	function allocateBones( object ) {[m
 [m
 		var skeleton = object.skeleton;[m
 		var bones = skeleton.bones;[m
 [m
[31m-		if ( capabilities.floatVertexTextures ) {[m
[32m+[m		[32mif ( floatVertexTextures ) {[m
 [m
 			return 1024;[m
 [m
[36m@@ -18223,7 +18522,7 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 			//  - limit here is ANGLE's 254 max uniform vectors[m
 			//    (up to 54 should be safe)[m
 [m
[31m-			var nVertexUniforms = capabilities.maxVertexUniforms;[m
[32m+[m			[32mvar nVertexUniforms = maxVertexUniforms;[m
 			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );[m
 [m
 			var maxBones = Math.min( nVertexMatrices, bones.length );[m
[36m@@ -18241,7 +18540,7 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 [m
 	}[m
 [m
[31m-	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {[m
[32m+[m	[32mfunction getTextureEncodingFromMap( map ) {[m
 [m
 		var encoding;[m
 [m
[36m@@ -18260,18 +18559,16 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 [m
 		}[m
 [m
[31m-		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.[m
[31m-		if ( encoding === LinearEncoding && gammaOverrideLinear ) {[m
[31m-[m
[31m-			encoding = GammaEncoding;[m
[31m-[m
[31m-		}[m
[31m-[m
 		return encoding;[m
 [m
 	}[m
 [m
[31m-	this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {[m
[32m+[m	[32mthis.getParameters = function ( material, lights, shadows, scene, nClipPlanes, nClipIntersection, object ) {[m
[32m+[m
[32m+[m		[32mvar fog = scene.fog;[m
[32m+[m		[32mvar environment = material.isMeshStandardMaterial ? scene.environment : null;[m
[32m+[m
[32m+[m		[32mvar envMap = material.envMap || environment;[m
 [m
 		var shaderID = shaderIDs[ material.type ];[m
 [m
[36m@@ -18279,7 +18576,6 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 		// (not to blow over maxLights budget)[m
 [m
 		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;[m
[31m-		var precision = capabilities.precision;[m
 [m
 		if ( material.precision !== null ) {[m
 [m
[36m@@ -18293,36 +18589,51 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 [m
 		}[m
 [m
[32m+[m		[32mvar shaderobject = getShaderObject( material, shaderID );[m
[32m+[m		[32mmaterial.onBeforeCompile( shaderobject, renderer );[m
[32m+[m
 		var currentRenderTarget = renderer.getRenderTarget();[m
 [m
 		var parameters = {[m
 [m
[31m-			isWebGL2: capabilities.isWebGL2,[m
[32m+[m			[32misWebGL2: isWebGL2,[m
 [m
 			shaderID: shaderID,[m
[32m+[m			[32mshaderName: shaderobject.name,[m
[32m+[m
[32m+[m			[32muniforms: shaderobject.uniforms,[m
[32m+[m			[32mvertexShader: shaderobject.vertexShader,[m
[32m+[m			[32mfragmentShader: shaderobject.fragmentShader,[m
[32m+[m			[32mdefines: material.defines,[m
[32m+[m
[32m+[m			[32misRawShaderMaterial: material.isRawShaderMaterial,[m
[32m+[m			[32misShaderMaterial: material.isShaderMaterial,[m
 [m
 			precision: precision,[m
 [m
 			instancing: object.isInstancedMesh === true,[m
 [m
[31m-			supportsVertexTextures: capabilities.vertexTextures,[m
[31m-			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),[m
[32m+[m			[32msupportsVertexTextures: vertexTextures,[m
[32m+[m			[32moutputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,[m
 			map: !! material.map,[m
[31m-			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),[m
[32m+[m			[32mmapEncoding: getTextureEncodingFromMap( material.map ),[m
 			matcap: !! material.matcap,[m
[31m-			matcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),[m
[31m-			envMap: !! material.envMap,[m
[31m-			envMapMode: material.envMap && material.envMap.mapping,[m
[31m-			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),[m
[31m-			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),[m
[32m+[m			[32mmatcapEncoding: getTextureEncodingFromMap( material.matcap ),[m
[32m+[m			[32menvMap: !! envMap,[m
[32m+[m			[32menvMapMode: envMap && envMap.mapping,[m
[32m+[m			[32menvMapEncoding: getTextureEncodingFromMap( envMap ),[m
[32m+[m			[32menvMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),[m
 			lightMap: !! material.lightMap,[m
[32m+[m			[32mlightMapEncoding: getTextureEncodingFromMap( material.lightMap ),[m
 			aoMap: !! material.aoMap,[m
 			emissiveMap: !! material.emissiveMap,[m
[31m-			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),[m
[32m+[m			[32memissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),[m
 			bumpMap: !! material.bumpMap,[m
 			normalMap: !! material.normalMap,[m
 			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,[m
 			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,[m
[32m+[m			[32mclearcoatMap: !! material.clearcoatMap,[m
[32m+[m			[32mclearcoatRoughnessMap: !! material.clearcoatRoughnessMap,[m
 			clearcoatNormalMap: !! material.clearcoatNormalMap,[m
 			displacementMap: !! material.displacementMap,[m
 			roughnessMap: !! material.roughnessMap,[m
[36m@@ -18338,7 +18649,8 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 [m
 			vertexTangents: ( material.normalMap && material.vertexTangents ),[m
 			vertexColors: material.vertexColors,[m
[31m-			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap,[m
[32m+[m			[32mvertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap,[m
[32m+[m			[32muvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap ) && !! material.displacementMap,[m
 [m
 			fog: !! fog,[m
 			useFog: material.fog,[m
[36m@@ -18347,11 +18659,11 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 			flatShading: material.flatShading,[m
 [m
 			sizeAttenuation: material.sizeAttenuation,[m
[31m-			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,[m
[32m+[m			[32mlogarithmicDepthBuffer: logarithmicDepthBuffer,[m
 [m
 			skinning: material.skinning && maxBones > 0,[m
 			maxBones: maxBones,[m
[31m-			useVertexTexture: capabilities.floatVertexTextures,[m
[32m+[m			[32museVertexTexture: floatVertexTextures,[m
 [m
 			morphTargets: material.morphTargets,[m
 			morphNormals: material.morphNormals,[m
[36m@@ -18385,7 +18697,20 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 			doubleSided: material.side === DoubleSide,[m
 			flipSided: material.side === BackSide,[m
 [m
[31m-			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false[m
[32m+[m			[32mdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,[m
[32m+[m
[32m+[m			[32mindex0AttributeName: material.index0AttributeName,[m
[32m+[m
[32m+[m			[32mextensionDerivatives: material.extensions && material.extensions.derivatives,[m
[32m+[m			[32mextensionFragDepth: material.extensions && material.extensions.fragDepth,[m
[32m+[m			[32mextensionDrawBuffers: material.extensions && material.extensions.drawBuffers,[m
[32m+[m			[32mextensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,[m
[32m+[m
[32m+[m			[32mrendererExtensionFragDepth: isWebGL2 || extensions.get( 'EXT_frag_depth' ) !== null,[m
[32m+[m			[32mrendererExtensionDrawBuffers: isWebGL2 || extensions.get( 'WEBGL_draw_buffers' ) !== null,[m
[32m+[m			[32mrendererExtensionShaderTextureLod: isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) !== null,[m
[32m+[m
[32m+[m			[32monBeforeCompile: material.onBeforeCompile[m
 [m
 		};[m
 [m
[36m@@ -18393,7 +18718,7 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 [m
 	};[m
 [m
[31m-	this.getProgramCode = function ( material, parameters ) {[m
[32m+[m	[32mthis.getProgramCacheKey = function ( parameters ) {[m
 [m
 		var array = [];[m
 [m
[36m@@ -18403,50 +18728,53 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 [m
 		} else {[m
 [m
[31m-			array.push( material.fragmentShader );[m
[31m-			array.push( material.vertexShader );[m
[32m+[m			[32marray.push( parameters.fragmentShader );[m
[32m+[m			[32marray.push( parameters.vertexShader );[m
 [m
 		}[m
 [m
[31m-		if ( material.defines !== undefined ) {[m
[32m+[m		[32mif ( parameters.defines !== undefined ) {[m
 [m
[31m-			for ( var name in material.defines ) {[m
[32m+[m			[32mfor ( var name in parameters.defines ) {[m
 [m
 				array.push( name );[m
[31m-				array.push( material.defines[ name ] );[m
[32m+[m				[32marray.push( parameters.defines[ name ] );[m
 [m
 			}[m
 [m
 		}[m
 [m
[31m-		for ( var i = 0; i < parameterNames.length; i ++ ) {[m
[32m+[m		[32mif ( parameters.isRawShaderMaterial === undefined ) {[m
 [m
[31m-			array.push( parameters[ parameterNames[ i ] ] );[m
[32m+[m			[32mfor ( var i = 0; i < parameterNames.length; i ++ ) {[m
 [m
[31m-		}[m
[32m+[m				[32marray.push( parameters[ parameterNames[ i ] ] );[m
[32m+[m
[32m+[m			[32m}[m
 [m
[31m-		array.push( material.onBeforeCompile.toString() );[m
[32m+[m			[32marray.push( renderer.outputEncoding );[m
[32m+[m			[32marray.push( renderer.gammaFactor );[m
 [m
[31m-		array.push( renderer.gammaOutput );[m
[32m+[m		[32m}[m
 [m
[31m-		array.push( renderer.gammaFactor );[m
[32m+[m		[32marray.push( parameters.onBeforeCompile.toString() );[m
 [m
 		return array.join();[m
 [m
 	};[m
 [m
[31m-	this.acquireProgram = function ( material, shader, parameters, code ) {[m
[32m+[m	[32mthis.acquireProgram = function ( parameters, cacheKey ) {[m
 [m
 		var program;[m
 [m
 		// Check if code has been already compiled[m
 		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {[m
 [m
[31m-			var programInfo = programs[ p ];[m
[32m+[m			[32mvar preexistingProgram = programs[ p ];[m
 [m
[31m-			if ( programInfo.code === code ) {[m
[32m+[m			[32mif ( preexistingProgram.cacheKey === cacheKey ) {[m
 [m
[31m-				program = programInfo;[m
[32m+[m				[32mprogram = preexistingProgram;[m
 				++ program.usedTimes;[m
 [m
 				break;[m
[36m@@ -18457,7 +18785,7 @@[m [mfunction WebGLPrograms( renderer, extensions, capabilities ) {[m
 [m
 		if ( program === undefined ) {[m
 [m
[31m-			program = new WebGLProgram( renderer, extensions, code, material, shader, parameters );[m
[32m+[m			[32mprogram = new WebGLProgram( renderer, cacheKey, parameters );[m
 			programs.push( program );[m
 [m
 		}[m
[36m@@ -18669,10 +18997,31 @@[m [mfunction WebGLRenderList() {[m
 [m
 	}[m
 [m
[31m-	function sort() {[m
[32m+[m	[32mfunction sort( customOpaqueSort, customTransparentSort ) {[m
 [m
[31m-		if ( opaque.length > 1 ) opaque.sort( painterSortStable );[m
[31m-		if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );[m
[32m+[m		[32mif ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );[m
[32m+[m		[32mif ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mfunction finish() {[m
[32m+[m
[32m+[m		[32m// Clear references from inactive renderItems in the list[m
[32m+[m
[32m+[m		[32mfor ( var i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {[m
[32m+[m
[32m+[m			[32mvar renderItem = renderItems[ i ];[m
[32m+[m
[32m+[m			[32mif ( renderItem.id === null ) break;[m
[32m+[m
[32m+[m			[32mrenderItem.id = null;[m
[32m+[m			[32mrenderItem.object = null;[m
[32m+[m			[32mrenderItem.geometry = null;[m
[32m+[m			[32mrenderItem.material = null;[m
[32m+[m			[32mrenderItem.program = null;[m
[32m+[m			[32mrenderItem.group = null;[m
[32m+[m
[32m+[m		[32m}[m
 [m
 	}[m
 [m
[36m@@ -18683,6 +19032,7 @@[m [mfunction WebGLRenderList() {[m
 		init: init,[m
 		push: push,[m
 		unshift: unshift,[m
[32m+[m		[32mfinish: finish,[m
 [m
 		sort: sort[m
 	};[m
[36m@@ -18769,12 +19119,7 @@[m [mfunction UniformsCache() {[m
 				case 'DirectionalLight':[m
 					uniforms = {[m
 						direction: new Vector3(),[m
[31m-						color: new Color(),[m
[31m-[m
[31m-						shadow: false,[m
[31m-						shadowBias: 0,[m
[31m-						shadowRadius: 1,[m
[31m-						shadowMapSize: new Vector2()[m
[32m+[m						[32mcolor: new Color()[m
 					};[m
 					break;[m
 [m
[36m@@ -18786,12 +19131,7 @@[m [mfunction UniformsCache() {[m
 						distance: 0,[m
 						coneCos: 0,[m
 						penumbraCos: 0,[m
[31m-						decay: 0,[m
[31m-[m
[31m-						shadow: false,[m
[31m-						shadowBias: 0,[m
[31m-						shadowRadius: 1,[m
[31m-						shadowMapSize: new Vector2()[m
[32m+[m						[32mdecay: 0[m
 					};[m
 					break;[m
 [m
[36m@@ -18800,14 +19140,7 @@[m [mfunction UniformsCache() {[m
 						position: new Vector3(),[m
 						color: new Color(),[m
 						distance: 0,[m
[31m-						decay: 0,[m
[31m-[m
[31m-						shadow: false,[m
[31m-						shadowBias: 0,[m
[31m-						shadowRadius: 1,[m
[31m-						shadowMapSize: new Vector2(),[m
[31m-						shadowCameraNear: 1,[m
[31m-						shadowCameraFar: 1000[m
[32m+[m						[32mdecay: 0[m
 					};[m
 					break;[m
 [m
[36m@@ -18825,7 +19158,6 @@[m [mfunction UniformsCache() {[m
 						position: new Vector3(),[m
 						halfWidth: new Vector3(),[m
 						halfHeight: new Vector3()[m
[31m-						// TODO (abelnation): set RectAreaLight shadow uniforms[m
 					};[m
 					break;[m
 [m
[36m@@ -18841,6 +19173,66 @@[m [mfunction UniformsCache() {[m
 [m
 }[m
 [m
[32m+[m[32mfunction ShadowUniformsCache() {[m
[32m+[m
[32m+[m	[32mvar lights = {};[m
[32m+[m
[32m+[m	[32mreturn {[m
[32m+[m
[32m+[m		[32mget: function ( light ) {[m
[32m+[m
[32m+[m			[32mif ( lights[ light.id ] !== undefined ) {[m
[32m+[m
[32m+[m				[32mreturn lights[ light.id ];[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mvar uniforms;[m
[32m+[m
[32m+[m			[32mswitch ( light.type ) {[m
[32m+[m
[32m+[m				[32mcase 'DirectionalLight':[m
[32m+[m					[32muniforms = {[m
[32m+[m						[32mshadowBias: 0,[m
[32m+[m						[32mshadowRadius: 1,[m
[32m+[m						[32mshadowMapSize: new Vector2()[m
[32m+[m					[32m};[m
[32m+[m					[32mbreak;[m
[32m+[m
[32m+[m				[32mcase 'SpotLight':[m
[32m+[m					[32muniforms = {[m
[32m+[m						[32mshadowBias: 0,[m
[32m+[m						[32mshadowRadius: 1,[m
[32m+[m						[32mshadowMapSize: new Vector2()[m
[32m+[m					[32m};[m
[32m+[m					[32mbreak;[m
[32m+[m
[32m+[m				[32mcase 'PointLight':[m
[32m+[m					[32muniforms = {[m
[32m+[m						[32mshadowBias: 0,[m
[32m+[m						[32mshadowRadius: 1,[m
[32m+[m						[32mshadowMapSize: new Vector2(),[m
[32m+[m						[32mshadowCameraNear: 1,[m
[32m+[m						[32mshadowCameraFar: 1000[m
[32m+[m					[32m};[m
[32m+[m					[32mbreak;[m
[32m+[m
[32m+[m				[32m// TODO (abelnation): set RectAreaLight shadow uniforms[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mlights[ light.id ] = uniforms;[m
[32m+[m
[32m+[m			[32mreturn uniforms;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m};[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m
 var nextVersion = 0;[m
 [m
 function shadowCastingLightsFirst( lightA, lightB ) {[m
[36m@@ -18853,6 +19245,8 @@[m [mfunction WebGLLights() {[m
 [m
 	var cache = new UniformsCache();[m
 [m
[32m+[m	[32mvar shadowCache = ShadowUniformsCache();[m
[32m+[m
 	var state = {[m
 [m
 		version: 0,[m
[36m@@ -18866,26 +19260,25 @@[m [mfunction WebGLLights() {[m
 [m
 			numDirectionalShadows: - 1,[m
 			numPointShadows: - 1,[m
[31m-			numSpotShadows: - 1,[m
[32m+[m			[32mnumSpotShadows: - 1[m
 		},[m
 [m
 		ambient: [ 0, 0, 0 ],[m
 		probe: [],[m
 		directional: [],[m
[32m+[m		[32mdirectionalShadow: [],[m
 		directionalShadowMap: [],[m
 		directionalShadowMatrix: [],[m
 		spot: [],[m
[32m+[m		[32mspotShadow: [],[m
 		spotShadowMap: [],[m
 		spotShadowMatrix: [],[m
 		rectArea: [],[m
 		point: [],[m
[32m+[m		[32mpointShadow: [],[m
 		pointShadowMap: [],[m
 		pointShadowMatrix: [],[m
[31m-		hemi: [],[m
[31m-[m
[31m-		numDirectionalShadows: - 1,[m
[31m-		numPointShadows: - 1,[m
[31m-		numSpotShadows: - 1[m
[32m+[m		[32mhemi: [][m
 [m
 	};[m
 [m
[36m@@ -18949,16 +19342,17 @@[m [mfunction WebGLLights() {[m
 				uniforms.direction.sub( vector3 );[m
 				uniforms.direction.transformDirection( viewMatrix );[m
 [m
[31m-				uniforms.shadow = light.castShadow;[m
[31m-[m
 				if ( light.castShadow ) {[m
 [m
 					var shadow = light.shadow;[m
 [m
[31m-					uniforms.shadowBias = shadow.bias;[m
[31m-					uniforms.shadowRadius = shadow.radius;[m
[31m-					uniforms.shadowMapSize = shadow.mapSize;[m
[32m+[m					[32mvar shadowUniforms = shadowCache.get( light );[m
[32m+[m
[32m+[m					[32mshadowUniforms.shadowBias = shadow.bias;[m
[32m+[m					[32mshadowUniforms.shadowRadius = shadow.radius;[m
[32m+[m					[32mshadowUniforms.shadowMapSize = shadow.mapSize;[m
 [m
[32m+[m					[32mstate.directionalShadow[ directionalLength ] = shadowUniforms;[m
 					state.directionalShadowMap[ directionalLength ] = shadowMap;[m
 					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;[m
 [m
[36m@@ -18989,16 +19383,17 @@[m [mfunction WebGLLights() {[m
 				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );[m
 				uniforms.decay = light.decay;[m
 [m
[31m-				uniforms.shadow = light.castShadow;[m
[31m-[m
 				if ( light.castShadow ) {[m
 [m
 					var shadow = light.shadow;[m
 [m
[31m-					uniforms.shadowBias = shadow.bias;[m
[31m-					uniforms.shadowRadius = shadow.radius;[m
[31m-					uniforms.shadowMapSize = shadow.mapSize;[m
[32m+[m					[32mvar shadowUniforms = shadowCache.get( light );[m
[32m+[m
[32m+[m					[32mshadowUniforms.shadowBias = shadow.bias;[m
[32m+[m					[32mshadowUniforms.shadowRadius = shadow.radius;[m
[32m+[m					[32mshadowUniforms.shadowMapSize = shadow.mapSize;[m
 [m
[32m+[m					[32mstate.spotShadow[ spotLength ] = shadowUniforms;[m
 					state.spotShadowMap[ spotLength ] = shadowMap;[m
 					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;[m
 [m
[36m@@ -19053,18 +19448,19 @@[m [mfunction WebGLLights() {[m
 				uniforms.distance = light.distance;[m
 				uniforms.decay = light.decay;[m
 [m
[31m-				uniforms.shadow = light.castShadow;[m
[31m-[m
 				if ( light.castShadow ) {[m
 [m
 					var shadow = light.shadow;[m
 [m
[31m-					uniforms.shadowBias = shadow.bias;[m
[31m-					uniforms.shadowRadius = shadow.radius;[m
[31m-					uniforms.shadowMapSize = shadow.mapSize;[m
[31m-					uniforms.shadowCameraNear = shadow.camera.near;[m
[31m-					uniforms.shadowCameraFar = shadow.camera.far;[m
[32m+[m					[32mvar shadowUniforms = shadowCache.get( light );[m
[32m+[m
[32m+[m					[32mshadowUniforms.shadowBias = shadow.bias;[m
[32m+[m					[32mshadowUniforms.shadowRadius = shadow.radius;[m
[32m+[m					[32mshadowUniforms.shadowMapSize = shadow.mapSize;[m
[32m+[m					[32mshadowUniforms.shadowCameraNear = shadow.camera.near;[m
[32m+[m					[32mshadowUniforms.shadowCameraFar = shadow.camera.far;[m
 [m
[32m+[m					[32mstate.pointShadow[ pointLength ] = shadowUniforms;[m
 					state.pointShadowMap[ pointLength ] = shadowMap;[m
 					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;[m
 [m
[36m@@ -19116,8 +19512,11 @@[m [mfunction WebGLLights() {[m
 			state.point.length = pointLength;[m
 			state.hemi.length = hemiLength;[m
 [m
[32m+[m			[32mstate.directionalShadow.length = numDirectionalShadows;[m
 			state.directionalShadowMap.length = numDirectionalShadows;[m
[32m+[m			[32mstate.pointShadow.length = numPointShadows;[m
 			state.pointShadowMap.length = numPointShadows;[m
[32m+[m			[32mstate.spotShadow.length = numSpotShadows;[m
 			state.spotShadowMap.length = numSpotShadows;[m
 			state.directionalShadowMatrix.length = numDirectionalShadows;[m
 			state.pointShadowMatrix.length = numPointShadows;[m
[36m@@ -19416,7 +19815,7 @@[m [mMeshDistanceMaterial.prototype.copy = function ( source ) {[m
 [m
 };[m
 [m
[31m-var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}";[m
[32m+[m[32mvar vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";[m
 [m
 var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";[m
 [m
[36m@@ -19434,13 +19833,8 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
 [m
 		_viewport = new Vector4(),[m
 [m
[31m-		_MorphingFlag = 1,[m
[31m-		_SkinningFlag = 2,[m
[31m-[m
[31m-		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,[m
[31m-[m
[31m-		_depthMaterials = new Array( _NumberOfMaterialVariants ),[m
[31m-		_distanceMaterials = new Array( _NumberOfMaterialVariants ),[m
[32m+[m		[32m_depthMaterials = [],[m
[32m+[m		[32m_distanceMaterials = [],[m
 [m
 		_materialCache = {};[m
 [m
[36m@@ -19469,7 +19863,7 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
 	shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;[m
 [m
 	var fullScreenTri = new BufferGeometry();[m
[31m-	fullScreenTri.addAttribute([m
[32m+[m	[32mfullScreenTri.setAttribute([m
 		"position",[m
 		new BufferAttribute([m
 			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),[m
[36m@@ -19479,35 +19873,6 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
 [m
 	var fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );[m
 [m
[31m-	// init[m
[31m-[m
[31m-	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {[m
[31m-[m
[31m-		var useMorphing = ( i & _MorphingFlag ) !== 0;[m
[31m-		var useSkinning = ( i & _SkinningFlag ) !== 0;[m
[31m-[m
[31m-		var depthMaterial = new MeshDepthMaterial( {[m
[31m-[m
[31m-			depthPacking: RGBADepthPacking,[m
[31m-[m
[31m-			morphTargets: useMorphing,[m
[31m-			skinning: useSkinning[m
[31m-[m
[31m-		} );[m
[31m-[m
[31m-		_depthMaterials[ i ] = depthMaterial;[m
[31m-[m
[31m-		var distanceMaterial = new MeshDistanceMaterial( {[m
[31m-[m
[31m-			morphTargets: useMorphing,[m
[31m-			skinning: useSkinning[m
[31m-[m
[31m-		} );[m
[31m-[m
[31m-		_distanceMaterials[ i ] = distanceMaterial;[m
[31m-[m
[31m-	}[m
[31m-[m
 	var scope = this;[m
 [m
 	this.enabled = false;[m
[36m@@ -19622,7 +19987,7 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
 [m
 				_state.viewport( _viewport );[m
 [m
[31m-				shadow.updateMatrices( light, camera, vp );[m
[32m+[m				[32mshadow.updateMatrices( light, vp );[m
 [m
 				_frustum = shadow.getFrustum();[m
 [m
[36m@@ -19670,33 +20035,81 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
 [m
 	}[m
 [m
[32m+[m	[32mfunction getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {[m
[32m+[m
[32m+[m		[32mvar index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;[m
[32m+[m
[32m+[m		[32mvar material = _depthMaterials[ index ];[m
[32m+[m
[32m+[m		[32mif ( material === undefined ) {[m
[32m+[m
[32m+[m			[32mmaterial = new MeshDepthMaterial( {[m
[32m+[m
[32m+[m				[32mdepthPacking: RGBADepthPacking,[m
[32m+[m
[32m+[m				[32mmorphTargets: useMorphing,[m
[32m+[m				[32mskinning: useSkinning[m
[32m+[m
[32m+[m			[32m} );[m
[32m+[m
[32m+[m			[32m_depthMaterials[ index ] = material;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn material;[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mfunction getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {[m
[32m+[m
[32m+[m		[32mvar index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;[m
[32m+[m
[32m+[m		[32mvar material = _distanceMaterials[ index ];[m
[32m+[m
[32m+[m		[32mif ( material === undefined ) {[m
[32m+[m
[32m+[m			[32mmaterial = new MeshDistanceMaterial( {[m
[32m+[m
[32m+[m				[32mmorphTargets: useMorphing,[m
[32m+[m				[32mskinning: useSkinning[m
[32m+[m
[32m+[m			[32m} );[m
[32m+[m
[32m+[m			[32m_distanceMaterials[ index ] = material;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn material;[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
 	function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {[m
 [m
 		var geometry = object.geometry;[m
 [m
 		var result = null;[m
 [m
[31m-		var materialVariants = _depthMaterials;[m
[32m+[m		[32mvar getMaterialVariant = getDepthMaterialVariant;[m
 		var customMaterial = object.customDepthMaterial;[m
 [m
[31m-		if ( light.isPointLight ) {[m
[32m+[m		[32mif ( light.isPointLight === true ) {[m
 [m
[31m-			materialVariants = _distanceMaterials;[m
[32m+[m			[32mgetMaterialVariant = getDistanceMaterialVariant;[m
 			customMaterial = object.customDistanceMaterial;[m
 [m
 		}[m
 [m
[31m-		if ( ! customMaterial ) {[m
[32m+[m		[32mif ( customMaterial === undefined ) {[m
 [m
 			var useMorphing = false;[m
 [m
[31m-			if ( material.morphTargets ) {[m
[32m+[m			[32mif ( material.morphTargets === true ) {[m
 [m
[31m-				if ( geometry && geometry.isBufferGeometry ) {[m
[32m+[m				[32mif ( geometry.isBufferGeometry === true ) {[m
 [m
 					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;[m
 [m
[31m-				} else if ( geometry && geometry.isGeometry ) {[m
[32m+[m				[32m} else if ( geometry.isGeometry === true ) {[m
 [m
 					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;[m
 [m
[36m@@ -19704,20 +20117,25 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
 [m
 			}[m
 [m
[31m-			if ( object.isSkinnedMesh && material.skinning === false ) {[m
[32m+[m			[32mvar useSkinning = false;[m
 [m
[31m-				console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );[m
[32m+[m			[32mif ( object.isSkinnedMesh === true ) {[m
 [m
[31m-			}[m
[32m+[m				[32mif ( material.skinning === true ) {[m
 [m
[31m-			var useSkinning = object.isSkinnedMesh && material.skinning;[m
[32m+[m					[32museSkinning = true;[m
 [m
[31m-			var variantIndex = 0;[m
[32m+[m				[32m} else {[m
[32m+[m
[32m+[m					[32mconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );[m
 [m
[31m-			if ( useMorphing ) variantIndex |= _MorphingFlag;[m
[31m-			if ( useSkinning ) variantIndex |= _SkinningFlag;[m
[32m+[m				[32m}[m
 [m
[31m-			result = materialVariants[ variantIndex ];[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mvar useInstancing = object.isInstancedMesh === true;[m
[32m+[m
[32m+[m			[32mresult = getMaterialVariant( useMorphing, useSkinning, useInstancing );[m
 [m
 		} else {[m
 [m
[36m@@ -19761,11 +20179,11 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
 [m
 		if ( type === VSMShadowMap ) {[m
 [m
[31m-			result.side = ( material.shadowSide != null ) ? material.shadowSide : material.side;[m
[32m+[m			[32mresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;[m
 [m
 		} else {[m
 [m
[31m-			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];[m
[32m+[m			[32mresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];[m
 [m
 		}[m
 [m
[36m@@ -19776,7 +20194,7 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
 		result.wireframeLinewidth = material.wireframeLinewidth;[m
 		result.linewidth = material.linewidth;[m
 [m
[31m-		if ( light.isPointLight && result.isMeshDistanceMaterial ) {[m
[32m+[m		[32mif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {[m
 [m
 			result.referencePosition.setFromMatrixPosition( light.matrixWorld );[m
 			result.nearDistance = shadowCameraNear;[m
[36m@@ -19850,7 +20268,9 @@[m [mfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {[m
  * @author mrdoob / http://mrdoob.com/[m
  */[m
 [m
[31m-function WebGLState( gl, extensions, utils, capabilities ) {[m
[32m+[m[32mfunction WebGLState( gl, extensions, capabilities ) {[m
[32m+[m
[32m+[m	[32mvar isWebGL2 = capabilities.isWebGL2;[m
 [m
 	function ColorBuffer() {[m
 [m
[36m@@ -20168,8 +20588,6 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 	var enabledCapabilities = {};[m
 [m
[31m-	var compressedTextureFormats = null;[m
[31m-[m
 	var currentProgram = null;[m
 [m
 	var currentBlendingEnabled = null;[m
[36m@@ -20283,9 +20701,9 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {[m
 [m
[31m-			var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );[m
[32m+[m			[32mvar extension = isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );[m
 [m
[31m-			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );[m
[32m+[m			[32mextension[ isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );[m
 			attributeDivisors[ attribute ] = meshPerAttribute;[m
 [m
 		}[m
[36m@@ -20329,49 +20747,60 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 	}[m
 [m
[31m-	function getCompressedTextureFormats() {[m
[31m-[m
[31m-		if ( compressedTextureFormats === null ) {[m
[31m-[m
[31m-			compressedTextureFormats = [];[m
[31m-[m
[31m-			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||[m
[31m-			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||[m
[31m-			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||[m
[31m-			     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {[m
[31m-[m
[31m-				var formats = gl.getParameter( 34467 );[m
[32m+[m	[32mfunction useProgram( program ) {[m
 [m
[31m-				for ( var i = 0; i < formats.length; i ++ ) {[m
[32m+[m		[32mif ( currentProgram !== program ) {[m
 [m
[31m-					compressedTextureFormats.push( formats[ i ] );[m
[32m+[m			[32mgl.useProgram( program );[m
 [m
[31m-				}[m
[32m+[m			[32mcurrentProgram = program;[m
 [m
[31m-			}[m
[32m+[m			[32mreturn true;[m
 [m
 		}[m
 [m
[31m-		return compressedTextureFormats;[m
[32m+[m		[32mreturn false;[m
 [m
 	}[m
 [m
[31m-	function useProgram( program ) {[m
[32m+[m	[32mvar equationToGL = {[m
[32m+[m		[32m[ AddEquation ]: 32774,[m
[32m+[m		[32m[ SubtractEquation ]: 32778,[m
[32m+[m		[32m[ ReverseSubtractEquation ]: 32779[m
[32m+[m	[32m};[m
 [m
[31m-		if ( currentProgram !== program ) {[m
[32m+[m	[32mif ( isWebGL2 ) {[m
 [m
[31m-			gl.useProgram( program );[m
[32m+[m		[32mequationToGL[ MinEquation ] = 32775;[m
[32m+[m		[32mequationToGL[ MaxEquation ] = 32776;[m
 [m
[31m-			currentProgram = program;[m
[32m+[m	[32m} else {[m
 [m
[31m-			return true;[m
[32m+[m		[32mvar extension = extensions.get( 'EXT_blend_minmax' );[m
 [m
[31m-		}[m
[32m+[m		[32mif ( extension !== null ) {[m
 [m
[31m-		return false;[m
[32m+[m			[32mequationToGL[ MinEquation ] = extension.MIN_EXT;[m
[32m+[m			[32mequationToGL[ MaxEquation ] = extension.MAX_EXT;[m
[32m+[m
[32m+[m		[32m}[m
 [m
 	}[m
 [m
[32m+[m	[32mvar factorToGL = {[m
[32m+[m		[32m[ ZeroFactor ]: 0,[m
[32m+[m		[32m[ OneFactor ]: 1,[m
[32m+[m		[32m[ SrcColorFactor ]: 768,[m
[32m+[m		[32m[ SrcAlphaFactor ]: 770,[m
[32m+[m		[32m[ SrcAlphaSaturateFactor ]: 776,[m
[32m+[m		[32m[ DstColorFactor ]: 774,[m
[32m+[m		[32m[ DstAlphaFactor ]: 772,[m
[32m+[m		[32m[ OneMinusSrcColorFactor ]: 769,[m
[32m+[m		[32m[ OneMinusSrcAlphaFactor ]: 771,[m
[32m+[m		[32m[ OneMinusDstColorFactor ]: 775,[m
[32m+[m		[32m[ OneMinusDstAlphaFactor ]: 773[m
[32m+[m	[32m};[m
[32m+[m
 	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {[m
 [m
 		if ( blending === NoBlending ) {[m
[36m@@ -20483,7 +20912,7 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {[m
 [m
[31m-			gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );[m
[32m+[m			[32mgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );[m
 [m
 			currentBlendEquation = blendEquation;[m
 			currentBlendEquationAlpha = blendEquationAlpha;[m
[36m@@ -20492,7 +20921,7 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {[m
 [m
[31m-			gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );[m
[32m+[m			[32mgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );[m
 [m
 			currentBlendSrc = blendSrc;[m
 			currentBlendDst = blendDst;[m
[36m@@ -20688,6 +21117,21 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 	}[m
 [m
[32m+[m	[32mfunction unbindTexture() {[m
[32m+[m
[32m+[m		[32mvar boundTexture = currentBoundTextures[ currentTextureSlot ];[m
[32m+[m
[32m+[m		[32mif ( boundTexture !== undefined && boundTexture.type !== undefined ) {[m
[32m+[m
[32m+[m			[32mgl.bindTexture( boundTexture.type, null );[m
[32m+[m
[32m+[m			[32mboundTexture.type = undefined;[m
[32m+[m			[32mboundTexture.texture = undefined;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
 	function compressedTexImage2D() {[m
 [m
 		try {[m
[36m@@ -20771,8 +21215,6 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 		enabledCapabilities = {};[m
 [m
[31m-		compressedTextureFormats = null;[m
[31m-[m
 		currentTextureSlot = null;[m
 		currentBoundTextures = {};[m
 [m
[36m@@ -20803,7 +21245,6 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 		disableUnusedAttributes: disableUnusedAttributes,[m
 		enable: enable,[m
 		disable: disable,[m
[31m-		getCompressedTextureFormats: getCompressedTextureFormats,[m
 [m
 		useProgram: useProgram,[m
 [m
[36m@@ -20820,6 +21261,7 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 		activeTexture: activeTexture,[m
 		bindTexture: bindTexture,[m
[32m+[m		[32munbindTexture: unbindTexture,[m
 		compressedTexImage2D: compressedTexImage2D,[m
 		texImage2D: texImage2D,[m
 		texImage3D: texImage3D,[m
[36m@@ -20839,14 +21281,31 @@[m [mfunction WebGLState( gl, extensions, utils, capabilities ) {[m
 [m
 function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {[m
 [m
[32m+[m	[32mvar isWebGL2 = capabilities.isWebGL2;[m
[32m+[m	[32mvar maxTextures = capabilities.maxTextures;[m
[32m+[m	[32mvar maxCubemapSize = capabilities.maxCubemapSize;[m
[32m+[m	[32mvar maxTextureSize = capabilities.maxTextureSize;[m
[32m+[m	[32mvar maxSamples = capabilities.maxSamples;[m
[32m+[m
 	var _videoTextures = new WeakMap();[m
 	var _canvas;[m
 [m
 	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,[m
 	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")![m
[32m+[m	[32m// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).[m
[32m+[m
[32m+[m	[32mvar useOffscreenCanvas = false;[m
[32m+[m
[32m+[m	[32mtry {[m
[32m+[m
[32m+[m		[32museOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'[m
[32m+[m			[32m&& ( new OffscreenCanvas( 1, 1 ).getContext( "2d" ) ) !== null;[m
 [m
[31m-	var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'[m
[31m-		&& ( new OffscreenCanvas( 1, 1 ).getContext( "2d" ) ) !== null;[m
[32m+[m	[32m} catch ( err ) {[m
[32m+[m
[32m+[m		[32m// Ignore any errors[m
[32m+[m
[32m+[m	[32m}[m
 [m
 	function createCanvas( width, height ) {[m
 [m
[36m@@ -20880,7 +21339,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||[m
 				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {[m
 [m
[31m-				var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;[m
[32m+[m				[32mvar floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;[m
 [m
 				var width = floor( scale * image.width );[m
 				var height = floor( scale * image.height );[m
[36m@@ -20921,13 +21380,13 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 	function isPowerOfTwo( image ) {[m
 [m
[31m-		return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );[m
[32m+[m		[32mreturn MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );[m
 [m
 	}[m
 [m
 	function textureNeedsPowerOfTwo( texture ) {[m
 [m
[31m-		if ( capabilities.isWebGL2 ) return false;[m
[32m+[m		[32mif ( isWebGL2 ) return false;[m
 [m
 		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||[m
 			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );[m
[36m@@ -20952,9 +21411,17 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 	}[m
 [m
[31m-	function getInternalFormat( glFormat, glType ) {[m
[32m+[m	[32mfunction getInternalFormat( internalFormatName, glFormat, glType ) {[m
[32m+[m
[32m+[m		[32mif ( isWebGL2 === false ) return glFormat;[m
 [m
[31m-		if ( ! capabilities.isWebGL2 ) return glFormat;[m
[32m+[m		[32mif ( internalFormatName !== null ) {[m
[32m+[m
[32m+[m			[32mif ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );[m
[32m+[m
[32m+[m		[32m}[m
 [m
 		var internalFormat = glFormat;[m
 [m
[36m@@ -20987,10 +21454,6 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			extensions.get( 'EXT_color_buffer_float' );[m
 [m
[31m-		} else if ( internalFormat === 34843 || internalFormat === 34837 ) {[m
[31m-[m
[31m-			console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );[m
[31m-[m
 		}[m
 [m
 		return internalFormat;[m
[36m@@ -21076,7 +21539,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		}[m
 [m
[31m-		if ( renderTarget.isWebGLRenderTargetCube ) {[m
[32m+[m		[32mif ( renderTarget.isWebGLCubeRenderTarget ) {[m
 [m
 			for ( var i = 0; i < 6; i ++ ) {[m
 [m
[36m@@ -21089,21 +21552,9 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );[m
 			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		if ( renderTarget.isWebGLMultiviewRenderTarget ) {[m
[31m-[m
[31m-			_gl.deleteTexture( renderTargetProperties.__webglColorTexture );[m
[31m-			_gl.deleteTexture( renderTargetProperties.__webglDepthStencilTexture );[m
[31m-[m
[31m-			info.memory.textures -= 2;[m
[31m-[m
[31m-			for ( var i = 0, il = renderTargetProperties.__webglViewFramebuffers.length; i < il; i ++ ) {[m
[31m-[m
[31m-				_gl.deleteFramebuffer( renderTargetProperties.__webglViewFramebuffers[ i ] );[m
[31m-[m
[31m-			}[m
[32m+[m			[32mif ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );[m
[32m+[m			[32mif ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );[m
[32m+[m			[32mif ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );[m
 [m
 		}[m
 [m
[36m@@ -21126,9 +21577,9 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		var textureUnit = textureUnits;[m
 [m
[31m-		if ( textureUnit >= capabilities.maxTextures ) {[m
[32m+[m		[32mif ( textureUnit >= maxTextures ) {[m
 [m
[31m-			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );[m
 [m
 		}[m
 [m
[36m@@ -21219,7 +21670,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			_gl.pixelStorei( 37440, texture.flipY );[m
 [m
[31m-			var isCompressed = ( texture && texture.isCompressedTexture );[m
[32m+[m			[32mvar isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );[m
 			var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );[m
 [m
 			var cubeImage = [];[m
[36m@@ -21228,7 +21679,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 				if ( ! isCompressed && ! isDataTexture ) {[m
 [m
[31m-					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );[m
[32m+[m					[32mcubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );[m
 [m
 				} else {[m
 [m
[36m@@ -21239,10 +21690,10 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 			}[m
 [m
 			var image = cubeImage[ 0 ],[m
[31m-				supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,[m
[32m+[m				[32msupportsMips = isPowerOfTwo( image ) || isWebGL2,[m
 				glFormat = utils.convert( texture.format ),[m
 				glType = utils.convert( texture.type ),[m
[31m-				glInternalFormat = getInternalFormat( glFormat, glType );[m
[32m+[m				[32mglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );[m
 [m
 			setTextureParameters( 34067, texture, supportsMips );[m
 [m
[36m@@ -21260,7 +21711,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {[m
 [m
[31m-							if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {[m
[32m+[m							[32mif ( glFormat !== null ) {[m
 [m
 								state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );[m
 [m
[36m@@ -21348,23 +21799,37 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 	}[m
 [m
[31m-	function setTextureParameters( textureType, texture, supportsMips ) {[m
[32m+[m	[32mvar wrappingToGL = {[m
[32m+[m		[32m[ RepeatWrapping ]: 10497,[m
[32m+[m		[32m[ ClampToEdgeWrapping ]: 33071,[m
[32m+[m		[32m[ MirroredRepeatWrapping ]: 33648[m
[32m+[m	[32m};[m
 [m
[31m-		var extension;[m
[32m+[m	[32mvar filterToGL = {[m
[32m+[m		[32m[ NearestFilter ]: 9728,[m
[32m+[m		[32m[ NearestMipmapNearestFilter ]: 9984,[m
[32m+[m		[32m[ NearestMipmapLinearFilter ]: 9986,[m
[32m+[m
[32m+[m		[32m[ LinearFilter ]: 9729,[m
[32m+[m		[32m[ LinearMipmapNearestFilter ]: 9985,[m
[32m+[m		[32m[ LinearMipmapLinearFilter ]: 9987[m
[32m+[m	[32m};[m
[32m+[m
[32m+[m	[32mfunction setTextureParameters( textureType, texture, supportsMips ) {[m
 [m
 		if ( supportsMips ) {[m
 [m
[31m-			_gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) );[m
[31m-			_gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) );[m
[32m+[m			[32m_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );[m
[32m+[m			[32m_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );[m
 [m
 			if ( textureType === 32879 || textureType === 35866 ) {[m
 [m
[31m-				_gl.texParameteri( textureType, 32882, utils.convert( texture.wrapR ) );[m
[32m+[m				[32m_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );[m
 [m
 			}[m
 [m
[31m-			_gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) );[m
[31m-			_gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) );[m
[32m+[m			[32m_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );[m
[32m+[m			[32m_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );[m
 [m
 		} else {[m
 [m
[36m@@ -21394,12 +21859,12 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		}[m
 [m
[31m-		extension = extensions.get( 'EXT_texture_filter_anisotropic' );[m
[32m+[m		[32mvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );[m
 [m
 		if ( extension ) {[m
 [m
 			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;[m
[31m-			if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;[m
[32m+[m			[32mif ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;[m
 [m
 			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {[m
 [m
[36m@@ -21445,12 +21910,12 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 		_gl.pixelStorei( 3317, texture.unpackAlignment );[m
 [m
 		var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;[m
[31m-		var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );[m
[32m+[m		[32mvar image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );[m
 [m
[31m-		var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,[m
[32m+[m		[32mvar supportsMips = isPowerOfTwo( image ) || isWebGL2,[m
 			glFormat = utils.convert( texture.format ),[m
 			glType = utils.convert( texture.type ),[m
[31m-			glInternalFormat = getInternalFormat( glFormat, glType );[m
[32m+[m			[32mglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );[m
 [m
 		setTextureParameters( textureType, texture, supportsMips );[m
 [m
[36m@@ -21462,18 +21927,38 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			glInternalFormat = 6402;[m
 [m
[31m-			if ( texture.type === FloatType ) {[m
[32m+[m			[32mif ( isWebGL2 ) {[m
[32m+[m
[32m+[m				[32mif ( texture.type === FloatType ) {[m
[32m+[m
[32m+[m					[32mglInternalFormat = 36012;[m
 [m
[31m-				if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );[m
[31m-				glInternalFormat = 36012;[m
[32m+[m				[32m} else if ( texture.type === UnsignedIntType ) {[m
 [m
[31m-			} else if ( capabilities.isWebGL2 ) {[m
[32m+[m					[32mglInternalFormat = 33190;[m
 [m
[31m-				// WebGL 2.0 requires signed internalformat for glTexImage2D[m
[31m-				glInternalFormat = 33189;[m
[32m+[m				[32m} else if ( texture.type === UnsignedInt248Type ) {[m
[32m+[m
[32m+[m					[32mglInternalFormat = 35056;[m
[32m+[m
[32m+[m				[32m} else {[m
[32m+[m
[32m+[m					[32mglInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D[m
[32m+[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m			[32m} else {[m
[32m+[m
[32m+[m				[32mif ( texture.type === FloatType ) {[m
[32m+[m
[32m+[m					[32mconsole.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );[m
[32m+[m
[32m+[m				[32m}[m
 [m
 			}[m
 [m
[32m+[m			[32m// validation checks for WebGL 1[m
[32m+[m
 			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {[m
 [m
 				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are[m
[36m@@ -21490,10 +21975,10 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			}[m
 [m
[31m-			// Depth stencil textures need the DEPTH_STENCIL internal format[m
[31m-			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)[m
[31m-			if ( texture.format === DepthStencilFormat ) {[m
[32m+[m			[32mif ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {[m
 [m
[32m+[m				[32m// Depth stencil textures need the DEPTH_STENCIL internal format[m
[32m+[m				[32m// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)[m
 				glInternalFormat = 34041;[m
 [m
 				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are[m
[36m@@ -21510,6 +21995,8 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			}[m
 [m
[32m+[m			[32m//[m
[32m+[m
 			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );[m
 [m
 		} else if ( texture.isDataTexture ) {[m
[36m@@ -21545,7 +22032,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {[m
 [m
[31m-					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {[m
[32m+[m					[32mif ( glFormat !== null ) {[m
 [m
 						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );[m
 [m
[36m@@ -21606,7 +22093,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {[m
 [m
[31m-			generateMipmap( 3553, texture, image.width, image.height );[m
[32m+[m			[32mgenerateMipmap( textureType, texture, image.width, image.height );[m
 [m
 		}[m
 [m
[36m@@ -21623,7 +22110,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		var glFormat = utils.convert( renderTarget.texture.format );[m
 		var glType = utils.convert( renderTarget.texture.type );[m
[31m-		var glInternalFormat = getInternalFormat( glFormat, glType );[m
[32m+[m		[32mvar glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );[m
 		state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );[m
 		_gl.bindFramebuffer( 36160, framebuffer );[m
 		_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );[m
[36m@@ -21638,15 +22125,33 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {[m
 [m
[32m+[m			[32mvar glInternalFormat = 33189;[m
[32m+[m
 			if ( isMultisample ) {[m
 [m
[32m+[m				[32mvar depthTexture = renderTarget.depthTexture;[m
[32m+[m
[32m+[m				[32mif ( depthTexture && depthTexture.isDepthTexture ) {[m
[32m+[m
[32m+[m					[32mif ( depthTexture.type === FloatType ) {[m
[32m+[m
[32m+[m						[32mglInternalFormat = 36012;[m
[32m+[m
[32m+[m					[32m} else if ( depthTexture.type === UnsignedIntType ) {[m
[32m+[m
[32m+[m						[32mglInternalFormat = 33190;[m
[32m+[m
[32m+[m					[32m}[m
[32m+[m
[32m+[m				[32m}[m
[32m+[m
 				var samples = getRenderTargetSamples( renderTarget );[m
 [m
[31m-				_gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );[m
[32m+[m				[32m_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );[m
 [m
 			} else {[m
 [m
[31m-				_gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );[m
[32m+[m				[32m_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );[m
 [m
 			}[m
 [m
[36m@@ -21673,7 +22178,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			var glFormat = utils.convert( renderTarget.texture.format );[m
 			var glType = utils.convert( renderTarget.texture.type );[m
[31m-			var glInternalFormat = getInternalFormat( glFormat, glType );[m
[32m+[m			[32mvar glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );[m
 [m
 			if ( isMultisample ) {[m
 [m
[36m@@ -21696,7 +22201,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 	// Setup resources for a Depth Texture for a FBO (needs an extension)[m
 	function setupDepthTexture( framebuffer, renderTarget ) {[m
 [m
[31m-		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );[m
[32m+[m		[32mvar isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );[m
 		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );[m
 [m
 		_gl.bindFramebuffer( 36160, framebuffer );[m
[36m@@ -21743,7 +22248,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		var renderTargetProperties = properties.get( renderTarget );[m
 [m
[31m-		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );[m
[32m+[m		[32mvar isCube = ( renderTarget.isWebGLCubeRenderTarget === true );[m
 [m
 		if ( renderTarget.depthTexture ) {[m
 [m
[36m@@ -21761,7 +22266,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );[m
 					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();[m
[31m-					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );[m
[32m+[m					[32msetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );[m
 [m
 				}[m
 [m
[36m@@ -21769,7 +22274,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );[m
 				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();[m
[31m-				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );[m
[32m+[m				[32msetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );[m
 [m
 			}[m
 [m
[36m@@ -21791,10 +22296,19 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		info.memory.textures ++;[m
 [m
[31m-		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );[m
[32m+[m		[32mvar isCube = ( renderTarget.isWebGLCubeRenderTarget === true );[m
 		var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );[m
[31m-		var isMultiview = ( renderTarget.isWebGLMultiviewRenderTarget === true );[m
[31m-		var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;[m
[32m+[m		[32mvar supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;[m
[32m+[m
[32m+[m		[32m// Handles WebGL2 RGBFormat fallback - #18858[m
[32m+[m
[32m+[m		[32mif ( isWebGL2 && renderTarget.texture.format === RGBFormat && ( renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType ) ) {[m
[32m+[m
[32m+[m			[32mrenderTarget.texture.format = RGBAFormat;[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );[m
[32m+[m
[32m+[m		[32m}[m
 [m
 		// Setup framebuffer[m
 [m
[36m@@ -21814,15 +22328,16 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			if ( isMultisample ) {[m
 [m
[31m-				if ( capabilities.isWebGL2 ) {[m
[32m+[m				[32mif ( isWebGL2 ) {[m
 [m
 					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();[m
 					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();[m
 [m
 					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );[m
[32m+[m
 					var glFormat = utils.convert( renderTarget.texture.format );[m
 					var glType = utils.convert( renderTarget.texture.type );[m
[31m-					var glInternalFormat = getInternalFormat( glFormat, glType );[m
[32m+[m					[32mvar glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );[m
 					var samples = getRenderTargetSamples( renderTarget );[m
 					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );[m
 [m
[36m@@ -21846,48 +22361,6 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 				}[m
 [m
[31m-			} else if ( isMultiview ) {[m
[31m-[m
[31m-				var width = renderTarget.width;[m
[31m-				var height = renderTarget.height;[m
[31m-				var numViews = renderTarget.numViews;[m
[31m-[m
[31m-				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );[m
[31m-[m
[31m-				var ext = extensions.get( 'OVR_multiview2' );[m
[31m-[m
[31m-				info.memory.textures += 2;[m
[31m-[m
[31m-				var colorTexture = _gl.createTexture();[m
[31m-				_gl.bindTexture( 35866, colorTexture );[m
[31m-				_gl.texParameteri( 35866, 10240, 9728 );[m
[31m-				_gl.texParameteri( 35866, 10241, 9728 );[m
[31m-				_gl.texImage3D( 35866, 0, 32856, width, height, numViews, 0, 6408, 5121, null );[m
[31m-				ext.framebufferTextureMultiviewOVR( 36160, 36064, colorTexture, 0, 0, numViews );[m
[31m-[m
[31m-				var depthStencilTexture = _gl.createTexture();[m
[31m-				_gl.bindTexture( 35866, depthStencilTexture );[m
[31m-				_gl.texParameteri( 35866, 10240, 9728 );[m
[31m-				_gl.texParameteri( 35866, 10241, 9728 );[m
[31m-				_gl.texImage3D( 35866, 0, 35056, width, height, numViews, 0, 34041, 34042, null );[m
[31m-				ext.framebufferTextureMultiviewOVR( 36160, 33306, depthStencilTexture, 0, 0, numViews );[m
[31m-[m
[31m-				var viewFramebuffers = new Array( numViews );[m
[31m-				for ( var i = 0; i < numViews; ++ i ) {[m
[31m-[m
[31m-					viewFramebuffers[ i ] = _gl.createFramebuffer();[m
[31m-					_gl.bindFramebuffer( 36160, viewFramebuffers[ i ] );[m
[31m-					_gl.framebufferTextureLayer( 36160, 36064, colorTexture, 0, i );[m
[31m-[m
[31m-				}[m
[31m-[m
[31m-				renderTargetProperties.__webglColorTexture = colorTexture;[m
[31m-				renderTargetProperties.__webglDepthStencilTexture = depthStencilTexture;[m
[31m-				renderTargetProperties.__webglViewFramebuffers = viewFramebuffers;[m
[31m-[m
[31m-				_gl.bindFramebuffer( 36160, null );[m
[31m-				_gl.bindTexture( 35866, null );[m
[31m-[m
 			}[m
 [m
 		}[m
[36m@@ -21913,7 +22386,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 			state.bindTexture( 34067, null );[m
 [m
[31m-		} else if ( ! isMultiview ) {[m
[32m+[m		[32m} else {[m
 [m
 			state.bindTexture( 3553, textureProperties.__webglTexture );[m
 			setTextureParameters( 3553, renderTarget.texture, supportsMips );[m
[36m@@ -21942,11 +22415,11 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 	function updateRenderTargetMipmap( renderTarget ) {[m
 [m
 		var texture = renderTarget.texture;[m
[31m-		var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;[m
[32m+[m		[32mvar supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;[m
 [m
 		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {[m
 [m
[31m-			var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;[m
[32m+[m			[32mvar target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;[m
 			var webglTexture = properties.get( texture ).__webglTexture;[m
 [m
 			state.bindTexture( target, webglTexture );[m
[36m@@ -21961,7 +22434,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		if ( renderTarget.isWebGLMultisampleRenderTarget ) {[m
 [m
[31m-			if ( capabilities.isWebGL2 ) {[m
[32m+[m			[32mif ( isWebGL2 ) {[m
 [m
 				var renderTargetProperties = properties.get( renderTarget );[m
 [m
[36m@@ -21977,6 +22450,8 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );[m
 [m
[32m+[m				[32m_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905[m
[32m+[m
 			} else {[m
 [m
 				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );[m
[36m@@ -21989,8 +22464,8 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 	function getRenderTargetSamples( renderTarget ) {[m
 [m
[31m-		return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?[m
[31m-			Math.min( capabilities.maxSamples, renderTarget.samples ) : 0;[m
[32m+[m		[32mreturn ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?[m
[32m+[m			[32mMath.min( maxSamples, renderTarget.samples ) : 0;[m
 [m
 	}[m
 [m
[36m@@ -22035,7 +22510,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 	function safeSetTextureCube( texture, slot ) {[m
 [m
[31m-		if ( texture && texture.isWebGLRenderTargetCube ) {[m
[32m+[m		[32mif ( texture && texture.isWebGLCubeRenderTarget ) {[m
 [m
 			if ( warnedTextureCube === false ) {[m
 [m
[36m@@ -22048,7 +22523,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		}[m
 [m
[31m-		// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture[m
[32m+[m		[32m// currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture[m
 		// TODO: unify these code paths[m
 		if ( ( texture && texture.isCubeTexture ) ||[m
 			( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {[m
[36m@@ -22060,7 +22535,7 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 		} else {[m
 [m
[31m-			// assumed: texture property of THREE.WebGLRenderTargetCube[m
[32m+[m			[32m// assumed: texture property of THREE.WebGLCubeRenderTarget[m
 			setTextureCubeDynamic( texture, slot );[m
 [m
 		}[m
[36m@@ -22092,22 +22567,12 @@[m [mfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils,[m
 [m
 function WebGLUtils( gl, extensions, capabilities ) {[m
 [m
[32m+[m	[32mvar isWebGL2 = capabilities.isWebGL2;[m
[32m+[m
 	function convert( p ) {[m
 [m
 		var extension;[m
 [m
[31m-		if ( p === RepeatWrapping ) return 10497;[m
[31m-		if ( p === ClampToEdgeWrapping ) return 33071;[m
[31m-		if ( p === MirroredRepeatWrapping ) return 33648;[m
[31m-[m
[31m-		if ( p === NearestFilter ) return 9728;[m
[31m-		if ( p === NearestMipmapNearestFilter ) return 9984;[m
[31m-		if ( p === NearestMipmapLinearFilter ) return 9986;[m
[31m-[m
[31m-		if ( p === LinearFilter ) return 9729;[m
[31m-		if ( p === LinearMipmapNearestFilter ) return 9985;[m
[31m-		if ( p === LinearMipmapLinearFilter ) return 9987;[m
[31m-[m
 		if ( p === UnsignedByteType ) return 5121;[m
 		if ( p === UnsignedShort4444Type ) return 32819;[m
 		if ( p === UnsignedShort5551Type ) return 32820;[m
[36m@@ -22122,11 +22587,19 @@[m [mfunction WebGLUtils( gl, extensions, capabilities ) {[m
 [m
 		if ( p === HalfFloatType ) {[m
 [m
[31m-			if ( capabilities.isWebGL2 ) return 5131;[m
[32m+[m			[32mif ( isWebGL2 ) return 5131;[m
 [m
 			extension = extensions.get( 'OES_texture_half_float' );[m
 [m
[31m-			if ( extension !== null ) return extension.HALF_FLOAT_OES;[m
[32m+[m			[32mif ( extension !== null ) {[m
[32m+[m
[32m+[m				[32mreturn extension.HALF_FLOAT_OES;[m
[32m+[m
[32m+[m			[32m} else {[m
[32m+[m
[32m+[m				[32mreturn null;[m
[32m+[m
[32m+[m			[32m}[m
 [m
 		}[m
 [m
[36m@@ -22139,22 +22612,13 @@[m [mfunction WebGLUtils( gl, extensions, capabilities ) {[m
 		if ( p === DepthStencilFormat ) return 34041;[m
 		if ( p === RedFormat ) return 6403;[m
 [m
[31m-		if ( p === AddEquation ) return 32774;[m
[31m-		if ( p === SubtractEquation ) return 32778;[m
[31m-		if ( p === ReverseSubtractEquation ) return 32779;[m
[31m-[m
[31m-		if ( p === ZeroFactor ) return 0;[m
[31m-		if ( p === OneFactor ) return 1;[m
[31m-		if ( p === SrcColorFactor ) return 768;[m
[31m-		if ( p === OneMinusSrcColorFactor ) return 769;[m
[31m-		if ( p === SrcAlphaFactor ) return 770;[m
[31m-		if ( p === OneMinusSrcAlphaFactor ) return 771;[m
[31m-		if ( p === DstAlphaFactor ) return 772;[m
[31m-		if ( p === OneMinusDstAlphaFactor ) return 773;[m
[32m+[m		[32m// WebGL2 formats.[m
 [m
[31m-		if ( p === DstColorFactor ) return 774;[m
[31m-		if ( p === OneMinusDstColorFactor ) return 775;[m
[31m-		if ( p === SrcAlphaSaturateFactor ) return 776;[m
[32m+[m		[32mif ( p === RedIntegerFormat ) return 36244;[m
[32m+[m		[32mif ( p === RGFormat ) return 33319;[m
[32m+[m		[32mif ( p === RGIntegerFormat ) return 33320;[m
[32m+[m		[32mif ( p === RGBIntegerFormat ) return 36248;[m
[32m+[m		[32mif ( p === RGBAIntegerFormat ) return 36249;[m
 [m
 		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||[m
 			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {[m
[36m@@ -22168,6 +22632,10 @@[m [mfunction WebGLUtils( gl, extensions, capabilities ) {[m
 				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;[m
 				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;[m
 [m
[32m+[m			[32m} else {[m
[32m+[m
[32m+[m				[32mreturn null;[m
[32m+[m
 			}[m
 [m
 		}[m
[36m@@ -22184,6 +22652,10 @@[m [mfunction WebGLUtils( gl, extensions, capabilities ) {[m
 				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;[m
 				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;[m
 [m
[32m+[m			[32m} else {[m
[32m+[m
[32m+[m				[32mreturn null;[m
[32m+[m
 			}[m
 [m
 		}[m
[36m@@ -22192,349 +22664,100 @@[m [mfunction WebGLUtils( gl, extensions, capabilities ) {[m
 [m
 			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );[m
 [m
[31m-			if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||[m
[31m-			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||[m
[31m-			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||[m
[31m-			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||[m
[31m-			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {[m
[32m+[m			[32mif ( extension !== null ) {[m
 [m
[31m-			extension = extensions.get( 'WEBGL_compressed_texture_astc' );[m
[32m+[m				[32mreturn extension.COMPRESSED_RGB_ETC1_WEBGL;[m
 [m
[31m-			if ( extension !== null ) {[m
[32m+[m			[32m} else {[m
 [m
[31m-				return p;[m
[32m+[m				[32mreturn null;[m
 [m
 			}[m
 [m
 		}[m
 [m
[31m-		if ( p === MinEquation || p === MaxEquation ) {[m
[31m-[m
[31m-			if ( capabilities.isWebGL2 ) {[m
[32m+[m		[32mif ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {[m
 [m
[31m-				if ( p === MinEquation ) return 32775;[m
[31m-				if ( p === MaxEquation ) return 32776;[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-			extension = extensions.get( 'EXT_blend_minmax' );[m
[32m+[m			[32mextension = extensions.get( 'WEBGL_compressed_texture_etc' );[m
 [m
 			if ( extension !== null ) {[m
 [m
[31m-				if ( p === MinEquation ) return extension.MIN_EXT;[m
[31m-				if ( p === MaxEquation ) return extension.MAX_EXT;[m
[32m+[m				[32mif ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;[m
[32m+[m				[32mif ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;[m
 [m
 			}[m
 [m
 		}[m
 [m
[31m-		if ( p === UnsignedInt248Type ) {[m
[31m-[m
[31m-			if ( capabilities.isWebGL2 ) return 34042;[m
[31m-[m
[31m-			extension = extensions.get( 'WEBGL_depth_texture' );[m
[31m-[m
[31m-			if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		return 0;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	return { convert: convert };[m
[31m-[m
[31m-}[m
[31m-[m
[31m-/**[m
[31m- * @author fernandojsg / http://fernandojsg.com[m
[31m- * @author Takahiro https://github.com/takahirox[m
[31m- */[m
[31m-[m
[31m-function WebGLMultiviewRenderTarget( width, height, numViews, options ) {[m
[31m-[m
[31m-	WebGLRenderTarget.call( this, width, height, options );[m
[31m-[m
[31m-	this.depthBuffer = false;[m
[31m-	this.stencilBuffer = false;[m
[31m-[m
[31m-	this.numViews = numViews;[m
[31m-[m
[31m-}[m
[31m-[m
[31m-WebGLMultiviewRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {[m
[31m-[m
[31m-	constructor: WebGLMultiviewRenderTarget,[m
[31m-[m
[31m-	isWebGLMultiviewRenderTarget: true,[m
[31m-[m
[31m-	copy: function ( source ) {[m
[31m-[m
[31m-		WebGLRenderTarget.prototype.copy.call( this, source );[m
[31m-[m
[31m-		this.numViews = source.numViews;[m
[31m-[m
[31m-		return this;[m
[31m-[m
[31m-	},[m
[31m-[m
[31m-	setNumViews: function ( numViews ) {[m
[31m-[m
[31m-		if ( this.numViews !== numViews ) {[m
[31m-[m
[31m-			this.numViews = numViews;[m
[31m-			this.dispose();[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		return this;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-} );[m
[31m-[m
[31m-/**[m
[31m- * @author fernandojsg / http://fernandojsg.com[m
[31m- * @author Takahiro https://github.com/takahirox[m
[31m- */[m
[31m-[m
[31m-function WebGLMultiview( renderer, gl ) {[m
[31m-[m
[31m-	var DEFAULT_NUMVIEWS = 2;[m
[31m-[m
[31m-	var extensions = renderer.extensions;[m
[31m-	var properties = renderer.properties;[m
[31m-[m
[31m-	var renderTarget, currentRenderTarget;[m
[31m-	var mat3, mat4, cameraArray, renderSize;[m
[31m-[m
[31m-	var available;[m
[31m-	var maxNumViews = 0;[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	function isAvailable() {[m
[31m-[m
[31m-		if ( available === undefined ) {[m
[31m-[m
[31m-			var extension = extensions.get( 'OVR_multiview2' );[m
[31m-[m
[31m-			available = extension !== null && gl.getContextAttributes().antialias === false;[m
[32m+[m		[32mif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||[m
[32m+[m			[32mp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||[m
[32m+[m			[32mp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||[m
[32m+[m			[32mp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||[m
[32m+[m			[32mp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||[m
[32m+[m			[32mp === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||[m
[32m+[m			[32mp === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||[m
[32m+[m			[32mp === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||[m
[32m+[m			[32mp === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||[m
[32m+[m			[32mp === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {[m
 [m
[31m-			if ( available ) {[m
[32m+[m			[32mextension = extensions.get( 'WEBGL_compressed_texture_astc' );[m
 [m
[31m-				maxNumViews = gl.getParameter( extension.MAX_VIEWS_OVR );[m
[31m-				renderTarget = new WebGLMultiviewRenderTarget( 0, 0, DEFAULT_NUMVIEWS );[m
[32m+[m			[32mif ( extension !== null ) {[m
 [m
[31m-				renderSize = new Vector2();[m
[31m-				mat4 = [];[m
[31m-				mat3 = [];[m
[31m-				cameraArray = [];[m
[32m+[m				[32m// TODO Complete?[m
 [m
[31m-				for ( var i = 0; i < maxNumViews; i ++ ) {[m
[32m+[m				[32mreturn p;[m
 [m
[31m-					mat4[ i ] = new Matrix4();[m
[31m-					mat3[ i ] = new Matrix3();[m
[32m+[m			[32m} else {[m
 [m
[31m-				}[m
[32m+[m				[32mreturn null;[m
 [m
 			}[m
 [m
 		}[m
 [m
[31m-		return available;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function getCameraArray( camera ) {[m
[31m-[m
[31m-		if ( camera.isArrayCamera ) return camera.cameras;[m
[31m-[m
[31m-		cameraArray[ 0 ] = camera;[m
[31m-[m
[31m-		return cameraArray;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function updateCameraProjectionMatricesUniform( camera, uniforms ) {[m
[31m-[m
[31m-		var cameras = getCameraArray( camera );[m
[31m-[m
[31m-		for ( var i = 0; i < cameras.length; i ++ ) {[m
[31m-[m
[31m-			mat4[ i ].copy( cameras[ i ].projectionMatrix );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		uniforms.setValue( gl, 'projectionMatrices', mat4 );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function updateCameraViewMatricesUniform( camera, uniforms ) {[m
[31m-[m
[31m-		var cameras = getCameraArray( camera );[m
[31m-[m
[31m-		for ( var i = 0; i < cameras.length; i ++ ) {[m
[31m-[m
[31m-			mat4[ i ].copy( cameras[ i ].matrixWorldInverse );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		uniforms.setValue( gl, 'viewMatrices', mat4 );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function updateObjectMatricesUniforms( object, camera, uniforms ) {[m
[31m-[m
[31m-		var cameras = getCameraArray( camera );[m
[31m-[m
[31m-		for ( var i = 0; i < cameras.length; i ++ ) {[m
[31m-[m
[31m-			mat4[ i ].multiplyMatrices( cameras[ i ].matrixWorldInverse, object.matrixWorld );[m
[31m-			mat3[ i ].getNormalMatrix( mat4[ i ] );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		uniforms.setValue( gl, 'modelViewMatrices', mat4 );[m
[31m-		uniforms.setValue( gl, 'normalMatrices', mat3 );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function isMultiviewCompatible( camera ) {[m
[31m-[m
[31m-		if ( camera.isArrayCamera === undefined ) return true;[m
[31m-[m
[31m-		var cameras = camera.cameras;[m
[31m-[m
[31m-		if ( cameras.length > maxNumViews ) return false;[m
[31m-[m
[31m-		for ( var i = 1, il = cameras.length; i < il; i ++ ) {[m
[31m-[m
[31m-			if ( cameras[ 0 ].viewport.z !== cameras[ i ].viewport.z ||[m
[31m-				cameras[ 0 ].viewport.w !== cameras[ i ].viewport.w ) return false;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		return true;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function resizeRenderTarget( camera ) {[m
[32m+[m		[32mif ( p === RGBA_BPTC_Format ) {[m
 [m
[31m-		if ( currentRenderTarget ) {[m
[32m+[m			[32mextension = extensions.get( 'EXT_texture_compression_bptc' );[m
 [m
[31m-			renderSize.set( currentRenderTarget.width, currentRenderTarget.height );[m
[31m-[m
[31m-		} else {[m
[31m-[m
[31m-			renderer.getDrawingBufferSize( renderSize );[m
[31m-[m
[31m-		}[m
[32m+[m			[32mif ( extension !== null ) {[m
 [m
[31m-		if ( camera.isArrayCamera ) {[m
[32m+[m				[32m// TODO Complete?[m
 [m
[31m-			var viewport = camera.cameras[ 0 ].viewport;[m
[32m+[m				[32mreturn p;[m
 [m
[31m-			renderTarget.setSize( viewport.z, viewport.w );[m
[31m-			renderTarget.setNumViews( camera.cameras.length );[m
[32m+[m			[32m} else {[m
 [m
[31m-		} else {[m
[32m+[m				[32mreturn null;[m
 [m
[31m-			renderTarget.setSize( renderSize.x, renderSize.y );[m
[31m-			renderTarget.setNumViews( DEFAULT_NUMVIEWS );[m
[32m+[m			[32m}[m
 [m
 		}[m
 [m
[31m-	}[m
[31m-[m
[31m-	function attachCamera( camera ) {[m
[31m-[m
[31m-		if ( isMultiviewCompatible( camera ) === false ) return;[m
[31m-[m
[31m-		currentRenderTarget = renderer.getRenderTarget();[m
[31m-		resizeRenderTarget( camera );[m
[31m-		renderer.setRenderTarget( renderTarget );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function detachCamera( camera ) {[m
[31m-[m
[31m-		if ( renderTarget !== renderer.getRenderTarget() ) return;[m
[31m-[m
[31m-		renderer.setRenderTarget( currentRenderTarget );[m
[31m-[m
[31m-		flush( camera );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function flush( camera ) {[m
[31m-[m
[31m-		var srcRenderTarget = renderTarget;[m
[31m-		var numViews = srcRenderTarget.numViews;[m
[31m-[m
[31m-		var srcFramebuffers = properties.get( srcRenderTarget ).__webglViewFramebuffers;[m
[32m+[m		[32mif ( p === UnsignedInt248Type ) {[m
 [m
[31m-		var viewWidth = srcRenderTarget.width;[m
[31m-		var viewHeight = srcRenderTarget.height;[m
[32m+[m			[32mif ( isWebGL2 ) return 34042;[m
 [m
[31m-		if ( camera.isArrayCamera ) {[m
[32m+[m			[32mextension = extensions.get( 'WEBGL_depth_texture' );[m
 [m
[31m-			for ( var i = 0; i < numViews; i ++ ) {[m
[32m+[m			[32mif ( extension !== null ) {[m
 [m
[31m-				var viewport = camera.cameras[ i ].viewport;[m
[32m+[m				[32mreturn extension.UNSIGNED_INT_24_8_WEBGL;[m
 [m
[31m-				var x1 = viewport.x;[m
[31m-				var y1 = viewport.y;[m
[31m-				var x2 = x1 + viewport.z;[m
[31m-				var y2 = y1 + viewport.w;[m
[32m+[m			[32m} else {[m
 [m
[31m-				gl.bindFramebuffer( 36008, srcFramebuffers[ i ] );[m
[31m-				gl.blitFramebuffer( 0, 0, viewWidth, viewHeight, x1, y1, x2, y2, 16384, 9728 );[m
[32m+[m				[32mreturn null;[m
 [m
 			}[m
 [m
[31m-		} else {[m
[31m-[m
[31m-			gl.bindFramebuffer( 36008, srcFramebuffers[ 0 ] );[m
[31m-			gl.blitFramebuffer( 0, 0, viewWidth, viewHeight, 0, 0, renderSize.x, renderSize.y, 16384, 9728 );[m
[31m-[m
 		}[m
 [m
 	}[m
 [m
[31m-	this.isAvailable = isAvailable;[m
[31m-	this.attachCamera = attachCamera;[m
[31m-	this.detachCamera = detachCamera;[m
[31m-	this.updateCameraProjectionMatricesUniform = updateCameraProjectionMatricesUniform;[m
[31m-	this.updateCameraViewMatricesUniform = updateCameraViewMatricesUniform;[m
[31m-	this.updateObjectMatricesUniforms = updateObjectMatricesUniforms;[m
[31m-[m
[31m-}[m
[31m-[m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- */[m
[31m-[m
[31m-function Group() {[m
[31m-[m
[31m-	Object3D.call( this );[m
[31m-[m
[31m-	this.type = 'Group';[m
[32m+[m	[32mreturn { convert: convert };[m
 [m
 }[m
 [m
[31m-Group.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
[31m-[m
[31m-	constructor: Group,[m
[31m-[m
[31m-	isGroup: true[m
[31m-[m
[31m-} );[m
[31m-[m
 /**[m
  * @author mrdoob / http://mrdoob.com/[m
  */[m
[36m@@ -22556,636 +22779,382 @@[m [mArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototyp[m
 } );[m
 [m
 /**[m
[31m- * @author jsantell / https://www.jsantell.com/[m
  * @author mrdoob / http://mrdoob.com/[m
  */[m
 [m
[31m-var cameraLPos = new Vector3();[m
[31m-var cameraRPos = new Vector3();[m
[31m-[m
[31m-/**[m
[31m- * Assumes 2 cameras that are parallel and share an X-axis, and that[m
[31m- * the cameras' projection and world matrices have already been set.[m
[31m- * And that near and far planes are identical for both cameras.[m
[31m- * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765[m
[31m- */[m
[31m-function setProjectionFromUnion( camera, cameraL, cameraR ) {[m
[31m-[m
[31m-	cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );[m
[31m-	cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );[m
[31m-[m
[31m-	var ipd = cameraLPos.distanceTo( cameraRPos );[m
[31m-[m
[31m-	var projL = cameraL.projectionMatrix.elements;[m
[31m-	var projR = cameraR.projectionMatrix.elements;[m
[32m+[m[32mfunction Group() {[m
 [m
[31m-	// VR systems will have identical far and near planes, and[m
[31m-	// most likely identical top and bottom frustum extents.[m
[31m-	// Use the left camera for these values.[m
[31m-	var near = projL[ 14 ] / ( projL[ 10 ] - 1 );[m
[31m-	var far = projL[ 14 ] / ( projL[ 10 ] + 1 );[m
[31m-	var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];[m
[31m-	var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];[m
[32m+[m	[32mObject3D.call( this );[m
 [m
[31m-	var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];[m
[31m-	var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];[m
[31m-	var left = near * leftFov;[m
[31m-	var right = near * rightFov;[m
[32m+[m	[32mthis.type = 'Group';[m
 [m
[31m-	// Calculate the new camera's position offset from the[m
[31m-	// left camera. xOffset should be roughly half `ipd`.[m
[31m-	var zOffset = ipd / ( - leftFov + rightFov );[m
[31m-	var xOffset = zOffset * - leftFov;[m
[32m+[m[32m}[m
 [m
[31m-	// TODO: Better way to apply this offset?[m
[31m-	cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );[m
[31m-	camera.translateX( xOffset );[m
[31m-	camera.translateZ( zOffset );[m
[31m-	camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );[m
[31m-	camera.matrixWorldInverse.getInverse( camera.matrixWorld );[m
[32m+[m[32mGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
[31m-	// Find the union of the frustum values of the cameras and scale[m
[31m-	// the values so that the near plane's position does not change in world space,[m
[31m-	// although must now be relative to the new union camera.[m
[31m-	var near2 = near + zOffset;[m
[31m-	var far2 = far + zOffset;[m
[31m-	var left2 = left - xOffset;[m
[31m-	var right2 = right + ( ipd - xOffset );[m
[31m-	var top2 = topFov * far / far2 * near2;[m
[31m-	var bottom2 = bottomFov * far / far2 * near2;[m
[32m+[m	[32mconstructor: Group,[m
 [m
[31m-	camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );[m
[32m+[m	[32misGroup: true[m
 [m
[31m-}[m
[32m+[m[32m} );[m
 [m
 /**[m
  * @author mrdoob / http://mrdoob.com/[m
  */[m
 [m
[31m-function WebVRManager( renderer ) {[m
[32m+[m[32mfunction WebXRManager( renderer, gl ) {[m
 [m
[31m-	var renderWidth, renderHeight;[m
 	var scope = this;[m
 [m
[31m-	var device = null;[m
[31m-	var frameData = null;[m
[31m-[m
[31m-	var poseTarget = null;[m
[31m-[m
[31m-	var controllers = [];[m
[31m-	var standingMatrix = new Matrix4();[m
[31m-	var standingMatrixInverse = new Matrix4();[m
[32m+[m	[32mvar session = null;[m
 [m
 	var framebufferScaleFactor = 1.0;[m
 [m
[32m+[m	[32mvar referenceSpace = null;[m
 	var referenceSpaceType = 'local-floor';[m
 [m
[31m-	if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {[m
[31m-[m
[31m-		frameData = new window.VRFrameData();[m
[31m-		window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );[m
[32m+[m	[32mvar pose = null;[m
 [m
[31m-	}[m
[32m+[m	[32mvar controllers = [];[m
[32m+[m	[32mvar inputSourcesMap = new Map();[m
 [m
[31m-	var matrixWorldInverse = new Matrix4();[m
[31m-	var tempQuaternion = new Quaternion();[m
[31m-	var tempPosition = new Vector3();[m
[32m+[m	[32m//[m
 [m
 	var cameraL = new PerspectiveCamera();[m
[31m-	cameraL.viewport = new Vector4();[m
 	cameraL.layers.enable( 1 );[m
[32m+[m	[32mcameraL.viewport = new Vector4();[m
 [m
 	var cameraR = new PerspectiveCamera();[m
[31m-	cameraR.viewport = new Vector4();[m
 	cameraR.layers.enable( 2 );[m
[32m+[m	[32mcameraR.viewport = new Vector4();[m
 [m
 	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );[m
 	cameraVR.layers.enable( 1 );[m
 	cameraVR.layers.enable( 2 );[m
 [m
[31m-	//[m
[31m-[m
[31m-	function isPresenting() {[m
[31m-[m
[31m-		return device !== null && device.isPresenting === true;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	var currentSize = new Vector2(), currentPixelRatio;[m
[31m-[m
[31m-	function onVRDisplayPresentChange() {[m
[31m-[m
[31m-		if ( isPresenting() ) {[m
[31m-[m
[31m-			var eyeParameters = device.getEyeParameters( 'left' );[m
[31m-			renderWidth = 2 * eyeParameters.renderWidth * framebufferScaleFactor;[m
[31m-			renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;[m
[31m-[m
[31m-			currentPixelRatio = renderer.getPixelRatio();[m
[31m-			renderer.getSize( currentSize );[m
[31m-[m
[31m-			renderer.setDrawingBufferSize( renderWidth, renderHeight, 1 );[m
[31m-[m
[31m-			cameraL.viewport.set( 0, 0, renderWidth / 2, renderHeight );[m
[31m-			cameraR.viewport.set( renderWidth / 2, 0, renderWidth / 2, renderHeight );[m
[31m-[m
[31m-			animation.start();[m
[31m-[m
[31m-			scope.dispatchEvent( { type: 'sessionstart' } );[m
[31m-[m
[31m-		} else {[m
[31m-[m
[31m-			if ( scope.enabled ) {[m
[31m-[m
[31m-				renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-			animation.stop();[m
[31m-[m
[31m-			scope.dispatchEvent( { type: 'sessionend' } );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[32m+[m	[32mvar _currentDepthNear = null;[m
[32m+[m	[32mvar _currentDepthFar = null;[m
 [m
 	//[m
 [m
[31m-	var triggers = [];[m
[31m-[m
[31m-	function findGamepad( id ) {[m
[31m-[m
[31m-		var gamepads = navigator.getGamepads && navigator.getGamepads();[m
[31m-[m
[31m-		for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {[m
[31m-[m
[31m-			var gamepad = gamepads[ i ];[m
[31m-[m
[31m-			if ( gamepad && ( gamepad.id === 'Daydream Controller' ||[m
[31m-				gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||[m
[31m-				gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||[m
[31m-				gamepad.id.startsWith( 'HTC Vive Focus' ) ||[m
[31m-				gamepad.id.startsWith( 'Spatial Controller' ) ) ) {[m
[31m-[m
[31m-				if ( j === id ) return gamepad;[m
[31m-[m
[31m-				j ++;[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	function updateControllers() {[m
[31m-[m
[31m-		for ( var i = 0; i < controllers.length; i ++ ) {[m
[31m-[m
[31m-			var controller = controllers[ i ];[m
[31m-[m
[31m-			var gamepad = findGamepad( i );[m
[31m-[m
[31m-			if ( gamepad !== undefined && gamepad.pose !== undefined ) {[m
[31m-[m
[31m-				if ( gamepad.pose === null ) return;[m
[31m-[m
[31m-				// Pose[m
[31m-[m
[31m-				var pose = gamepad.pose;[m
[31m-[m
[31m-				if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );[m
[31m-[m
[31m-				if ( pose.position !== null ) controller.position.fromArray( pose.position );[m
[31m-				if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );[m
[31m-				controller.matrix.compose( controller.position, controller.quaternion, controller.scale );[m
[31m-				controller.matrix.premultiply( standingMatrix );[m
[31m-				controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );[m
[31m-				controller.matrixWorldNeedsUpdate = true;[m
[31m-				controller.visible = true;[m
[31m-[m
[31m-				// Trigger[m
[31m-[m
[31m-				var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;[m
[31m-[m
[31m-				if ( triggers[ i ] === undefined ) triggers[ i ] = false;[m
[31m-[m
[31m-				if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {[m
[31m-[m
[31m-					triggers[ i ] = gamepad.buttons[ buttonId ].pressed;[m
[31m-[m
[31m-					if ( triggers[ i ] === true ) {[m
[31m-[m
[31m-						controller.dispatchEvent( { type: 'selectstart' } );[m
[31m-[m
[31m-					} else {[m
[31m-[m
[31m-						controller.dispatchEvent( { type: 'selectend' } );[m
[31m-						controller.dispatchEvent( { type: 'select' } );[m
[32m+[m	[32mthis.enabled = false;[m
 [m
[31m-					}[m
[32m+[m	[32mthis.isPresenting = false;[m
 [m
[31m-				}[m
[32m+[m	[32mthis.getController = function ( id ) {[m
 [m
[31m-			} else {[m
[32m+[m		[32mvar controller = controllers[ id ];[m
 [m
[31m-				controller.visible = false;[m
[32m+[m		[32mif ( controller === undefined ) {[m
 [m
[31m-			}[m
[32m+[m			[32mcontroller = {};[m
[32m+[m			[32mcontrollers[ id ] = controller;[m
 [m
 		}[m
 [m
[31m-	}[m
[31m-[m
[31m-	function updateViewportFromBounds( viewport, bounds ) {[m
[32m+[m		[32mif ( controller.targetRay === undefined ) {[m
 [m
[31m-		if ( bounds !== null && bounds.length === 4 ) {[m
[31m-[m
[31m-			viewport.set( bounds[ 0 ] * renderWidth, bounds[ 1 ] * renderHeight, bounds[ 2 ] * renderWidth, bounds[ 3 ] * renderHeight );[m
[32m+[m			[32mcontroller.targetRay = new Group();[m
[32m+[m			[32mcontroller.targetRay.matrixAutoUpdate = false;[m
[32m+[m			[32mcontroller.targetRay.visible = false;[m
 [m
 		}[m
 [m
[31m-	}[m
[32m+[m		[32mreturn controller.targetRay;[m
 [m
[31m-	//[m
[31m-[m
[31m-	this.enabled = false;[m
[32m+[m	[32m};[m
 [m
[31m-	this.getController = function ( id ) {[m
[32m+[m	[32mthis.getControllerGrip = function ( id ) {[m
 [m
 		var controller = controllers[ id ];[m
 [m
 		if ( controller === undefined ) {[m
 [m
[31m-			controller = new Group();[m
[31m-			controller.matrixAutoUpdate = false;[m
[31m-			controller.visible = false;[m
[31m-[m
[32m+[m			[32mcontroller = {};[m
 			controllers[ id ] = controller;[m
 [m
 		}[m
 [m
[31m-		return controller;[m
[32m+[m		[32mif ( controller.grip === undefined ) {[m
 [m
[31m-	};[m
[32m+[m			[32mcontroller.grip = new Group();[m
[32m+[m			[32mcontroller.grip.matrixAutoUpdate = false;[m
[32m+[m			[32mcontroller.grip.visible = false;[m
 [m
[31m-	this.getDevice = function () {[m
[31m-[m
[31m-		return device;[m
[31m-[m
[31m-	};[m
[31m-[m
[31m-	this.setDevice = function ( value ) {[m
[31m-[m
[31m-		if ( value !== undefined ) device = value;[m
[31m-[m
[31m-		animation.setContext( value );[m
[31m-[m
[31m-	};[m
[31m-[m
[31m-	this.setFramebufferScaleFactor = function ( value ) {[m
[32m+[m		[32m}[m
 [m
[31m-		framebufferScaleFactor = value;[m
[32m+[m		[32mreturn controller.grip;[m
 [m
 	};[m
 [m
[31m-	this.setReferenceSpaceType = function ( value ) {[m
[31m-[m
[31m-		referenceSpaceType = value;[m
[32m+[m	[32m//[m
 [m
[31m-	};[m
[32m+[m	[32mfunction onSessionEvent( event ) {[m
 [m
[31m-	this.setPoseTarget = function ( object ) {[m
[32m+[m		[32mvar controller = inputSourcesMap.get( event.inputSource );[m
 [m
[31m-		if ( object !== undefined ) poseTarget = object;[m
[32m+[m		[32mif ( controller ) {[m
 [m
[31m-	};[m
[32m+[m			[32mif ( controller.targetRay ) {[m
 [m
[31m-	this.getCamera = function ( camera ) {[m
[32m+[m				[32mcontroller.targetRay.dispatchEvent( { type: event.type } );[m
 [m
[31m-		var userHeight = referenceSpaceType === 'local-floor' ? 1.6 : 0;[m
[32m+[m			[32m}[m
 [m
[31m-		if ( isPresenting() === false ) {[m
[32m+[m			[32mif ( controller.grip ) {[m
 [m
[31m-			camera.position.set( 0, userHeight, 0 );[m
[31m-			camera.rotation.set( 0, 0, 0 );[m
[32m+[m				[32mcontroller.grip.dispatchEvent( { type: event.type } );[m
 [m
[31m-			return camera;[m
[32m+[m			[32m}[m
 [m
 		}[m
 [m
[31m-		device.depthNear = camera.near;[m
[31m-		device.depthFar = camera.far;[m
[31m-[m
[31m-		device.getFrameData( frameData );[m
[31m-[m
[31m-		//[m
[31m-[m
[31m-		if ( referenceSpaceType === 'local-floor' ) {[m
[31m-[m
[31m-			var stageParameters = device.stageParameters;[m
[32m+[m	[32m}[m
 [m
[31m-			if ( stageParameters ) {[m
[32m+[m	[32mfunction onSessionEnd() {[m
 [m
[31m-				standingMatrix.fromArray( stageParameters.sittingToStandingTransform );[m
[32m+[m		[32minputSourcesMap.forEach( function ( controller, inputSource ) {[m
 [m
[31m-			} else {[m
[32m+[m			[32mif ( controller.targetRay ) {[m
 [m
[31m-				standingMatrix.makeTranslation( 0, userHeight, 0 );[m
[32m+[m				[32mcontroller.targetRay.dispatchEvent( { type: 'disconnected', data: inputSource } );[m
[32m+[m				[32mcontroller.targetRay.visible = false;[m
 [m
 			}[m
 [m
[31m-		}[m
[31m-[m
[31m-[m
[31m-		var pose = frameData.pose;[m
[31m-		var poseObject = poseTarget !== null ? poseTarget : camera;[m
[32m+[m			[32mif ( controller.grip ) {[m
 [m
[31m-		// We want to manipulate poseObject by its position and quaternion components since users may rely on them.[m
[31m-		poseObject.matrix.copy( standingMatrix );[m
[31m-		poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );[m
[32m+[m				[32mcontroller.grip.dispatchEvent( { type: 'disconnected', data: inputSource } );[m
[32m+[m				[32mcontroller.grip.visible = false;[m
 [m
[31m-		if ( pose.orientation !== null ) {[m
[31m-[m
[31m-			tempQuaternion.fromArray( pose.orientation );[m
[31m-			poseObject.quaternion.multiply( tempQuaternion );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		if ( pose.position !== null ) {[m
[31m-[m
[31m-			tempQuaternion.setFromRotationMatrix( standingMatrix );[m
[31m-			tempPosition.fromArray( pose.position );[m
[31m-			tempPosition.applyQuaternion( tempQuaternion );[m
[31m-			poseObject.position.add( tempPosition );[m
[32m+[m			[32m}[m
 [m
[31m-		}[m
[32m+[m		[32m} );[m
 [m
[31m-		poseObject.updateMatrixWorld();[m
[32m+[m		[32minputSourcesMap.clear();[m
 [m
 		//[m
 [m
[31m-		cameraL.near = camera.near;[m
[31m-		cameraR.near = camera.near;[m
[31m-[m
[31m-		cameraL.far = camera.far;[m
[31m-		cameraR.far = camera.far;[m
[31m-[m
[31m-		cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );[m
[31m-		cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );[m
[31m-[m
[31m-		// TODO (mrdoob) Double check this code[m
[31m-[m
[31m-		standingMatrixInverse.getInverse( standingMatrix );[m
[31m-[m
[31m-		if ( referenceSpaceType === 'local-floor' ) {[m
[31m-[m
[31m-			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );[m
[31m-			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		var parent = poseObject.parent;[m
[32m+[m		[32mrenderer.setFramebuffer( null );[m
[32m+[m		[32mrenderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830[m
[32m+[m		[32manimation.stop();[m
 [m
[31m-		if ( parent !== null ) {[m
[32m+[m		[32mscope.isPresenting = false;[m
 [m
[31m-			matrixWorldInverse.getInverse( parent.matrixWorld );[m
[32m+[m		[32mscope.dispatchEvent( { type: 'sessionend' } );[m
 [m
[31m-			cameraL.matrixWorldInverse.multiply( matrixWorldInverse );[m
[31m-			cameraR.matrixWorldInverse.multiply( matrixWorldInverse );[m
[32m+[m	[32m}[m
 [m
[31m-		}[m
[32m+[m	[32mfunction onRequestReferenceSpace( value ) {[m
 [m
[31m-		// envMap and Mirror needs camera.matrixWorld[m
[32m+[m		[32mreferenceSpace = value;[m
 [m
[31m-		cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );[m
[31m-		cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );[m
[32m+[m		[32manimation.setContext( session );[m
[32m+[m		[32manimation.start();[m
 [m
[31m-		cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );[m
[31m-		cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );[m
[32m+[m		[32mscope.isPresenting = true;[m
 [m
[31m-		setProjectionFromUnion( cameraVR, cameraL, cameraR );[m
[32m+[m		[32mscope.dispatchEvent( { type: 'sessionstart' } );[m
 [m
[31m-		//[m
[32m+[m	[32m}[m
 [m
[31m-		var layers = device.getLayers();[m
[32m+[m	[32mthis.setFramebufferScaleFactor = function ( value ) {[m
 [m
[31m-		if ( layers.length ) {[m
[32m+[m		[32mframebufferScaleFactor = value;[m
 [m
[31m-			var layer = layers[ 0 ];[m
[32m+[m		[32m// Warn if function is used while presenting[m
[32m+[m		[32mif ( scope.isPresenting == true ) {[m
 [m
[31m-			updateViewportFromBounds( cameraL.viewport, layer.leftBounds );[m
[31m-			updateViewportFromBounds( cameraR.viewport, layer.rightBounds );[m
[32m+[m			[32mconsole.warn( "WebXRManager: Cannot change framebuffer scale while presenting VR content" );[m
 [m
 		}[m
 [m
[31m-		updateControllers();[m
[31m-[m
[31m-		return cameraVR;[m
[31m-[m
[31m-	};[m
[31m-[m
[31m-	this.getStandingMatrix = function () {[m
[31m-[m
[31m-		return standingMatrix;[m
[31m-[m
[31m-	};[m
[31m-[m
[31m-	this.isPresenting = isPresenting;[m
[31m-[m
[31m-	// Animation Loop[m
[31m-[m
[31m-	var animation = new WebGLAnimation();[m
[31m-[m
[31m-	this.setAnimationLoop = function ( callback ) {[m
[31m-[m
[31m-		animation.setAnimationLoop( callback );[m
[31m-[m
[31m-		if ( isPresenting() ) animation.start();[m
[31m-[m
 	};[m
 [m
[31m-	this.submitFrame = function () {[m
[32m+[m	[32mthis.setReferenceSpaceType = function ( value ) {[m
 [m
[31m-		if ( isPresenting() ) device.submitFrame();[m
[32m+[m		[32mreferenceSpaceType = value;[m
 [m
 	};[m
 [m
[31m-	this.dispose = function () {[m
[32m+[m	[32mthis.getReferenceSpace = function () {[m
 [m
[31m-		if ( typeof window !== 'undefined' ) {[m
[31m-[m
[31m-			window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );[m
[31m-[m
[31m-		}[m
[32m+[m		[32mreturn referenceSpace;[m
 [m
 	};[m
 [m
[31m-	// DEPRECATED[m
[31m-[m
[31m-	this.setFrameOfReferenceType = function () {[m
[32m+[m	[32mthis.getSession = function () {[m
 [m
[31m-		console.warn( 'THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.' );[m
[32m+[m		[32mreturn session;[m
 [m
 	};[m
 [m
[31m-}[m
[31m-[m
[31m-Object.assign( WebVRManager.prototype, EventDispatcher.prototype );[m
[31m-[m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- */[m
[31m-[m
[31m-function WebXRManager( renderer, gl ) {[m
[31m-[m
[31m-	var scope = this;[m
[31m-[m
[31m-	var session = null;[m
[31m-[m
[31m-	// var framebufferScaleFactor = 1.0;[m
[31m-[m
[31m-	var referenceSpace = null;[m
[31m-	var referenceSpaceType = 'local-floor';[m
[31m-[m
[31m-	var pose = null;[m
[31m-[m
[31m-	var controllers = [];[m
[31m-	var inputSources = [];[m
[31m-[m
[31m-	function isPresenting() {[m
[31m-[m
[31m-		return session !== null && referenceSpace !== null;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	//[m
[32m+[m	[32mthis.setSession = function ( value ) {[m
 [m
[31m-	var cameraL = new PerspectiveCamera();[m
[31m-	cameraL.layers.enable( 1 );[m
[31m-	cameraL.viewport = new Vector4();[m
[32m+[m		[32msession = value;[m
 [m
[31m-	var cameraR = new PerspectiveCamera();[m
[31m-	cameraR.layers.enable( 2 );[m
[31m-	cameraR.viewport = new Vector4();[m
[32m+[m		[32mif ( session !== null ) {[m
 [m
[31m-	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );[m
[31m-	cameraVR.layers.enable( 1 );[m
[31m-	cameraVR.layers.enable( 2 );[m
[32m+[m			[32msession.addEventListener( 'select', onSessionEvent );[m
[32m+[m			[32msession.addEventListener( 'selectstart', onSessionEvent );[m
[32m+[m			[32msession.addEventListener( 'selectend', onSessionEvent );[m
[32m+[m			[32msession.addEventListener( 'squeeze', onSessionEvent );[m
[32m+[m			[32msession.addEventListener( 'squeezestart', onSessionEvent );[m
[32m+[m			[32msession.addEventListener( 'squeezeend', onSessionEvent );[m
[32m+[m			[32msession.addEventListener( 'end', onSessionEnd );[m
 [m
[31m-	//[m
[32m+[m			[32mvar attributes = gl.getContextAttributes();[m
 [m
[31m-	this.enabled = false;[m
[32m+[m			[32mvar layerInit = {[m
[32m+[m				[32mantialias: attributes.antialias,[m
[32m+[m				[32malpha: attributes.alpha,[m
[32m+[m				[32mdepth: attributes.depth,[m
[32m+[m				[32mstencil: attributes.stencil,[m
[32m+[m				[32mframebufferScaleFactor: framebufferScaleFactor[m
[32m+[m			[32m};[m
 [m
[31m-	this.getController = function ( id ) {[m
[32m+[m			[32m// eslint-disable-next-line no-undef[m
[32m+[m			[32mvar baseLayer = new XRWebGLLayer( session, gl, layerInit );[m
 [m
[31m-		var controller = controllers[ id ];[m
[32m+[m			[32msession.updateRenderState( { baseLayer: baseLayer } );[m
 [m
[31m-		if ( controller === undefined ) {[m
[32m+[m			[32msession.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );[m
 [m
[31m-			controller = new Group();[m
[31m-			controller.matrixAutoUpdate = false;[m
[31m-			controller.visible = false;[m
[32m+[m			[32m//[m
 [m
[31m-			controllers[ id ] = controller;[m
[32m+[m			[32msession.addEventListener( 'inputsourceschange', updateInputSources );[m
 [m
 		}[m
 [m
[31m-		return controller;[m
[31m-[m
 	};[m
 [m
[31m-	//[m
[31m-[m
[31m-	function onSessionEvent( event ) {[m
[32m+[m	[32mfunction updateInputSources( event ) {[m
 [m
[31m-		for ( var i = 0; i < controllers.length; i ++ ) {[m
[32m+[m		[32mvar inputSources = session.inputSources;[m
 [m
[31m-			if ( inputSources[ i ] === event.inputSource ) {[m
[32m+[m		[32m// Assign inputSources to available controllers[m
 [m
[31m-				controllers[ i ].dispatchEvent( { type: event.type } );[m
[32m+[m		[32mfor ( var i = 0; i < controllers.length; i ++ ) {[m
 [m
[31m-			}[m
[32m+[m			[32minputSourcesMap.set( inputSources[ i ], controllers[ i ] );[m
 [m
 		}[m
 [m
[31m-	}[m
[32m+[m		[32m// Notify disconnected[m
 [m
[31m-	function onSessionEnd() {[m
[32m+[m		[32mfor ( var i = 0; i < event.removed.length; i ++ ) {[m
 [m
[31m-		renderer.setFramebuffer( null );[m
[31m-		renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830[m
[31m-		animation.stop();[m
[32m+[m			[32mvar inputSource = event.removed[ i ];[m
[32m+[m			[32mvar controller = inputSourcesMap.get( inputSource );[m
 [m
[31m-		scope.dispatchEvent( { type: 'sessionend' } );[m
[31m-[m
[31m-	}[m
[32m+[m			[32mif ( controller ) {[m
 [m
[31m-	function onRequestReferenceSpace( value ) {[m
[31m-[m
[31m-		referenceSpace = value;[m
[32m+[m				[32mif ( controller.targetRay ) {[m
 [m
[31m-		animation.setContext( session );[m
[31m-		animation.start();[m
[32m+[m					[32mcontroller.targetRay.dispatchEvent( { type: 'disconnected', data: inputSource } );[m
 [m
[31m-		scope.dispatchEvent( { type: 'sessionstart' } );[m
[32m+[m				[32m}[m
 [m
[31m-	}[m
[32m+[m				[32mif ( controller.grip ) {[m
 [m
[31m-	this.setFramebufferScaleFactor = function ( /* value */ ) {[m
[32m+[m					[32mcontroller.grip.dispatchEvent( { type: 'disconnected', data: inputSource } );[m
 [m
[31m-		// framebufferScaleFactor = value;[m
[32m+[m				[32m}[m
 [m
[31m-	};[m
[32m+[m				[32minputSourcesMap.delete( inputSource );[m
 [m
[31m-	this.setReferenceSpaceType = function ( value ) {[m
[32m+[m			[32m}[m
 [m
[31m-		referenceSpaceType = value;[m
[32m+[m		[32m}[m
 [m
[31m-	};[m
[32m+[m		[32m// Notify connected[m
 [m
[31m-	this.getSession = function () {[m
[32m+[m		[32mfor ( var i = 0; i < event.added.length; i ++ ) {[m
 [m
[31m-		return session;[m
[32m+[m			[32mvar inputSource = event.added[ i ];[m
[32m+[m			[32mvar controller = inputSourcesMap.get( inputSource );[m
 [m
[31m-	};[m
[32m+[m			[32mif ( controller ) {[m
 [m
[31m-	this.setSession = function ( value ) {[m
[32m+[m				[32mif ( controller.targetRay ) {[m
 [m
[31m-		session = value;[m
[32m+[m					[32mcontroller.targetRay.dispatchEvent( { type: 'connected', data: inputSource } );[m
 [m
[31m-		if ( session !== null ) {[m
[32m+[m				[32m}[m
 [m
[31m-			session.addEventListener( 'select', onSessionEvent );[m
[31m-			session.addEventListener( 'selectstart', onSessionEvent );[m
[31m-			session.addEventListener( 'selectend', onSessionEvent );[m
[31m-			session.addEventListener( 'end', onSessionEnd );[m
[32m+[m				[32mif ( controller.grip ) {[m
 [m
[31m-			// eslint-disable-next-line no-undef[m
[31m-			session.updateRenderState( { baseLayer: new XRWebGLLayer( session, gl ) } );[m
[32m+[m					[32mcontroller.grip.dispatchEvent( { type: 'connected', data: inputSource } );[m
 [m
[31m-			session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );[m
[31m-[m
[31m-			//[m
[32m+[m				[32m}[m
 [m
[31m-			inputSources = session.inputSources;[m
[32m+[m			[32m}[m
 [m
[31m-			session.addEventListener( 'inputsourceschange', function () {[m
[32m+[m		[32m}[m
 [m
[31m-				inputSources = session.inputSources;[m
[31m-				console.log( inputSources );[m
[32m+[m	[32m}[m
 [m
[31m-				for ( var i = 0; i < controllers.length; i ++ ) {[m
[32m+[m	[32m//[m
 [m
[31m-					var controller = controllers[ i ];[m
[31m-					controller.userData.inputSource = inputSources[ i ];[m
[32m+[m	[32mvar cameraLPos = new Vector3();[m
[32m+[m	[32mvar cameraRPos = new Vector3();[m
 [m
[31m-				}[m
[32m+[m	[32m/**[m
[32m+[m	[32m * @author jsantell / https://www.jsantell.com/[m
[32m+[m	[32m *[m
[32m+[m	[32m * Assumes 2 cameras that are parallel and share an X-axis, and that[m
[32m+[m	[32m * the cameras' projection and world matrices have already been set.[m
[32m+[m	[32m * And that near and far planes are identical for both cameras.[m
[32m+[m	[32m * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765[m
[32m+[m	[32m */[m
[32m+[m	[32mfunction setProjectionFromUnion( camera, cameraL, cameraR ) {[m
[32m+[m
[32m+[m		[32mcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );[m
[32m+[m		[32mcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );[m
[32m+[m
[32m+[m		[32mvar ipd = cameraLPos.distanceTo( cameraRPos );[m
[32m+[m
[32m+[m		[32mvar projL = cameraL.projectionMatrix.elements;[m
[32m+[m		[32mvar projR = cameraR.projectionMatrix.elements;[m
[32m+[m
[32m+[m		[32m// VR systems will have identical far and near planes, and[m
[32m+[m		[32m// most likely identical top and bottom frustum extents.[m
[32m+[m		[32m// Use the left camera for these values.[m
[32m+[m		[32mvar near = projL[ 14 ] / ( projL[ 10 ] - 1 );[m
[32m+[m		[32mvar far = projL[ 14 ] / ( projL[ 10 ] + 1 );[m
[32m+[m		[32mvar topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];[m
[32m+[m		[32mvar bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];[m
[32m+[m
[32m+[m		[32mvar leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];[m
[32m+[m		[32mvar rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];[m
[32m+[m		[32mvar left = near * leftFov;[m
[32m+[m		[32mvar right = near * rightFov;[m
[32m+[m
[32m+[m		[32m// Calculate the new camera's position offset from the[m
[32m+[m		[32m// left camera. xOffset should be roughly half `ipd`.[m
[32m+[m		[32mvar zOffset = ipd / ( - leftFov + rightFov );[m
[32m+[m		[32mvar xOffset = zOffset * - leftFov;[m
[32m+[m
[32m+[m		[32m// TODO: Better way to apply this offset?[m
[32m+[m		[32mcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );[m
[32m+[m		[32mcamera.translateX( xOffset );[m
[32m+[m		[32mcamera.translateZ( zOffset );[m
[32m+[m		[32mcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );[m
[32m+[m		[32mcamera.matrixWorldInverse.getInverse( camera.matrixWorld );[m
 [m
[31m-			} );[m
[32m+[m		[32m// Find the union of the frustum values of the cameras and scale[m
[32m+[m		[32m// the values so that the near plane's position does not change in world space,[m
[32m+[m		[32m// although must now be relative to the new union camera.[m
[32m+[m		[32mvar near2 = near + zOffset;[m
[32m+[m		[32mvar far2 = far + zOffset;[m
[32m+[m		[32mvar left2 = left - xOffset;[m
[32m+[m		[32mvar right2 = right + ( ipd - xOffset );[m
[32m+[m		[32mvar top2 = topFov * far / far2 * near2;[m
[32m+[m		[32mvar bottom2 = bottomFov * far / far2 * near2;[m
 [m
[31m-		}[m
[32m+[m		[32mcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );[m
 [m
[31m-	};[m
[32m+[m	[32m}[m
 [m
 	function updateCamera( camera, parent ) {[m
 [m
[36m@@ -23205,43 +23174,52 @@[m [mfunction WebXRManager( renderer, gl ) {[m
 [m
 	this.getCamera = function ( camera ) {[m
 [m
[31m-		if ( isPresenting() ) {[m
[32m+[m		[32mcameraVR.near = cameraR.near = cameraL.near = camera.near;[m
[32m+[m		[32mcameraVR.far = cameraR.far = cameraL.far = camera.far;[m
 [m
[31m-			var parent = camera.parent;[m
[31m-			var cameras = cameraVR.cameras;[m
[32m+[m		[32mif ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {[m
 [m
[31m-			updateCamera( cameraVR, parent );[m
[32m+[m			[32m// Note that the new renderState won't apply until the next frame. See #18320[m
 [m
[31m-			for ( var i = 0; i < cameras.length; i ++ ) {[m
[32m+[m			[32msession.updateRenderState( {[m
[32m+[m				[32mdepthNear: cameraVR.near,[m
[32m+[m				[32mdepthFar: cameraVR.far[m
[32m+[m			[32m} );[m
 [m
[31m-				updateCamera( cameras[ i ], parent );[m
[32m+[m			[32m_currentDepthNear = cameraVR.near;[m
[32m+[m			[32m_currentDepthFar = cameraVR.far;[m
 [m
[31m-			}[m
[32m+[m		[32m}[m
 [m
[31m-			// update camera and its children[m
[32m+[m		[32mvar parent = camera.parent;[m
[32m+[m		[32mvar cameras = cameraVR.cameras;[m
 [m
[31m-			camera.matrixWorld.copy( cameraVR.matrixWorld );[m
[32m+[m		[32mupdateCamera( cameraVR, parent );[m
 [m
[31m-			var children = camera.children;[m
[32m+[m		[32mfor ( var i = 0; i < cameras.length; i ++ ) {[m
 [m
[31m-			for ( var i = 0, l = children.length; i < l; i ++ ) {[m
[32m+[m			[32mupdateCamera( cameras[ i ], parent );[m
 [m
[31m-				children[ i ].updateMatrixWorld( true );[m
[32m+[m		[32m}[m
 [m
[31m-			}[m
[32m+[m		[32m// update camera and its children[m
[32m+[m
[32m+[m		[32mcamera.matrixWorld.copy( cameraVR.matrixWorld );[m
 [m
[31m-			setProjectionFromUnion( cameraVR, cameraL, cameraR );[m
[32m+[m		[32mvar children = camera.children;[m
 [m
[31m-			return cameraVR;[m
[32m+[m		[32mfor ( var i = 0, l = children.length; i < l; i ++ ) {[m
[32m+[m
[32m+[m			[32mchildren[ i ].updateMatrixWorld( true );[m
 [m
 		}[m
 [m
[31m-		return camera;[m
[32m+[m		[32msetProjectionFromUnion( cameraVR, cameraL, cameraR );[m
[32m+[m
[32m+[m		[32mreturn cameraVR;[m
 [m
 	};[m
 [m
[31m-	this.isPresenting = isPresenting;[m
[31m-[m
 	// Animation Loop[m
 [m
 	var onAnimationFrameCallback = null;[m
[36m@@ -23261,10 +23239,9 @@[m [mfunction WebXRManager( renderer, gl ) {[m
 [m
 				var view = views[ i ];[m
 				var viewport = baseLayer.getViewport( view );[m
[31m-				var viewMatrix = view.transform.inverse.matrix;[m
 [m
 				var camera = cameraVR.cameras[ i ];[m
[31m-				camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );[m
[32m+[m				[32mcamera.matrix.fromArray( view.transform.matrix );[m
 				camera.projectionMatrix.fromArray( view.projectionMatrix );[m
 				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );[m
 [m
[36m@@ -23280,75 +23257,75 @@[m [mfunction WebXRManager( renderer, gl ) {[m
 [m
 		//[m
 [m
[32m+[m		[32mvar inputSources = session.inputSources;[m
[32m+[m
 		for ( var i = 0; i < controllers.length; i ++ ) {[m
 [m
 			var controller = controllers[ i ];[m
 [m
 			var inputSource = inputSources[ i ];[m
 [m
[32m+[m			[32mvar inputPose = null;[m
[32m+[m			[32mvar gripPose = null;[m
[32m+[m
 			if ( inputSource ) {[m
 [m
[31m-				var inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );[m
[32m+[m				[32mif ( controller.targetRay ) {[m
 [m
[31m-				if ( inputPose !== null ) {[m
[32m+[m					[32minputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );[m
 [m
[31m-					controller.matrix.fromArray( inputPose.transform.matrix );[m
[31m-					controller.matrix.decompose( controller.position, controller.rotation, controller.scale );[m
[31m-					controller.visible = true;[m
[32m+[m					[32mif ( inputPose !== null ) {[m
 [m
[31m-					continue;[m
[32m+[m						[32mcontroller.targetRay.matrix.fromArray( inputPose.transform.matrix );[m
[32m+[m						[32mcontroller.targetRay.matrix.decompose( controller.targetRay.position, controller.targetRay.rotation, controller.targetRay.scale );[m
 [m
[31m-				}[m
[32m+[m					[32m}[m
 [m
[31m-			}[m
[32m+[m				[32m}[m
 [m
[31m-			controller.visible = false;[m
[32m+[m				[32mif ( controller.grip && inputSource.gripSpace ) {[m
 [m
[31m-		}[m
[32m+[m					[32mgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );[m
 [m
[31m-		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );[m
[32m+[m					[32mif ( gripPose !== null ) {[m
 [m
[31m-	}[m
[32m+[m						[32mcontroller.grip.matrix.fromArray( gripPose.transform.matrix );[m
[32m+[m						[32mcontroller.grip.matrix.decompose( controller.grip.position, controller.grip.rotation, controller.grip.scale );[m
 [m
[31m-	var animation = new WebGLAnimation();[m
[31m-	animation.setAnimationLoop( onAnimationFrame );[m
[31m-[m
[31m-	this.setAnimationLoop = function ( callback ) {[m
[31m-[m
[31m-		onAnimationFrameCallback = callback;[m
[32m+[m					[32m}[m
 [m
[31m-	};[m
[32m+[m				[32m}[m
 [m
[31m-	this.dispose = function () {};[m
[32m+[m			[32m}[m
 [m
[31m-	// DEPRECATED[m
[32m+[m			[32mif ( controller.targetRay ) {[m
 [m
[31m-	this.getStandingMatrix = function () {[m
[32m+[m				[32mcontroller.targetRay.visible = inputPose !== null;[m
 [m
[31m-		console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );[m
[31m-		return new Matrix4();[m
[32m+[m			[32m}[m
 [m
[31m-	};[m
[32m+[m			[32mif ( controller.grip ) {[m
 [m
[31m-	this.getDevice = function () {[m
[32m+[m				[32mcontroller.grip.visible = gripPose !== null;[m
 [m
[31m-		console.warn( 'THREE.WebXRManager: getDevice() has been deprecated.' );[m
[32m+[m			[32m}[m
 [m
[31m-	};[m
[32m+[m		[32m}[m
 [m
[31m-	this.setDevice = function () {[m
[32m+[m		[32mif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );[m
 [m
[31m-		console.warn( 'THREE.WebXRManager: setDevice() has been deprecated.' );[m
[32m+[m	[32m}[m
 [m
[31m-	};[m
[32m+[m	[32mvar animation = new WebGLAnimation();[m
[32m+[m	[32manimation.setAnimationLoop( onAnimationFrame );[m
 [m
[31m-	this.setFrameOfReferenceType = function () {[m
[32m+[m	[32mthis.setAnimationLoop = function ( callback ) {[m
 [m
[31m-		console.warn( 'THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.' );[m
[32m+[m		[32monAnimationFrameCallback = callback;[m
 [m
 	};[m
 [m
[31m-	this.submitFrame = function () {};[m
[32m+[m	[32mthis.dispose = function () {};[m
 [m
 }[m
 [m
[36m@@ -23414,8 +23391,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 	// physically based shading[m
 [m
 	this.gammaFactor = 2.0;	// for backwards compatibility[m
[31m-	this.gammaInput = false;[m
[31m-	this.gammaOutput = false;[m
[32m+[m	[32mthis.outputEncoding = LinearEncoding;[m
 [m
 	// physical lights[m
 [m
[36m@@ -23469,6 +23445,8 @@[m [mfunction WebGLRenderer( parameters ) {[m
 		_height = _canvas.height,[m
 [m
 		_pixelRatio = 1,[m
[32m+[m		[32m_opaqueSort = null,[m
[32m+[m		[32m_transparentSort = null,[m
 [m
 		_viewport = new Vector4( 0, 0, _width, _height ),[m
 		_scissor = new Vector4( 0, 0, _width, _height ),[m
[36m@@ -23584,14 +23562,14 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		utils = new WebGLUtils( _gl, extensions, capabilities );[m
 [m
[31m-		state = new WebGLState( _gl, extensions, utils, capabilities );[m
[32m+[m		[32mstate = new WebGLState( _gl, extensions, capabilities );[m
 		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );[m
 		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );[m
 [m
 		info = new WebGLInfo( _gl );[m
 		properties = new WebGLProperties();[m
 		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );[m
[31m-		attributes = new WebGLAttributes( _gl );[m
[32m+[m		[32mattributes = new WebGLAttributes( _gl, capabilities );[m
 		geometries = new WebGLGeometries( _gl, attributes, info );[m
 		objects = new WebGLObjects( _gl, geometries, attributes, info );[m
 		morphtargets = new WebGLMorphtargets( _gl );[m
[36m@@ -23617,15 +23595,11 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	initGLContext();[m
 [m
[31m-	// vr[m
[32m+[m	[32m// xr[m
 [m
[31m-	var vr = ( typeof navigator !== 'undefined' && 'xr' in navigator && 'supportsSession' in navigator.xr ) ? new WebXRManager( _this, _gl ) : new WebVRManager( _this );[m
[32m+[m	[32mvar xr = new WebXRManager( _this, _gl );[m
 [m
[31m-	this.vr = vr;[m
[31m-[m
[31m-	// Multiview[m
[31m-[m
[31m-	var multiview = new WebGLMultiview( _this, _gl );[m
[32m+[m	[32mthis.xr = xr;[m
 [m
 	// shadow map[m
 [m
[36m@@ -23693,7 +23667,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	this.setSize = function ( width, height, updateStyle ) {[m
 [m
[31m-		if ( vr.isPresenting() ) {[m
[32m+[m		[32mif ( xr.isPresenting ) {[m
 [m
 			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );[m
 			return;[m
[36m@@ -23815,6 +23789,18 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	};[m
 [m
[32m+[m	[32mthis.setOpaqueSort = function ( method ) {[m
[32m+[m
[32m+[m		[32m_opaqueSort = method;[m
[32m+[m
[32m+[m	[32m};[m
[32m+[m
[32m+[m	[32mthis.setTransparentSort = function ( method ) {[m
[32m+[m
[32m+[m		[32m_transparentSort = method;[m
[32m+[m
[32m+[m	[32m};[m
[32m+[m
 	// Clearing[m
 [m
 	this.getClearColor = function () {[m
[36m@@ -23883,10 +23869,12 @@[m [mfunction WebGLRenderer( parameters ) {[m
 		properties.dispose();[m
 		objects.dispose();[m
 [m
[31m-		vr.dispose();[m
[32m+[m		[32mxr.dispose();[m
 [m
 		animation.stop();[m
 [m
[32m+[m		[32mthis.forceContextLoss();[m
[32m+[m
 	};[m
 [m
 	// Events[m
[36m@@ -24019,13 +24007,17 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	};[m
 [m
[31m-	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {[m
[32m+[m	[32mvar tempScene = new Scene();[m
[32m+[m
[32m+[m	[32mthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {[m
[32m+[m
[32m+[m		[32mif ( scene === null ) scene = tempScene; // renderBufferDirect second parameter used to be fog (could be null)[m
 [m
 		var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );[m
 [m
[31m-		state.setMaterial( material, frontFaceCW );[m
[32m+[m		[32mvar program = setProgram( camera, scene, material, object );[m
 [m
[31m-		var program = setProgram( camera, fog, material, object );[m
[32m+[m		[32mstate.setMaterial( material, frontFaceCW );[m
 [m
 		var updateBuffers = false;[m
 [m
[36m@@ -24040,7 +24032,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[31m-		if ( object.morphTargetInfluences ) {[m
[32m+[m		[32mif ( material.morphTargets || material.morphNormals ) {[m
 [m
 			morphtargets.update( object, geometry, material, program );[m
 [m
[36m@@ -24052,6 +24044,21 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		var index = geometry.index;[m
 		var position = geometry.attributes.position;[m
[32m+[m
[32m+[m		[32m//[m
[32m+[m
[32m+[m		[32mif ( index === null ) {[m
[32m+[m
[32m+[m			[32mif ( position === undefined || position.count === 0 ) return;[m
[32m+[m
[32m+[m		[32m} else if ( index.count === 0 ) {[m
[32m+[m
[32m+[m			[32mreturn;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32m//[m
[32m+[m
 		var rangeFactor = 1;[m
 [m
 		if ( material.wireframe === true ) {[m
[36m@@ -24087,17 +24094,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		//[m
 [m
[31m-		var dataCount = Infinity;[m
[31m-[m
[31m-		if ( index !== null ) {[m
[31m-[m
[31m-			dataCount = index.count;[m
[31m-[m
[31m-		} else if ( position !== undefined ) {[m
[31m-[m
[31m-			dataCount = position.count;[m
[31m-[m
[31m-		}[m
[32m+[m		[32mvar dataCount = ( index !== null ) ? index.count : position.count;[m
 [m
 		var rangeStart = geometry.drawRange.start * rangeFactor;[m
 		var rangeCount = geometry.drawRange.count * rangeFactor;[m
[36m@@ -24123,21 +24120,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 			} else {[m
 [m
[31m-				switch ( object.drawMode ) {[m
[31m-[m
[31m-					case TrianglesDrawMode:[m
[31m-						renderer.setMode( 4 );[m
[31m-						break;[m
[31m-[m
[31m-					case TriangleStripDrawMode:[m
[31m-						renderer.setMode( 5 );[m
[31m-						break;[m
[31m-[m
[31m-					case TriangleFanDrawMode:[m
[31m-						renderer.setMode( 6 );[m
[31m-						break;[m
[31m-[m
[31m-				}[m
[32m+[m				[32mrenderer.setMode( 4 );[m
 [m
 			}[m
 [m
[36m@@ -24361,6 +24344,8 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		currentRenderState.setupLights( camera );[m
 [m
[32m+[m		[32mvar compiled = {};[m
[32m+[m
 		scene.traverse( function ( object ) {[m
 [m
 			if ( object.material ) {[m
[36m@@ -24369,13 +24354,19 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 					for ( var i = 0; i < object.material.length; i ++ ) {[m
 [m
[31m-						initMaterial( object.material[ i ], scene.fog, object );[m
[32m+[m						[32mif ( object.material[ i ].uuid in compiled === false ) {[m
[32m+[m
[32m+[m							[32minitMaterial( object.material[ i ], scene, object );[m
[32m+[m							[32mcompiled[ object.material[ i ].uuid ] = true;[m
[32m+[m
[32m+[m						[32m}[m
 [m
 					}[m
 [m
[31m-				} else {[m
[32m+[m				[32m} else if ( object.material.uuid in compiled === false ) {[m
 [m
[31m-					initMaterial( object.material, scene.fog, object );[m
[32m+[m					[32minitMaterial( object.material, scene, object );[m
[32m+[m					[32mcompiled[ object.material.uuid ] = true;[m
 [m
 				}[m
 [m
[36m@@ -24391,7 +24382,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	function onAnimationFrame( time ) {[m
 [m
[31m-		if ( vr.isPresenting() ) return;[m
[32m+[m		[32mif ( xr.isPresenting ) return;[m
 		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );[m
 [m
 	}[m
[36m@@ -24404,7 +24395,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 	this.setAnimationLoop = function ( callback ) {[m
 [m
 		onAnimationFrameCallback = callback;[m
[31m-		vr.setAnimationLoop( callback );[m
[32m+[m		[32mxr.setAnimationLoop( callback );[m
 [m
 		animation.start();[m
 [m
[36m@@ -24455,21 +24446,20 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		if ( camera.parent === null ) camera.updateMatrixWorld();[m
 [m
[31m-		if ( vr.enabled ) {[m
[32m+[m		[32mif ( xr.enabled && xr.isPresenting ) {[m
 [m
[31m-			camera = vr.getCamera( camera );[m
[32m+[m			[32mcamera = xr.getCamera( camera );[m
 [m
 		}[m
 [m
 		//[m
[32m+[m		[32mscene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );[m
 [m
 		currentRenderState = renderStates.get( scene, camera );[m
 		currentRenderState.init();[m
 [m
[31m-		scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );[m
[31m-[m
 		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );[m
[31m-		_frustum.setFromMatrix( _projScreenMatrix );[m
[32m+[m		[32m_frustum.setFromProjectionMatrix( _projScreenMatrix );[m
 [m
 		_localClippingEnabled = this.localClippingEnabled;[m
 		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );[m
[36m@@ -24479,9 +24469,11 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		projectObject( scene, camera, 0, _this.sortObjects );[m
 [m
[32m+[m		[32mcurrentRenderList.finish();[m
[32m+[m
 		if ( _this.sortObjects === true ) {[m
 [m
[31m-			currentRenderList.sort();[m
[32m+[m			[32mcurrentRenderList.sort( _opaqueSort, _transparentSort );[m
 [m
 		}[m
 [m
[36m@@ -24507,12 +24499,6 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[31m-		if ( vr.enabled && multiview.isAvailable() ) {[m
[31m-[m
[31m-			multiview.attachCamera( camera );[m
[31m-[m
[31m-		}[m
[31m-[m
 		//[m
 [m
 		background.render( currentRenderList, scene, camera, forceClear );[m
[36m@@ -24567,18 +24553,6 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		state.setPolygonOffset( false );[m
 [m
[31m-		if ( vr.enabled ) {[m
[31m-[m
[31m-			if ( multiview.isAvailable() ) {[m
[31m-[m
[31m-				multiview.detachCamera( camera );[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-			vr.submitFrame();[m
[31m-[m
[31m-		}[m
[31m-[m
 		// _gl.finish();[m
 [m
 		currentRenderList = null;[m
[36m@@ -24726,27 +24700,19 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 				_currentArrayCamera = camera;[m
 [m
[31m-				if ( vr.enabled && multiview.isAvailable() ) {[m
[32m+[m				[32mvar cameras = camera.cameras;[m
 [m
[31m-					renderObject( object, scene, camera, geometry, material, group );[m
[31m-[m
[31m-				} else {[m
[32m+[m				[32mfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {[m
 [m
[31m-					var cameras = camera.cameras;[m
[32m+[m					[32mvar camera2 = cameras[ j ];[m
 [m
[31m-					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {[m
[32m+[m					[32mif ( object.layers.test( camera2.layers ) ) {[m
 [m
[31m-						var camera2 = cameras[ j ];[m
[32m+[m						[32mstate.viewport( _currentViewport.copy( camera2.viewport ) );[m
 [m
[31m-						if ( object.layers.test( camera2.layers ) ) {[m
[32m+[m						[32mcurrentRenderState.setupLights( camera2 );[m
 [m
[31m-							state.viewport( _currentViewport.copy( camera2.viewport ) );[m
[31m-[m
[31m-							currentRenderState.setupLights( camera2 );[m
[31m-[m
[31m-							renderObject( object, scene, camera2, geometry, material, group );[m
[31m-[m
[31m-						}[m
[32m+[m						[32mrenderObject( object, scene, camera2, geometry, material, group );[m
 [m
 					}[m
 [m
[36m@@ -24774,9 +24740,9 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		if ( object.isImmediateRenderObject ) {[m
 [m
[31m-			state.setMaterial( material );[m
[32m+[m			[32mvar program = setProgram( camera, scene, material, object );[m
 [m
[31m-			var program = setProgram( camera, scene.fog, material, object );[m
[32m+[m			[32mstate.setMaterial( material );[m
 [m
 			_currentGeometryProgram.geometry = null;[m
 			_currentGeometryProgram.program = null;[m
[36m@@ -24786,7 +24752,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		} else {[m
 [m
[31m-			_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );[m
[32m+[m			[32m_this.renderBufferDirect( camera, scene, geometry, material, object, group );[m
 [m
 		}[m
 [m
[36m@@ -24795,7 +24761,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	}[m
 [m
[31m-	function initMaterial( material, fog, object ) {[m
[32m+[m	[32mfunction initMaterial( material, scene, object ) {[m
 [m
 		var materialProperties = properties.get( material );[m
 [m
[36m@@ -24804,10 +24770,8 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		var lightsStateVersion = lights.state.version;[m
 [m
[31m-		var parameters = programCache.getParameters([m
[31m-			material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );[m
[31m-[m
[31m-		var code = programCache.getProgramCode( material, parameters );[m
[32m+[m		[32mvar parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object );[m
[32m+[m		[32mvar programCacheKey = programCache.getProgramCacheKey( parameters );[m
 [m
 		var program = materialProperties.program;[m
 		var programChange = true;[m
[36m@@ -24817,7 +24781,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 			// new material[m
 			material.addEventListener( 'dispose', onMaterialDispose );[m
 [m
[31m-		} else if ( program.code !== code ) {[m
[32m+[m		[32m} else if ( program.cacheKey !== programCacheKey ) {[m
 [m
 			// changed glsl or parameters[m
 			releaseMaterialProgramReference( material );[m
[36m@@ -24842,36 +24806,12 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		if ( programChange ) {[m
 [m
[31m-			if ( parameters.shaderID ) {[m
[31m-[m
[31m-				var shader = ShaderLib[ parameters.shaderID ];[m
[31m-[m
[31m-				materialProperties.shader = {[m
[31m-					name: material.type,[m
[31m-					uniforms: cloneUniforms( shader.uniforms ),[m
[31m-					vertexShader: shader.vertexShader,[m
[31m-					fragmentShader: shader.fragmentShader[m
[31m-				};[m
[31m-[m
[31m-			} else {[m
[31m-[m
[31m-				materialProperties.shader = {[m
[31m-					name: material.type,[m
[31m-					uniforms: material.uniforms,[m
[31m-					vertexShader: material.vertexShader,[m
[31m-					fragmentShader: material.fragmentShader[m
[31m-				};[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-			material.onBeforeCompile( materialProperties.shader, _this );[m
[31m-[m
[31m-			// Computing code again as onBeforeCompile may have changed the shaders[m
[31m-			code = programCache.getProgramCode( material, parameters );[m
[31m-[m
[31m-			program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );[m
[32m+[m			[32mprogram = programCache.acquireProgram( parameters, programCacheKey );[m
 [m
 			materialProperties.program = program;[m
[32m+[m			[32mmaterialProperties.uniforms = parameters.uniforms;[m
[32m+[m			[32mmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;[m
[32m+[m			[32mmaterialProperties.outputEncoding = _this.outputEncoding;[m
 			material.program = program;[m
 [m
 		}[m
[36m@@ -24910,7 +24850,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[31m-		var uniforms = materialProperties.shader.uniforms;[m
[32m+[m		[32mvar uniforms = materialProperties.uniforms;[m
 [m
 		if ( ! material.isShaderMaterial &&[m
 			! material.isRawShaderMaterial ||[m
[36m@@ -24922,7 +24862,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[31m-		materialProperties.fog = fog;[m
[32m+[m		[32mmaterialProperties.fog = scene.fog;[m
 [m
 		// store the light setup it was created for[m
 [m
[36m@@ -24936,9 +24876,12 @@[m [mfunction WebGLRenderer( parameters ) {[m
 			uniforms.ambientLightColor.value = lights.state.ambient;[m
 			uniforms.lightProbe.value = lights.state.probe;[m
 			uniforms.directionalLights.value = lights.state.directional;[m
[32m+[m			[32muniforms.directionalLightShadows.value = lights.state.directionalShadow;[m
 			uniforms.spotLights.value = lights.state.spot;[m
[32m+[m			[32muniforms.spotLightShadows.value = lights.state.spotShadow;[m
 			uniforms.rectAreaLights.value = lights.state.rectArea;[m
 			uniforms.pointLights.value = lights.state.point;[m
[32m+[m			[32muniforms.pointLightShadows.value = lights.state.pointShadow;[m
 			uniforms.hemisphereLights.value = lights.state.hemi;[m
 [m
 			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;[m
[36m@@ -24959,10 +24902,13 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	}[m
 [m
[31m-	function setProgram( camera, fog, material, object ) {[m
[32m+[m	[32mfunction setProgram( camera, scene, material, object ) {[m
 [m
 		textures.resetTextureUnits();[m
 [m
[32m+[m		[32mvar fog = scene.fog;[m
[32m+[m		[32mvar environment = material.isMeshStandardMaterial ? scene.environment : null;[m
[32m+[m
 		var materialProperties = properties.get( material );[m
 		var lights = currentRenderState.state.lights;[m
 [m
[36m@@ -24985,34 +24931,40 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[31m-		if ( material.needsUpdate === false ) {[m
[32m+[m		[32mif ( material.version === materialProperties.__version ) {[m
 [m
 			if ( materialProperties.program === undefined ) {[m
 [m
[31m-				material.needsUpdate = true;[m
[32m+[m				[32minitMaterial( material, scene, object );[m
 [m
 			} else if ( material.fog && materialProperties.fog !== fog ) {[m
 [m
[31m-				material.needsUpdate = true;[m
[32m+[m				[32minitMaterial( material, scene, object );[m
[32m+[m
[32m+[m			[32m} else if ( materialProperties.environment !== environment ) {[m
[32m+[m
[32m+[m				[32minitMaterial( material, scene, object );[m
 [m
 			} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {[m
 [m
[31m-				material.needsUpdate = true;[m
[32m+[m				[32minitMaterial( material, scene, object );[m
 [m
 			} else if ( materialProperties.numClippingPlanes !== undefined &&[m
 				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||[m
 				materialProperties.numIntersection !== _clipping.numIntersection ) ) {[m
 [m
[31m-				material.needsUpdate = true;[m
[32m+[m				[32minitMaterial( material, scene, object );[m
 [m
[31m-			}[m
[32m+[m			[32m} else if ( materialProperties.outputEncoding !== _this.outputEncoding ) {[m
 [m
[31m-		}[m
[32m+[m				[32minitMaterial( material, scene, object );[m
 [m
[31m-		if ( material.needsUpdate ) {[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m} else {[m
 [m
[31m-			initMaterial( material, fog, object );[m
[31m-			material.needsUpdate = false;[m
[32m+[m			[32minitMaterial( material, scene, object );[m
[32m+[m			[32mmaterialProperties.__version = material.version;[m
 [m
 		}[m
 [m
[36m@@ -25022,7 +24974,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		var program = materialProperties.program,[m
 			p_uniforms = program.getUniforms(),[m
[31m-			m_uniforms = materialProperties.shader.uniforms;[m
[32m+[m			[32mm_uniforms = materialProperties.uniforms;[m
 [m
 		if ( state.useProgram( program.program ) ) {[m
 [m
[36m@@ -25042,15 +24994,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		if ( refreshProgram || _currentCamera !== camera ) {[m
 [m
[31m-			if ( program.numMultiviewViews > 0 ) {[m
[31m-[m
[31m-				multiview.updateCameraProjectionMatricesUniform( camera, p_uniforms );[m
[31m-[m
[31m-			} else {[m
[31m-[m
[31m-				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );[m
[31m-[m
[31m-			}[m
[32m+[m			[32mp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );[m
 [m
 			if ( capabilities.logarithmicDepthBuffer ) {[m
 [m
[36m@@ -25077,6 +25021,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 			if ( material.isShaderMaterial ||[m
 				material.isMeshPhongMaterial ||[m
[32m+[m				[32mmaterial.isMeshToonMaterial ||[m
 				material.isMeshStandardMaterial ||[m
 				material.envMap ) {[m
 [m
[36m@@ -25092,21 +25037,25 @@[m [mfunction WebGLRenderer( parameters ) {[m
 			}[m
 [m
 			if ( material.isMeshPhongMaterial ||[m
[32m+[m				[32mmaterial.isMeshToonMaterial ||[m
 				material.isMeshLambertMaterial ||[m
 				material.isMeshBasicMaterial ||[m
 				material.isMeshStandardMaterial ||[m
[31m-				material.isShaderMaterial ||[m
[31m-				material.skinning ) {[m
[32m+[m				[32mmaterial.isShaderMaterial ) {[m
 [m
[31m-				if ( program.numMultiviewViews > 0 ) {[m
[32m+[m				[32mp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );[m
 [m
[31m-					multiview.updateCameraViewMatricesUniform( camera, p_uniforms );[m
[31m-[m
[31m-				} else {[m
[32m+[m			[32m}[m
 [m
[31m-					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );[m
[32m+[m			[32mif ( material.isMeshPhongMaterial ||[m
[32m+[m				[32mmaterial.isMeshToonMaterial ||[m
[32m+[m				[32mmaterial.isMeshLambertMaterial ||[m
[32m+[m				[32mmaterial.isMeshBasicMaterial ||[m
[32m+[m				[32mmaterial.isMeshStandardMaterial ||[m
[32m+[m				[32mmaterial.isShaderMaterial ||[m
[32m+[m				[32mmaterial.skinning ) {[m
 [m
[31m-				}[m
[32m+[m				[32mp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );[m
 [m
 			}[m
 [m
[36m@@ -25114,7 +25063,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		// skinning uniforms must be set even if material didn't change[m
 		// auto-setting of texture unit for bone texture must go before other textures[m
[31m-		// not sure why, but otherwise weird things happen[m
[32m+[m		[32m// otherwise textures used for skinning can take over texture units reserved for other material textures[m
 [m
 		if ( material.skinning ) {[m
 [m
[36m@@ -25140,7 +25089,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 [m
 						var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix[m
[31m-						size = _Math.ceilPowerOfTwo( size );[m
[32m+[m						[32msize = MathUtils.ceilPowerOfTwo( size );[m
 						size = Math.max( size, 4 );[m
 [m
 						var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel[m
[36m@@ -25211,38 +25160,33 @@[m [mfunction WebGLRenderer( parameters ) {[m
 				refreshUniformsCommon( m_uniforms, material );[m
 				refreshUniformsLambert( m_uniforms, material );[m
 [m
[31m-			} else if ( material.isMeshPhongMaterial ) {[m
[32m+[m			[32m} else if ( material.isMeshToonMaterial ) {[m
 [m
 				refreshUniformsCommon( m_uniforms, material );[m
[32m+[m				[32mrefreshUniformsToon( m_uniforms, material );[m
 [m
[31m-				if ( material.isMeshToonMaterial ) {[m
[31m-[m
[31m-					refreshUniformsToon( m_uniforms, material );[m
[31m-[m
[31m-				} else {[m
[31m-[m
[31m-					refreshUniformsPhong( m_uniforms, material );[m
[32m+[m			[32m} else if ( material.isMeshPhongMaterial ) {[m
 [m
[31m-				}[m
[32m+[m				[32mrefreshUniformsCommon( m_uniforms, material );[m
[32m+[m				[32mrefreshUniformsPhong( m_uniforms, material );[m
 [m
 			} else if ( material.isMeshStandardMaterial ) {[m
 [m
[31m-				refreshUniformsCommon( m_uniforms, material );[m
[32m+[m				[32mrefreshUniformsCommon( m_uniforms, material, environment );[m
 [m
 				if ( material.isMeshPhysicalMaterial ) {[m
 [m
[31m-					refreshUniformsPhysical( m_uniforms, material );[m
[32m+[m					[32mrefreshUniformsPhysical( m_uniforms, material, environment );[m
 [m
 				} else {[m
 [m
[31m-					refreshUniformsStandard( m_uniforms, material );[m
[32m+[m					[32mrefreshUniformsStandard( m_uniforms, material, environment );[m
 [m
 				}[m
 [m
 			} else if ( material.isMeshMatcapMaterial ) {[m
 [m
 				refreshUniformsCommon( m_uniforms, material );[m
[31m-[m
 				refreshUniformsMatcap( m_uniforms, material );[m
 [m
 			} else if ( material.isMeshDepthMaterial ) {[m
[36m@@ -25293,6 +25237,12 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );[m
 [m
[32m+[m			[32mif ( material.isShaderMaterial ) {[m
[32m+[m
[32m+[m				[32mmaterial.uniformsNeedUpdate = false; // #15581[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
 		}[m
 [m
 		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {[m
[36m@@ -25310,17 +25260,8 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		// common matrices[m
 [m
[31m-		if ( program.numMultiviewViews > 0 ) {[m
[31m-[m
[31m-			multiview.updateObjectMatricesUniforms( object, camera, p_uniforms );[m
[31m-[m
[31m-		} else {[m
[31m-[m
[31m-			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );[m
[31m-			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );[m
[31m-[m
[31m-		}[m
[31m-[m
[32m+[m		[32mp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );[m
[32m+[m		[32mp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );[m
 		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );[m
 [m
 		return program;[m
[36m@@ -25329,7 +25270,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	// Uniforms (refresh uniforms objects)[m
 [m
[31m-	function refreshUniformsCommon( uniforms, material ) {[m
[32m+[m	[32mfunction refreshUniformsCommon( uniforms, material, environment ) {[m
 [m
 		uniforms.opacity.value = material.opacity;[m
 [m
[36m@@ -25363,20 +25304,18 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[31m-		if ( material.envMap ) {[m
[32m+[m		[32mvar envMap = material.envMap || environment;[m
[32m+[m
[32m+[m		[32mif ( envMap ) {[m
 [m
[31m-			uniforms.envMap.value = material.envMap;[m
[32m+[m			[32muniforms.envMap.value = envMap;[m
 [m
[31m-			// don't flip CubeTexture envMaps, flip everything else:[m
[31m-			//  WebGLRenderTargetCube will be flipped for backwards compatibility[m
[31m-			//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture[m
[31m-			// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future[m
[31m-			uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;[m
[32m+[m			[32muniforms.flipEnvMap.value = envMap.isCubeTexture ? - 1 : 1;[m
 [m
 			uniforms.reflectivity.value = material.reflectivity;[m
 			uniforms.refractionRatio.value = material.refractionRatio;[m
 [m
[31m-			uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;[m
[32m+[m			[32muniforms.maxMipLevel.value = properties.get( envMap ).__maxMipLevel;[m
 [m
 		}[m
 [m
[36m@@ -25461,6 +25400,41 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[32m+[m		[32m// uv repeat and offset setting priorities for uv2[m
[32m+[m		[32m// 1. ao map[m
[32m+[m		[32m// 2. light map[m
[32m+[m
[32m+[m		[32mvar uv2ScaleMap;[m
[32m+[m
[32m+[m		[32mif ( material.aoMap ) {[m
[32m+[m
[32m+[m			[32muv2ScaleMap = material.aoMap;[m
[32m+[m
[32m+[m		[32m} else if ( material.lightMap ) {[m
[32m+[m
[32m+[m			[32muv2ScaleMap = material.lightMap;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( uv2ScaleMap !== undefined ) {[m
[32m+[m
[32m+[m			[32m// backwards compatibility[m
[32m+[m			[32mif ( uv2ScaleMap.isWebGLRenderTarget ) {[m
[32m+[m
[32m+[m				[32muv2ScaleMap = uv2ScaleMap.texture;[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mif ( uv2ScaleMap.matrixAutoUpdate === true ) {[m
[32m+[m
[32m+[m				[32muv2ScaleMap.updateMatrix();[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32muniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 	}[m
 [m
 	function refreshUniformsLine( uniforms, material ) {[m
[36m@@ -25485,17 +25459,43 @@[m [mfunction WebGLRenderer( parameters ) {[m
 		uniforms.size.value = material.size * _pixelRatio;[m
 		uniforms.scale.value = _height * 0.5;[m
 [m
[31m-		uniforms.map.value = material.map;[m
[32m+[m		[32mif ( material.map ) {[m
 [m
[31m-		if ( material.map !== null ) {[m
[32m+[m			[32muniforms.map.value = material.map;[m
 [m
[31m-			if ( material.map.matrixAutoUpdate === true ) {[m
[32m+[m		[32m}[m
 [m
[31m-				material.map.updateMatrix();[m
[32m+[m		[32mif ( material.alphaMap ) {[m
[32m+[m
[32m+[m			[32muniforms.alphaMap.value = material.alphaMap;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32m// uv repeat and offset setting priorities[m
[32m+[m		[32m// 1. color map[m
[32m+[m		[32m// 2. alpha map[m
[32m+[m
[32m+[m		[32mvar uvScaleMap;[m
[32m+[m
[32m+[m		[32mif ( material.map ) {[m
[32m+[m
[32m+[m			[32muvScaleMap = material.map;[m
[32m+[m
[32m+[m		[32m} else if ( material.alphaMap ) {[m
[32m+[m
[32m+[m			[32muvScaleMap = material.alphaMap;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( uvScaleMap !== undefined ) {[m
[32m+[m
[32m+[m			[32mif ( uvScaleMap.matrixAutoUpdate === true ) {[m
[32m+[m
[32m+[m				[32muvScaleMap.updateMatrix();[m
 [m
 			}[m
 [m
[31m-			uniforms.uvTransform.value.copy( material.map.matrix );[m
[32m+[m			[32muniforms.uvTransform.value.copy( uvScaleMap.matrix );[m
 [m
 		}[m
 [m
[36m@@ -25506,17 +25506,44 @@[m [mfunction WebGLRenderer( parameters ) {[m
 		uniforms.diffuse.value.copy( material.color );[m
 		uniforms.opacity.value = material.opacity;[m
 		uniforms.rotation.value = material.rotation;[m
[31m-		uniforms.map.value = material.map;[m
 [m
[31m-		if ( material.map !== null ) {[m
[32m+[m		[32mif ( material.map ) {[m
[32m+[m
[32m+[m			[32muniforms.map.value = material.map;[m
[32m+[m
[32m+[m		[32m}[m
 [m
[31m-			if ( material.map.matrixAutoUpdate === true ) {[m
[32m+[m		[32mif ( material.alphaMap ) {[m
 [m
[31m-				material.map.updateMatrix();[m
[32m+[m			[32muniforms.alphaMap.value = material.alphaMap;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32m// uv repeat and offset setting priorities[m
[32m+[m		[32m// 1. color map[m
[32m+[m		[32m// 2. alpha map[m
[32m+[m
[32m+[m		[32mvar uvScaleMap;[m
[32m+[m
[32m+[m		[32mif ( material.map ) {[m
[32m+[m
[32m+[m			[32muvScaleMap = material.map;[m
[32m+[m
[32m+[m		[32m} else if ( material.alphaMap ) {[m
[32m+[m
[32m+[m			[32muvScaleMap = material.alphaMap;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( uvScaleMap !== undefined ) {[m
[32m+[m
[32m+[m			[32mif ( uvScaleMap.matrixAutoUpdate === true ) {[m
[32m+[m
[32m+[m				[32muvScaleMap.updateMatrix();[m
 [m
 			}[m
 [m
[31m-			uniforms.uvTransform.value.copy( material.map.matrix );[m
[32m+[m			[32muniforms.uvTransform.value.copy( uvScaleMap.matrix );[m
 [m
 		}[m
 [m
[36m@@ -25588,7 +25615,8 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	function refreshUniformsToon( uniforms, material ) {[m
 [m
[31m-		refreshUniformsPhong( uniforms, material );[m
[32m+[m		[32muniforms.specular.value.copy( material.specular );[m
[32m+[m		[32muniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )[m
 [m
 		if ( material.gradientMap ) {[m
 [m
[36m@@ -25596,9 +25624,39 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[32m+[m		[32mif ( material.emissiveMap ) {[m
[32m+[m
[32m+[m			[32muniforms.emissiveMap.value = material.emissiveMap;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( material.bumpMap ) {[m
[32m+[m
[32m+[m			[32muniforms.bumpMap.value = material.bumpMap;[m
[32m+[m			[32muniforms.bumpScale.value = material.bumpScale;[m
[32m+[m			[32mif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( material.normalMap ) {[m
[32m+[m
[32m+[m			[32muniforms.normalMap.value = material.normalMap;[m
[32m+[m			[32muniforms.normalScale.value.copy( material.normalScale );[m
[32m+[m			[32mif ( material.side === BackSide ) uniforms.normalScale.value.negate();[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( material.displacementMap ) {[m
[32m+[m
[32m+[m			[32muniforms.displacementMap.value = material.displacementMap;[m
[32m+[m			[32muniforms.displacementScale.value = material.displacementScale;[m
[32m+[m			[32muniforms.displacementBias.value = material.displacementBias;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 	}[m
 [m
[31m-	function refreshUniformsStandard( uniforms, material ) {[m
[32m+[m	[32mfunction refreshUniformsStandard( uniforms, material, environment ) {[m
 [m
 		uniforms.roughness.value = material.roughness;[m
 		uniforms.metalness.value = material.metalness;[m
[36m@@ -25645,7 +25703,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[31m-		if ( material.envMap ) {[m
[32m+[m		[32mif ( material.envMap || environment ) {[m
 [m
 			//uniforms.envMap.value = material.envMap; // part of uniforms common[m
 			uniforms.envMapIntensity.value = material.envMapIntensity;[m
[36m@@ -25654,9 +25712,9 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	}[m
 [m
[31m-	function refreshUniformsPhysical( uniforms, material ) {[m
[32m+[m	[32mfunction refreshUniformsPhysical( uniforms, material, environment ) {[m
 [m
[31m-		refreshUniformsStandard( uniforms, material );[m
[32m+[m		[32mrefreshUniformsStandard( uniforms, material, environment );[m
 [m
 		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common[m
 [m
[36m@@ -25664,6 +25722,18 @@[m [mfunction WebGLRenderer( parameters ) {[m
 		uniforms.clearcoatRoughness.value = material.clearcoatRoughness;[m
 		if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );[m
 [m
[32m+[m		[32mif ( material.clearcoatMap ) {[m
[32m+[m
[32m+[m			[32muniforms.clearcoatMap.value = material.clearcoatMap;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( material.clearcoatRoughnessMap ) {[m
[32m+[m
[32m+[m			[32muniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 		if ( material.clearcoatNormalMap ) {[m
 [m
 			uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );[m
[36m@@ -25779,8 +25849,11 @@[m [mfunction WebGLRenderer( parameters ) {[m
 		uniforms.lightProbe.needsUpdate = value;[m
 [m
 		uniforms.directionalLights.needsUpdate = value;[m
[32m+[m		[32muniforms.directionalLightShadows.needsUpdate = value;[m
 		uniforms.pointLights.needsUpdate = value;[m
[32m+[m		[32muniforms.pointLightShadows.needsUpdate = value;[m
 		uniforms.spotLights.needsUpdate = value;[m
[32m+[m		[32muniforms.spotLightShadows.needsUpdate = value;[m
 		uniforms.rectAreaLights.needsUpdate = value;[m
 		uniforms.hemisphereLights.needsUpdate = value;[m
 [m
[36m@@ -25788,7 +25861,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	function materialNeedsLights( material ) {[m
 [m
[31m-		return material.isMeshLambertMaterial || material.isMeshPhongMaterial ||[m
[32m+[m		[32mreturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||[m
 			material.isMeshStandardMaterial || material.isShadowMaterial ||[m
 			( material.isShaderMaterial && material.lights === true );[m
 [m
[36m@@ -25797,7 +25870,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 	//[m
 	this.setFramebuffer = function ( value ) {[m
 [m
[31m-		if ( _framebuffer !== value ) _gl.bindFramebuffer( 36160, value );[m
[32m+[m		[32mif ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( 36160, value );[m
 [m
 		_framebuffer = value;[m
 [m
[36m@@ -25840,7 +25913,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 			var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;[m
 [m
[31m-			if ( renderTarget.isWebGLRenderTargetCube ) {[m
[32m+[m			[32mif ( renderTarget.isWebGLCubeRenderTarget ) {[m
 [m
 				framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];[m
 				isCube = true;[m
[36m@@ -25898,7 +25971,7 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;[m
 [m
[31m-		if ( renderTarget.isWebGLRenderTargetCube && activeCubeFaceIndex !== undefined ) {[m
[32m+[m		[32mif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {[m
 [m
 			framebuffer = framebuffer[ activeCubeFaceIndex ];[m
 [m
[36m@@ -25970,13 +26043,18 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 	this.copyFramebufferToTexture = function ( position, texture, level ) {[m
 [m
[31m-		var width = texture.image.width;[m
[31m-		var height = texture.image.height;[m
[32m+[m		[32mif ( level === undefined ) level = 0;[m
[32m+[m
[32m+[m		[32mvar levelScale = Math.pow( 2, - level );[m
[32m+[m		[32mvar width = Math.floor( texture.image.width * levelScale );[m
[32m+[m		[32mvar height = Math.floor( texture.image.height * levelScale );[m
 		var glFormat = utils.convert( texture.format );[m
 [m
 		textures.setTexture2D( texture, 0 );[m
 [m
[31m-		_gl.copyTexImage2D( 3553, level || 0, glFormat, position.x, position.y, width, height, 0 );[m
[32m+[m		[32m_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );[m
[32m+[m
[32m+[m		[32mstate.unbindTexture();[m
 [m
 	};[m
 [m
[36m@@ -25999,6 +26077,16 @@[m [mfunction WebGLRenderer( parameters ) {[m
 [m
 		}[m
 [m
[32m+[m		[32mstate.unbindTexture();[m
[32m+[m
[32m+[m	[32m};[m
[32m+[m
[32m+[m	[32mthis.initTexture = function ( texture ) {[m
[32m+[m
[32m+[m		[32mtextures.setTexture2D( texture, 0 );[m
[32m+[m
[32m+[m		[32mstate.unbindTexture();[m
[32m+[m
 	};[m
 [m
 	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {[m
[36m@@ -26094,7 +26182,7 @@[m [mfunction InterleavedBuffer( array, stride ) {[m
 	this.stride = stride;[m
 	this.count = array !== undefined ? array.length / stride : 0;[m
 [m
[31m-	this.dynamic = false;[m
[32m+[m	[32mthis.usage = StaticDrawUsage;[m
 	this.updateRange = { offset: 0, count: - 1 };[m
 [m
 	this.version = 0;[m
[36m@@ -26117,9 +26205,9 @@[m [mObject.assign( InterleavedBuffer.prototype, {[m
 [m
 	onUploadCallback: function () {},[m
 [m
[31m-	setDynamic: function ( value ) {[m
[32m+[m	[32msetUsage: function ( value ) {[m
 [m
[31m-		this.dynamic = value;[m
[32m+[m		[32mthis.usage = value;[m
 [m
 		return this;[m
 [m
[36m@@ -26130,7 +26218,7 @@[m [mObject.assign( InterleavedBuffer.prototype, {[m
 		this.array = new source.array.constructor( source.array );[m
 		this.count = source.count;[m
 		this.stride = source.stride;[m
[31m-		this.dynamic = source.dynamic;[m
[32m+[m		[32mthis.usage = source.usage;[m
 [m
 		return this;[m
 [m
[36m@@ -26181,6 +26269,8 @@[m [mObject.assign( InterleavedBuffer.prototype, {[m
  * @author benaadams / https://twitter.com/ben_a_adams[m
  */[m
 [m
[32m+[m[32mvar _vector$6 = new Vector3();[m
[32m+[m
 function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {[m
 [m
 	this.data = interleavedBuffer;[m
[36m@@ -26219,6 +26309,24 @@[m [mObject.assign( InterleavedBufferAttribute.prototype, {[m
 [m
 	isInterleavedBufferAttribute: true,[m
 [m
[32m+[m	[32mapplyMatrix4: function ( m ) {[m
[32m+[m
[32m+[m		[32mfor ( var i = 0, l = this.data.count; i < l; i ++ ) {[m
[32m+[m
[32m+[m			[32m_vector$6.x = this.getX( i );[m
[32m+[m			[32m_vector$6.y = this.getY( i );[m
[32m+[m			[32m_vector$6.z = this.getZ( i );[m
[32m+[m
[32m+[m			[32m_vector$6.applyMatrix4( m );[m
[32m+[m
[32m+[m			[32mthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
 	setX: function ( index, x ) {[m
 [m
 		this.data.array[ index * this.data.stride + this.offset ] = x;[m
[36m@@ -26319,6 +26427,7 @@[m [mObject.assign( InterleavedBufferAttribute.prototype, {[m
  * parameters = {[m
  *  color: <hex>,[m
  *  map: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  alphaMap: new THREE.Texture( <Image> ),[m
  *  rotation: <float>,[m
  *  sizeAttenuation: <bool>[m
  * }[m
[36m@@ -26331,8 +26440,11 @@[m [mfunction SpriteMaterial( parameters ) {[m
 	this.type = 'SpriteMaterial';[m
 [m
 	this.color = new Color( 0xffffff );[m
[32m+[m
 	this.map = null;[m
 [m
[32m+[m	[32mthis.alphaMap = null;[m
[32m+[m
 	this.rotation = 0;[m
 [m
 	this.sizeAttenuation = true;[m
[36m@@ -26352,8 +26464,11 @@[m [mSpriteMaterial.prototype.copy = function ( source ) {[m
 	Material.prototype.copy.call( this, source );[m
 [m
 	this.color.copy( source.color );[m
[32m+[m
 	this.map = source.map;[m
 [m
[32m+[m	[32mthis.alphaMap = source.alphaMap;[m
[32m+[m
 	this.rotation = source.rotation;[m
 [m
 	this.sizeAttenuation = source.sizeAttenuation;[m
[36m@@ -26405,8 +26520,8 @@[m [mfunction Sprite( material ) {[m
 		var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );[m
 [m
 		_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );[m
[31m-		_geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );[m
[31m-		_geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );[m
[32m+[m		[32m_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );[m
[32m+[m		[32m_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );[m
 [m
 	}[m
 [m
[36m@@ -26556,6 +26671,8 @@[m [mfunction LOD() {[m
 [m
 	Object3D.call( this );[m
 [m
[32m+[m	[32mthis._currentLevel = 0;[m
[32m+[m
 	this.type = 'LOD';[m
 [m
 	Object.defineProperties( this, {[m
[36m@@ -26589,6 +26706,8 @@[m [mLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 		}[m
 [m
[32m+[m		[32mthis.autoUpdate = source.autoUpdate;[m
[32m+[m
 		return this;[m
 [m
 	},[m
[36m@@ -26619,31 +26738,49 @@[m [mLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 	},[m
 [m
[32m+[m	[32mgetCurrentLevel: function () {[m
[32m+[m
[32m+[m		[32mreturn this._currentLevel;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
 	getObjectForDistance: function ( distance ) {[m
 [m
 		var levels = this.levels;[m
 [m
[31m-		for ( var i = 1, l = levels.length; i < l; i ++ ) {[m
[32m+[m		[32mif ( levels.length > 0 ) {[m
 [m
[31m-			if ( distance < levels[ i ].distance ) {[m
[32m+[m			[32mfor ( var i = 1, l = levels.length; i < l; i ++ ) {[m
 [m
[31m-				break;[m
[32m+[m				[32mif ( distance < levels[ i ].distance ) {[m
[32m+[m
[32m+[m					[32mbreak;[m
[32m+[m
[32m+[m				[32m}[m
 [m
 			}[m
 [m
[32m+[m			[32mreturn levels[ i - 1 ].object;[m
[32m+[m
 		}[m
 [m
[31m-		return levels[ i - 1 ].object;[m
[32m+[m		[32mreturn null;[m
 [m
 	},[m
 [m
 	raycast: function ( raycaster, intersects ) {[m
 [m
[31m-		_v1$4.setFromMatrixPosition( this.matrixWorld );[m
[32m+[m		[32mvar levels = this.levels;[m
[32m+[m
[32m+[m		[32mif ( levels.length > 0 ) {[m
[32m+[m
[32m+[m			[32m_v1$4.setFromMatrixPosition( this.matrixWorld );[m
 [m
[31m-		var distance = raycaster.ray.origin.distanceTo( _v1$4 );[m
[32m+[m			[32mvar distance = raycaster.ray.origin.distanceTo( _v1$4 );[m
 [m
[31m-		this.getObjectForDistance( distance ).raycast( raycaster, intersects );[m
[32m+[m			[32mthis.getObjectForDistance( distance ).raycast( raycaster, intersects );[m
[32m+[m
[32m+[m		[32m}[m
 [m
 	},[m
 [m
[36m@@ -26656,7 +26793,7 @@[m [mLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 			_v1$4.setFromMatrixPosition( camera.matrixWorld );[m
 			_v2$2.setFromMatrixPosition( this.matrixWorld );[m
 [m
[31m-			var distance = _v1$4.distanceTo( _v2$2 );[m
[32m+[m			[32mvar distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;[m
 [m
 			levels[ 0 ].object.visible = true;[m
 [m
[36m@@ -26675,6 +26812,8 @@[m [mLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 			}[m
 [m
[32m+[m			[32mthis._currentLevel = i - 1;[m
[32m+[m
 			for ( ; i < l; i ++ ) {[m
 [m
 				levels[ i ].object.visible = false;[m
[36m@@ -26689,6 +26828,8 @@[m [mLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 		var data = Object3D.prototype.toJSON.call( this, meta );[m
 [m
[32m+[m		[32mif ( this.autoUpdate === false ) data.object.autoUpdate = false;[m
[32m+[m
 		data.object.levels = [];[m
 [m
 		var levels = this.levels;[m
[36m@@ -26992,6 +27133,18 @@[m [mObject.assign( Skeleton.prototype, {[m
 [m
 		return undefined;[m
 [m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mdispose: function ( ) {[m
[32m+[m
[32m+[m		[32mif ( this.boneTexture ) {[m
[32m+[m
[32m+[m			[32mthis.boneTexture.dispose();[m
[32m+[m
[32m+[m			[32mthis.boneTexture = undefined;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 	}[m
 [m
 } );[m
[36m@@ -27022,6 +27175,13 @@[m [mBone.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
  * @author mrdoob / http://mrdoob.com/[m
  */[m
 [m
[32m+[m[32mvar _instanceLocalMatrix = new Matrix4();[m
[32m+[m[32mvar _instanceWorldMatrix = new Matrix4();[m
[32m+[m
[32m+[m[32mvar _instanceIntersects = [];[m
[32m+[m
[32m+[m[32mvar _mesh = new Mesh();[m
[32m+[m
 function InstancedMesh( geometry, material, count ) {[m
 [m
 	Mesh.call( this, geometry, material );[m
[36m@@ -27030,6 +27190,8 @@[m [mfunction InstancedMesh( geometry, material, count ) {[m
 [m
 	this.count = count;[m
 [m
[32m+[m	[32mthis.frustumCulled = false;[m
[32m+[m
 }[m
 [m
 InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {[m
[36m@@ -27038,7 +27200,52 @@[m [mInstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {[m
 [m
 	isInstancedMesh: true,[m
 [m
[31m-	raycast: function () {},[m
[32m+[m	[32mgetMatrixAt: function ( index, matrix ) {[m
[32m+[m
[32m+[m		[32mmatrix.fromArray( this.instanceMatrix.array, index * 16 );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32mraycast: function ( raycaster, intersects ) {[m
[32m+[m
[32m+[m		[32mvar matrixWorld = this.matrixWorld;[m
[32m+[m		[32mvar raycastTimes = this.count;[m
[32m+[m
[32m+[m		[32m_mesh.geometry = this.geometry;[m
[32m+[m		[32m_mesh.material = this.material;[m
[32m+[m
[32m+[m		[32mif ( _mesh.material === undefined ) return;[m
[32m+[m
[32m+[m		[32mfor ( var instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {[m
[32m+[m
[32m+[m			[32m// calculate the world matrix for each instance[m
[32m+[m
[32m+[m			[32mthis.getMatrixAt( instanceId, _instanceLocalMatrix );[m
[32m+[m
[32m+[m			[32m_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );[m
[32m+[m
[32m+[m			[32m// the mesh represents this single instance[m
[32m+[m
[32m+[m			[32m_mesh.matrixWorld = _instanceWorldMatrix;[m
[32m+[m
[32m+[m			[32m_mesh.raycast( raycaster, _instanceIntersects );[m
[32m+[m
[32m+[m			[32m// process the result of raycast[m
[32m+[m
[32m+[m			[32mif ( _instanceIntersects.length > 0 ) {[m
[32m+[m
[32m+[m				[32m_instanceIntersects[ 0 ].instanceId = instanceId;[m
[32m+[m				[32m_instanceIntersects[ 0 ].object = this;[m
[32m+[m
[32m+[m				[32mintersects.push( _instanceIntersects[ 0 ] );[m
[32m+[m
[32m+[m				[32m_instanceIntersects.length = 0;[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m},[m
 [m
 	setMatrixAt: function ( index, matrix ) {[m
 [m
[36m@@ -27046,7 +27253,9 @@[m [mInstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {[m
 [m
 	},[m
 [m
[31m-	updateMorphTargets: function () {}[m
[32m+[m	[32mupdateMorphTargets: function () {[m
[32m+[m
[32m+[m	[32m}[m
 [m
 } );[m
 [m
[36m@@ -27122,7 +27331,7 @@[m [mfunction Line( geometry, material, mode ) {[m
 	this.type = 'Line';[m
 [m
 	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();[m
[31m-	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );[m
[32m+[m	[32mthis.material = material !== undefined ? material : new LineBasicMaterial();[m
 [m
 }[m
 [m
[36m@@ -27155,7 +27364,7 @@[m [mLine.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 				}[m
 [m
[31m-				geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );[m
[32m+[m				[32mgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );[m
 [m
 			} else {[m
 [m
[36m@@ -27185,10 +27394,9 @@[m [mLine.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 	raycast: function ( raycaster, intersects ) {[m
 [m
[31m-		var precision = raycaster.linePrecision;[m
[31m-[m
 		var geometry = this.geometry;[m
 		var matrixWorld = this.matrixWorld;[m
[32m+[m		[32mvar threshold = raycaster.params.Line.threshold;[m
 [m
 		// Checking boundingSphere distance to ray[m
 [m
[36m@@ -27196,7 +27404,7 @@[m [mLine.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 		_sphere$2.copy( geometry.boundingSphere );[m
 		_sphere$2.applyMatrix4( matrixWorld );[m
[31m-		_sphere$2.radius += precision;[m
[32m+[m		[32m_sphere$2.radius += threshold;[m
 [m
 		if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;[m
 [m
[36m@@ -27205,8 +27413,8 @@[m [mLine.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 		_inverseMatrix$1.getInverse( matrixWorld );[m
 		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );[m
 [m
[31m-		var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );[m
[31m-		var localPrecisionSq = localPrecision * localPrecision;[m
[32m+[m		[32mvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );[m
[32m+[m		[32mvar localThresholdSq = localThreshold * localThreshold;[m
 [m
 		var vStart = new Vector3();[m
 		var vEnd = new Vector3();[m
[36m@@ -27234,7 +27442,7 @@[m [mLine.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 					var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );[m
 [m
[31m-					if ( distSq > localPrecisionSq ) continue;[m
[32m+[m					[32mif ( distSq > localThresholdSq ) continue;[m
 [m
 					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation[m
 [m
[36m@@ -27266,7 +27474,7 @@[m [mLine.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 					var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );[m
 [m
[31m-					if ( distSq > localPrecisionSq ) continue;[m
[32m+[m					[32mif ( distSq > localThresholdSq ) continue;[m
 [m
 					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation[m
 [m
[36m@@ -27300,7 +27508,7 @@[m [mLine.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 				var distSq = _ray$1.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );[m
 [m
[31m-				if ( distSq > localPrecisionSq ) continue;[m
[32m+[m				[32mif ( distSq > localThresholdSq ) continue;[m
 [m
 				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation[m
 [m
[36m@@ -27379,7 +27587,7 @@[m [mLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {[m
 [m
 				}[m
 [m
[31m-				geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );[m
[32m+[m				[32mgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );[m
 [m
 			} else {[m
 [m
[36m@@ -27438,6 +27646,7 @@[m [mLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {[m
  *  color: <hex>,[m
  *  opacity: <float>,[m
  *  map: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  alphaMap: new THREE.Texture( <Image> ),[m
  *[m
  *  size: <float>,[m
  *  sizeAttenuation: <bool>[m
[36m@@ -27456,6 +27665,8 @@[m [mfunction PointsMaterial( parameters ) {[m
 [m
 	this.map = null;[m
 [m
[32m+[m	[32mthis.alphaMap = null;[m
[32m+[m
 	this.size = 1;[m
 	this.sizeAttenuation = true;[m
 [m
[36m@@ -27478,6 +27689,8 @@[m [mPointsMaterial.prototype.copy = function ( source ) {[m
 [m
 	this.map = source.map;[m
 [m
[32m+[m	[32mthis.alphaMap = source.alphaMap;[m
[32m+[m
 	this.size = source.size;[m
 	this.sizeAttenuation = source.sizeAttenuation;[m
 [m
[36m@@ -27503,7 +27716,7 @@[m [mfunction Points( geometry, material ) {[m
 	this.type = 'Points';[m
 [m
 	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();[m
[31m-	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );[m
[32m+[m	[32mthis.material = material !== undefined ? material : new PointsMaterial();[m
 [m
 	this.updateMorphTargets();[m
 [m
[36m@@ -27950,7 +28163,7 @@[m [mfunction WireframeGeometry( geometry ) {[m
 [m
 	// build geometry[m
 [m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
 [m
 }[m
 [m
[36m@@ -27962,7 +28175,7 @@[m [mWireframeGeometry.prototype.constructor = WireframeGeometry;[m
  * @author Mugen87 / https://github.com/Mugen87[m
  *[m
  * Parametric Surfaces Geometry[m
[31m- * based on the brilliant article by @prideout http://prideout.net/blog/?p=44[m
[32m+[m[32m * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html[m
  */[m
 [m
 // ParametricGeometry[m
[36m@@ -28104,9 +28317,9 @@[m [mfunction ParametricBufferGeometry( func, slices, stacks ) {[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 }[m
 [m
[36m@@ -28180,9 +28393,9 @@[m [mfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {[m
 [m
 	// build non-indexed geometry[m
 [m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );[m
 [m
 	if ( detail === 0 ) {[m
 [m
[36m@@ -28793,9 +29006,9 @@[m [mfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, clos[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 	// functions[m
 [m
[36m@@ -29083,9 +29296,9 @@[m [mfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments,[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 	// this function calculates the current position on the torus curve[m
 [m
[36m@@ -29233,9 +29446,9 @@[m [mfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 }[m
 [m
[36m@@ -30179,8 +30392,8 @@[m [mfunction ExtrudeBufferGeometry( shapes, options ) {[m
 [m
 	// build geometry[m
 [m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );[m
 [m
 	this.computeVertexNormals();[m
 [m
[36m@@ -31147,9 +31360,9 @@[m [mfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart,[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 }[m
 [m
[36m@@ -31291,9 +31504,9 @@[m [mfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegment[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 }[m
 [m
[36m@@ -31350,7 +31563,7 @@[m [mfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {[m
 [m
 	// clamp phiLength so it's in range of [ 0, 2PI ][m
 [m
[31m-	phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );[m
[32m+[m	[32mphiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );[m
 [m
 [m
 	// buffers[m
[36m@@ -31423,8 +31636,8 @@[m [mfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 	// generate normals[m
 [m
[36m@@ -31572,9 +31785,9 @@[m [mfunction ShapeBufferGeometry( shapes, curveSegments ) {[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 [m
 	// helper functions[m
[36m@@ -31713,7 +31926,7 @@[m [mfunction EdgesGeometry( geometry, thresholdAngle ) {[m
 [m
 	// helper variables[m
 [m
[31m-	var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );[m
[32m+[m	[32mvar thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );[m
 	var edge = [ 0, 0 ], edges = {}, edge1, edge2;[m
 	var key, keys = [ 'a', 'b', 'c' ];[m
 [m
[36m@@ -31789,7 +32002,7 @@[m [mfunction EdgesGeometry( geometry, thresholdAngle ) {[m
 [m
 	// build geometry[m
 [m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
 [m
 }[m
 [m
[36m@@ -31888,9 +32101,9 @@[m [mfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 	function generateTorso() {[m
 [m
[36m@@ -32258,9 +32471,9 @@[m [mfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {[m
 	// build geometry[m
 [m
 	this.setIndex( indices );[m
[31m-	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[31m-	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
[32m+[m	[32mthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );[m
[32m+[m	[32mthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );[m
 [m
 }[m
 [m
[36m@@ -32270,6 +32483,7 @@[m [mCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;[m
 [m
 [m
 var Geometries = /*#__PURE__*/Object.freeze({[m
[32m+[m	[32m__proto__: null,[m
 	WireframeGeometry: WireframeGeometry,[m
 	ParametricGeometry: ParametricGeometry,[m
 	ParametricBufferGeometry: ParametricBufferGeometry,[m
[36m@@ -32428,8 +32642,8 @@[m [mfunction MeshStandardMaterial( parameters ) {[m
 	this.type = 'MeshStandardMaterial';[m
 [m
 	this.color = new Color( 0xffffff ); // diffuse[m
[31m-	this.roughness = 0.5;[m
[31m-	this.metalness = 0.5;[m
[32m+[m	[32mthis.roughness = 1.0;[m
[32m+[m	[32mthis.metalness = 0.0;[m
 [m
 	this.map = null;[m
 [m
[36m@@ -32474,6 +32688,8 @@[m [mfunction MeshStandardMaterial( parameters ) {[m
 	this.morphTargets = false;[m
 	this.morphNormals = false;[m
 [m
[32m+[m	[32mthis.vertexTangents = false;[m
[32m+[m
 	this.setValues( parameters );[m
 [m
 }[m
[36m@@ -32536,6 +32752,8 @@[m [mMeshStandardMaterial.prototype.copy = function ( source ) {[m
 	this.morphTargets = source.morphTargets;[m
 	this.morphNormals = source.morphNormals;[m
 [m
[32m+[m	[32mthis.vertexTangents = source.vertexTangents;[m
[32m+[m
 	return this;[m
 [m
 };[m
[36m@@ -32544,14 +32762,18 @@[m [mMeshStandardMaterial.prototype.copy = function ( source ) {[m
  * @author WestLangley / http://github.com/WestLangley[m
  *[m
  * parameters = {[m
[31m- *  reflectivity: <float>[m
[31m- *  clearcoat: <float>[m
[31m- *  clearcoatRoughness: <float>[m
[31m- *[m
[31m- *  sheen: <Color>[m
[31m- *[m
[32m+[m[32m *  clearcoat: <float>,[m
[32m+[m[32m *  clearcoatMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  clearcoatRoughness: <float>,[m
[32m+[m[32m *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),[m
  *  clearcoatNormalScale: <Vector2>,[m
  *  clearcoatNormalMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *[m
[32m+[m[32m *  reflectivity: <float>,[m
[32m+[m[32m *[m
[32m+[m[32m *  sheen: <Color>,[m
[32m+[m[32m *[m
[32m+[m[32m *  transparency: <float>[m
  * }[m
  */[m
 [m
[36m@@ -32568,16 +32790,17 @@[m [mfunction MeshPhysicalMaterial( parameters ) {[m
 [m
 	this.type = 'MeshPhysicalMaterial';[m
 [m
[31m-	this.reflectivity = 0.5; // maps to F0 = 0.04[m
[31m-[m
 	this.clearcoat = 0.0;[m
[32m+[m	[32mthis.clearcoatMap = null;[m
 	this.clearcoatRoughness = 0.0;[m
[31m-[m
[31m-	this.sheen = null; // null will disable sheen bsdf[m
[31m-[m
[32m+[m	[32mthis.clearcoatRoughnessMap = null;[m
 	this.clearcoatNormalScale = new Vector2( 1, 1 );[m
 	this.clearcoatNormalMap = null;[m
 [m
[32m+[m	[32mthis.reflectivity = 0.5; // maps to F0 = 0.04[m
[32m+[m
[32m+[m	[32mthis.sheen = null; // null will disable sheen bsdf[m
[32m+[m
 	this.transparency = 0.0;[m
 [m
 	this.setValues( parameters );[m
[36m@@ -32600,17 +32823,25 @@[m [mMeshPhysicalMaterial.prototype.copy = function ( source ) {[m
 [m
 	};[m
 [m
[31m-	this.reflectivity = source.reflectivity;[m
[31m-[m
 	this.clearcoat = source.clearcoat;[m
[32m+[m	[32mthis.clearcoatMap = source.clearcoatMap;[m
 	this.clearcoatRoughness = source.clearcoatRoughness;[m
[31m-[m
[31m-	if ( source.sheen ) this.sheen = ( this.sheen || new Color() ).copy( source.sheen );[m
[31m-	else this.sheen = null;[m
[31m-[m
[32m+[m	[32mthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;[m
 	this.clearcoatNormalMap = source.clearcoatNormalMap;[m
 	this.clearcoatNormalScale.copy( source.clearcoatNormalScale );[m
 [m
[32m+[m	[32mthis.reflectivity = source.reflectivity;[m
[32m+[m
[32m+[m	[32mif ( source.sheen ) {[m
[32m+[m
[32m+[m		[32mthis.sheen = ( this.sheen || new Color() ).copy( source.sheen );[m
[32m+[m
[32m+[m	[32m} else {[m
[32m+[m
[32m+[m		[32mthis.sheen = null;[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
 	this.transparency = source.transparency;[m
 [m
 	return this;[m
[36m@@ -32655,7 +32886,7 @@[m [mMeshPhysicalMaterial.prototype.copy = function ( source ) {[m
  *  alphaMap: new THREE.Texture( <Image> ),[m
  *[m
  *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),[m
[31m- *  combine: THREE.Multiply,[m
[32m+[m[32m *  combine: THREE.MultiplyOperation,[m
  *  reflectivity: <float>,[m
  *  refractionRatio: <float>,[m
  *[m
[36m@@ -32763,11 +32994,163 @@[m [mMeshPhongMaterial.prototype.copy = function ( source ) {[m
 [m
 	this.alphaMap = source.alphaMap;[m
 [m
[31m-	this.envMap = source.envMap;[m
[31m-	this.combine = source.combine;[m
[31m-	this.reflectivity = source.reflectivity;[m
[31m-	this.refractionRatio = source.refractionRatio;[m
[31m-[m
[32m+[m	[32mthis.envMap = source.envMap;[m
[32m+[m	[32mthis.combine = source.combine;[m
[32m+[m	[32mthis.reflectivity = source.reflectivity;[m
[32m+[m	[32mthis.refractionRatio = source.refractionRatio;[m
[32m+[m
[32m+[m	[32mthis.wireframe = source.wireframe;[m
[32m+[m	[32mthis.wireframeLinewidth = source.wireframeLinewidth;[m
[32m+[m	[32mthis.wireframeLinecap = source.wireframeLinecap;[m
[32m+[m	[32mthis.wireframeLinejoin = source.wireframeLinejoin;[m
[32m+[m
[32m+[m	[32mthis.skinning = source.skinning;[m
[32m+[m	[32mthis.morphTargets = source.morphTargets;[m
[32m+[m	[32mthis.morphNormals = source.morphNormals;[m
[32m+[m
[32m+[m	[32mreturn this;[m
[32m+[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @author takahirox / http://github.com/takahirox[m
[32m+[m[32m *[m
[32m+[m[32m * parameters = {[m
[32m+[m[32m *  color: <hex>,[m
[32m+[m[32m *  specular: <hex>,[m
[32m+[m[32m *  shininess: <float>,[m
[32m+[m[32m *[m
[32m+[m[32m *  map: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  gradientMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *[m
[32m+[m[32m *  lightMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  lightMapIntensity: <float>[m
[32m+[m[32m *[m
[32m+[m[32m *  aoMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  aoMapIntensity: <float>[m
[32m+[m[32m *[m
[32m+[m[32m *  emissive: <hex>,[m
[32m+[m[32m *  emissiveIntensity: <float>[m
[32m+[m[32m *  emissiveMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *[m
[32m+[m[32m *  bumpMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  bumpScale: <float>,[m
[32m+[m[32m *[m
[32m+[m[32m *  normalMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  normalMapType: THREE.TangentSpaceNormalMap,[m
[32m+[m[32m *  normalScale: <Vector2>,[m
[32m+[m[32m *[m
[32m+[m[32m *  displacementMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *  displacementScale: <float>,[m
[32m+[m[32m *  displacementBias: <float>,[m
[32m+[m[32m *[m
[32m+[m[32m *  specularMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *[m
[32m+[m[32m *  alphaMap: new THREE.Texture( <Image> ),[m
[32m+[m[32m *[m
[32m+[m[32m *  wireframe: <boolean>,[m
[32m+[m[32m *  wireframeLinewidth: <float>,[m
[32m+[m[32m *[m
[32m+[m[32m *  skinning: <bool>,[m
[32m+[m[32m *  morphTargets: <bool>,[m
[32m+[m[32m *  morphNormals: <bool>[m
[32m+[m[32m * }[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mfunction MeshToonMaterial( parameters ) {[m
[32m+[m
[32m+[m	[32mMaterial.call( this );[m
[32m+[m
[32m+[m	[32mthis.defines = { 'TOON': '' };[m
[32m+[m
[32m+[m	[32mthis.type = 'MeshToonMaterial';[m
[32m+[m
[32m+[m	[32mthis.color = new Color( 0xffffff );[m
[32m+[m	[32mthis.specular = new Color( 0x111111 );[m
[32m+[m	[32mthis.shininess = 30;[m
[32m+[m
[32m+[m	[32mthis.map = null;[m
[32m+[m	[32mthis.gradientMap = null;[m
[32m+[m
[32m+[m	[32mthis.lightMap = null;[m
[32m+[m	[32mthis.lightMapIntensity = 1.0;[m
[32m+[m
[32m+[m	[32mthis.aoMap = null;[m
[32m+[m	[32mthis.aoMapIntensity = 1.0;[m
[32m+[m
[32m+[m	[32mthis.emissive = new Color( 0x000000 );[m
[32m+[m	[32mthis.emissiveIntensity = 1.0;[m
[32m+[m	[32mthis.emissiveMap = null;[m
[32m+[m
[32m+[m	[32mthis.bumpMap = null;[m
[32m+[m	[32mthis.bumpScale = 1;[m
[32m+[m
[32m+[m	[32mthis.normalMap = null;[m
[32m+[m	[32mthis.normalMapType = TangentSpaceNormalMap;[m
[32m+[m	[32mthis.normalScale = new Vector2( 1, 1 );[m
[32m+[m
[32m+[m	[32mthis.displacementMap = null;[m
[32m+[m	[32mthis.displacementScale = 1;[m
[32m+[m	[32mthis.displacementBias = 0;[m
[32m+[m
[32m+[m	[32mthis.specularMap = null;[m
[32m+[m
[32m+[m	[32mthis.alphaMap = null;[m
[32m+[m
[32m+[m	[32mthis.wireframe = false;[m
[32m+[m	[32mthis.wireframeLinewidth = 1;[m
[32m+[m	[32mthis.wireframeLinecap = 'round';[m
[32m+[m	[32mthis.wireframeLinejoin = 'round';[m
[32m+[m
[32m+[m	[32mthis.skinning = false;[m
[32m+[m	[32mthis.morphTargets = false;[m
[32m+[m	[32mthis.morphNormals = false;[m
[32m+[m
[32m+[m	[32mthis.setValues( parameters );[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mMeshToonMaterial.prototype = Object.create( Material.prototype );[m
[32m+[m[32mMeshToonMaterial.prototype.constructor = MeshToonMaterial;[m
[32m+[m
[32m+[m[32mMeshToonMaterial.prototype.isMeshToonMaterial = true;[m
[32m+[m
[32m+[m[32mMeshToonMaterial.prototype.copy = function ( source ) {[m
[32m+[m
[32m+[m	[32mMaterial.prototype.copy.call( this, source );[m
[32m+[m
[32m+[m	[32mthis.color.copy( source.color );[m
[32m+[m	[32mthis.specular.copy( source.specular );[m
[32m+[m	[32mthis.shininess = source.shininess;[m
[32m+[m
[32m+[m	[32mthis.map = source.map;[m
[32m+[m	[32mthis.gradientMap = source.gradientMap;[m
[32m+[m
[32m+[m	[32mthis.lightMap = source.lightMap;[m
[32m+[m	[32mthis.lightMapIntensity = source.lightMapIntensity;[m
[32m+[m
[32m+[m	[32mthis.aoMap = source.aoMap;[m
[32m+[m	[32mthis.aoMapIntensity = source.aoMapIntensity;[m
[32m+[m
[32m+[m	[32mthis.emissive.copy( source.emissive );[m
[32m+[m	[32mthis.emissiveMap = source.emissiveMap;[m
[32m+[m	[32mthis.emissiveIntensity = source.emissiveIntensity;[m
[32m+[m
[32m+[m	[32mthis.bumpMap = source.bumpMap;[m
[32m+[m	[32mthis.bumpScale = source.bumpScale;[m
[32m+[m
[32m+[m	[32mthis.normalMap = source.normalMap;[m
[32m+[m	[32mthis.normalMapType = source.normalMapType;[m
[32m+[m	[32mthis.normalScale.copy( source.normalScale );[m
[32m+[m
[32m+[m	[32mthis.displacementMap = source.displacementMap;[m
[32m+[m	[32mthis.displacementScale = source.displacementScale;[m
[32m+[m	[32mthis.displacementBias = source.displacementBias;[m
[32m+[m
[32m+[m	[32mthis.specularMap = source.specularMap;[m
[32m+[m
[32m+[m	[32mthis.alphaMap = source.alphaMap;[m
[32m+[m
 	this.wireframe = source.wireframe;[m
 	this.wireframeLinewidth = source.wireframeLinewidth;[m
 	this.wireframeLinecap = source.wireframeLinecap;[m
[36m@@ -32781,43 +33164,6 @@[m [mMeshPhongMaterial.prototype.copy = function ( source ) {[m
 [m
 };[m
 [m
[31m-/**[m
[31m- * @author takahirox / http://github.com/takahirox[m
[31m- *[m
[31m- * parameters = {[m
[31m- *  gradientMap: new THREE.Texture( <Image> )[m
[31m- * }[m
[31m- */[m
[31m-[m
[31m-function MeshToonMaterial( parameters ) {[m
[31m-[m
[31m-	MeshPhongMaterial.call( this );[m
[31m-[m
[31m-	this.defines = { 'TOON': '' };[m
[31m-[m
[31m-	this.type = 'MeshToonMaterial';[m
[31m-[m
[31m-	this.gradientMap = null;[m
[31m-[m
[31m-	this.setValues( parameters );[m
[31m-[m
[31m-}[m
[31m-[m
[31m-MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );[m
[31m-MeshToonMaterial.prototype.constructor = MeshToonMaterial;[m
[31m-[m
[31m-MeshToonMaterial.prototype.isMeshToonMaterial = true;[m
[31m-[m
[31m-MeshToonMaterial.prototype.copy = function ( source ) {[m
[31m-[m
[31m-	MeshPhongMaterial.prototype.copy.call( this, source );[m
[31m-[m
[31m-	this.gradientMap = source.gradientMap;[m
[31m-[m
[31m-	return this;[m
[31m-[m
[31m-};[m
[31m-[m
 /**[m
  * @author mrdoob / http://mrdoob.com/[m
  * @author WestLangley / http://github.com/WestLangley[m
[36m@@ -33183,6 +33529,7 @@[m [mLineDashedMaterial.prototype.copy = function ( source ) {[m
 [m
 [m
 var Materials = /*#__PURE__*/Object.freeze({[m
[32m+[m	[32m__proto__: null,[m
 	ShadowMaterial: ShadowMaterial,[m
 	SpriteMaterial: SpriteMaterial,[m
 	RawShaderMaterial: RawShaderMaterial,[m
[36m@@ -33363,6 +33710,79 @@[m [mvar AnimationUtils = {[m
 [m
 		}[m
 [m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32msubclip: function ( sourceClip, name, startFrame, endFrame, fps ) {[m
[32m+[m
[32m+[m		[32mfps = fps || 30;[m
[32m+[m
[32m+[m		[32mvar clip = sourceClip.clone();[m
[32m+[m
[32m+[m		[32mclip.name = name;[m
[32m+[m
[32m+[m		[32mvar tracks = [];[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < clip.tracks.length; ++ i ) {[m
[32m+[m
[32m+[m			[32mvar track = clip.tracks[ i ];[m
[32m+[m			[32mvar valueSize = track.getValueSize();[m
[32m+[m
[32m+[m			[32mvar times = [];[m
[32m+[m			[32mvar values = [];[m
[32m+[m
[32m+[m			[32mfor ( var j = 0; j < track.times.length; ++ j ) {[m
[32m+[m
[32m+[m				[32mvar frame = track.times[ j ] * fps;[m
[32m+[m
[32m+[m				[32mif ( frame < startFrame || frame >= endFrame ) continue;[m
[32m+[m
[32m+[m				[32mtimes.push( track.times[ j ] );[m
[32m+[m
[32m+[m				[32mfor ( var k = 0; k < valueSize; ++ k ) {[m
[32m+[m
[32m+[m					[32mvalues.push( track.values[ j * valueSize + k ] );[m
[32m+[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mif ( times.length === 0 ) continue;[m
[32m+[m
[32m+[m			[32mtrack.times = AnimationUtils.convertArray( times, track.times.constructor );[m
[32m+[m			[32mtrack.values = AnimationUtils.convertArray( values, track.values.constructor );[m
[32m+[m
[32m+[m			[32mtracks.push( track );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mclip.tracks = tracks;[m
[32m+[m
[32m+[m		[32m// find minimum .times value across all tracks in the trimmed clip[m
[32m+[m
[32m+[m		[32mvar minStartTime = Infinity;[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < clip.tracks.length; ++ i ) {[m
[32m+[m
[32m+[m			[32mif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {[m
[32m+[m
[32m+[m				[32mminStartTime = clip.tracks[ i ].times[ 0 ];[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32m// shift all tracks such that clip begins at t=0[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < clip.tracks.length; ++ i ) {[m
[32m+[m
[32m+[m			[32mclip.tracks[ i ].shift( - 1 * minStartTime );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mclip.resetDuration();[m
[32m+[m
[32m+[m		[32mreturn clip;[m
[32m+[m
 	}[m
 [m
 };[m
[36m@@ -33613,7 +34033,7 @@[m [mObject.assign( Interpolant.prototype, {[m
 [m
 } );[m
 [m
[31m-//!\ DECLARE ALIAS AFTER assign prototype ![m
[32m+[m[32m// DECLARE ALIAS AFTER assign prototype[m
 Object.assign( Interpolant.prototype, {[m
 [m
 	//( 0, t, t0 ), returns this.resultBuffer[m
[36m@@ -34086,7 +34506,12 @@[m [mObject.assign( KeyframeTrack.prototype, {[m
 		if ( from !== 0 || to !== nKeys ) {[m
 [m
 			// empty tracks are forbidden, so keep at least one keyframe[m
[31m-			if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;[m
[32m+[m			[32mif ( from >= to ) {[m
[32m+[m
[32m+[m				[32mto = Math.max( to, 1 );[m
[32m+[m				[32mfrom = to - 1;[m
[32m+[m
[32m+[m			[32m}[m
 [m
 			var stride = this.getValueSize();[m
 			this.times = AnimationUtils.arraySlice( times, from, to );[m
[36m@@ -34179,8 +34604,9 @@[m [mObject.assign( KeyframeTrack.prototype, {[m
 	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)[m
 	optimize: function () {[m
 [m
[31m-		var times = this.times,[m
[31m-			values = this.values,[m
[32m+[m		[32m// times or values may be shared with other tracks, so overwriting is unsafe[m
[32m+[m		[32mvar times = AnimationUtils.arraySlice( this.times ),[m
[32m+[m			[32mvalues = AnimationUtils.arraySlice( this.values ),[m
 			stride = this.getValueSize(),[m
 [m
 			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,[m
[36m@@ -34275,6 +34701,11 @@[m [mObject.assign( KeyframeTrack.prototype, {[m
 			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );[m
 			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );[m
 [m
[32m+[m		[32m} else {[m
[32m+[m
[32m+[m			[32mthis.times = times;[m
[32m+[m			[32mthis.values = values;[m
[32m+[m
 		}[m
 [m
 		return this;[m
[36m@@ -34536,7 +34967,7 @@[m [mfunction AnimationClip( name, duration, tracks ) {[m
 	this.tracks = tracks;[m
 	this.duration = ( duration !== undefined ) ? duration : - 1;[m
 [m
[31m-	this.uuid = _Math.generateUUID();[m
[32m+[m	[32mthis.uuid = MathUtils.generateUUID();[m
 [m
 	// this means it should figure out its duration by scanning the tracks[m
 	if ( this.duration < 0 ) {[m
[36m@@ -34961,7 +35392,6 @@[m [mObject.assign( AnimationClip.prototype, {[m
 [m
 	},[m
 [m
[31m-[m
 	clone: function () {[m
 [m
 		var tracks = [];[m
[36m@@ -35145,6 +35575,8 @@[m [mfunction LoadingManager( onLoad, onProgress, onError ) {[m
 			var regex = handlers[ i ];[m
 			var loader = handlers[ i + 1 ];[m
 [m
[32m+[m			[32mif ( regex.global ) regex.lastIndex = 0; // see #17920[m
[32m+[m
 			if ( regex.test( file ) ) {[m
 [m
 				return loader;[m
[36m@@ -35375,8 +35807,6 @@[m [mFileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 [m
 				var response = this.response;[m
 [m
[31m-				Cache.add( url, response );[m
[31m-[m
 				var callbacks = loading[ url ];[m
 [m
 				delete loading[ url ];[m
[36m@@ -35388,6 +35818,10 @@[m [mFileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 [m
 					if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );[m
 [m
[32m+[m					[32m// Add to cache only on HTTP success, so that we do not cache[m
[32m+[m					[32m// error response bodies as proper responses to requests.[m
[32m+[m					[32mCache.add( url, response );[m
[32m+[m
 					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {[m
 [m
 						var callback = callbacks[ i ];[m
[36m@@ -35736,7 +36170,7 @@[m [mDataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ),[m
 			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;[m
 [m
 			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;[m
[31m-			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipmapLinearFilter;[m
[32m+[m			[32mtexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;[m
 [m
 			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;[m
 [m
[36m@@ -35754,6 +36188,7 @@[m [mDataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ),[m
 			if ( texData.mipmaps !== undefined ) {[m
 [m
 				texture.mipmaps = texData.mipmaps;[m
[32m+[m				[32mtexture.minFilter = LinearMipmapLinearFilter; // presumably...[m
 [m
 			}[m
 [m
[36m@@ -35970,8 +36405,8 @@[m [mTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
  * Extensible curve object[m
  *[m
  * Some common of curve methods:[m
[31m- * .getPoint( t, optionalTarget ), .getTangent( t )[m
[31m- * .getPointAt( u, optionalTarget ), .getTangentAt( u )[m
[32m+[m[32m * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )[m
[32m+[m[32m * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )[m
  * .getPoints(), .getSpacedPoints()[m
  * .getLength()[m
  * .updateArcLengths()[m
[36m@@ -36200,7 +36635,7 @@[m [mObject.assign( Curve.prototype, {[m
 	// 2 points a small delta apart will be used to find its gradient[m
 	// which seems to give a reasonable approximation[m
 [m
[31m-	getTangent: function ( t ) {[m
[32m+[m	[32mgetTangent: function ( t, optionalTarget ) {[m
 [m
 		var delta = 0.0001;[m
 		var t1 = t - delta;[m
[36m@@ -36214,15 +36649,18 @@[m [mObject.assign( Curve.prototype, {[m
 		var pt1 = this.getPoint( t1 );[m
 		var pt2 = this.getPoint( t2 );[m
 [m
[31m-		var vec = pt2.clone().sub( pt1 );[m
[31m-		return vec.normalize();[m
[32m+[m		[32mvar tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );[m
[32m+[m
[32m+[m		[32mtangent.copy( pt2 ).sub( pt1 ).normalize();[m
[32m+[m
[32m+[m		[32mreturn tangent;[m
 [m
 	},[m
 [m
[31m-	getTangentAt: function ( u ) {[m
[32m+[m	[32mgetTangentAt: function ( u, optionalTarget ) {[m
 [m
 		var t = this.getUtoTmapping( u );[m
[31m-		return this.getTangent( t );[m
[32m+[m		[32mreturn this.getTangent( t, optionalTarget );[m
 [m
 	},[m
 [m
[36m@@ -36247,7 +36685,7 @@[m [mObject.assign( Curve.prototype, {[m
 [m
 			u = i / segments;[m
 [m
[31m-			tangents[ i ] = this.getTangentAt( u );[m
[32m+[m			[32mtangents[ i ] = this.getTangentAt( u, new Vector3() );[m
 			tangents[ i ].normalize();[m
 [m
 		}[m
[36m@@ -36302,7 +36740,7 @@[m [mObject.assign( Curve.prototype, {[m
 [m
 				vec.normalize();[m
 [m
[31m-				theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors[m
[32m+[m				[32mtheta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors[m
 [m
 				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );[m
 [m
[36m@@ -36316,7 +36754,7 @@[m [mObject.assign( Curve.prototype, {[m
 [m
 		if ( closed === true ) {[m
 [m
[31m-			theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );[m
[32m+[m			[32mtheta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );[m
 			theta /= segments;[m
 [m
 			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {[m
[36m@@ -37067,11 +37505,13 @@[m [mLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {[m
 [m
 };[m
 [m
[31m-LineCurve.prototype.getTangent = function ( /* t */ ) {[m
[32m+[m[32mLineCurve.prototype.getTangent = function ( t, optionalTarget ) {[m
 [m
[31m-	var tangent = this.v2.clone().sub( this.v1 );[m
[32m+[m	[32mvar tangent = optionalTarget || new Vector2();[m
 [m
[31m-	return tangent.normalize();[m
[32m+[m	[32mvar tangent = tangent.copy( this.v2 ).sub( this.v1 ).normalize();[m
[32m+[m
[32m+[m	[32mreturn tangent;[m
 [m
 };[m
 [m
[36m@@ -37415,6 +37855,7 @@[m [mSplineCurve.prototype.fromJSON = function ( json ) {[m
 [m
 [m
 var Curves = /*#__PURE__*/Object.freeze({[m
[32m+[m	[32m__proto__: null,[m
 	ArcCurve: ArcCurve,[m
 	CatmullRomCurve3: CatmullRomCurve3,[m
 	CubicBezierCurve: CubicBezierCurve,[m
[36m@@ -37718,12 +38159,16 @@[m [mPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {[m
 [m
 		}[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	moveTo: function ( x, y ) {[m
 [m
 		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	lineTo: function ( x, y ) {[m
[36m@@ -37733,6 +38178,8 @@[m [mPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {[m
 [m
 		this.currentPoint.set( x, y );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {[m
[36m@@ -37747,6 +38194,8 @@[m [mPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {[m
 [m
 		this.currentPoint.set( aX, aY );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {[m
[36m@@ -37762,6 +38211,8 @@[m [mPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {[m
 [m
 		this.currentPoint.set( aX, aY );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	splineThru: function ( pts /*Array of Vector*/ ) {[m
[36m@@ -37773,6 +38224,8 @@[m [mPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {[m
 [m
 		this.currentPoint.copy( pts[ pts.length - 1 ] );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {[m
[36m@@ -37783,12 +38236,16 @@[m [mPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {[m
 		this.absarc( aX + x0, aY + y0, aRadius,[m
 			aStartAngle, aEndAngle, aClockwise );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {[m
 [m
 		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {[m
[36m@@ -37798,6 +38255,8 @@[m [mPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {[m
 [m
 		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {[m
[36m@@ -37822,6 +38281,8 @@[m [mPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {[m
 		var lastPoint = curve.getPoint( 1 );[m
 		this.currentPoint.copy( lastPoint );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	copy: function ( source ) {[m
[36m@@ -37871,7 +38332,7 @@[m [mfunction Shape( points ) {[m
 [m
 	Path.call( this, points );[m
 [m
[31m-	this.uuid = _Math.generateUUID();[m
[32m+[m	[32mthis.uuid = MathUtils.generateUUID();[m
 [m
 	this.type = 'Shape';[m
 [m
[36m@@ -38126,7 +38587,7 @@[m [mObject.assign( LightShadow.prototype, {[m
 		shadowCamera.updateMatrixWorld();[m
 [m
 		projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );[m
[31m-		this._frustum.setFromMatrix( projScreenMatrix );[m
[32m+[m		[32mthis._frustum.setFromProjectionMatrix( projScreenMatrix );[m
 [m
 		shadowMatrix.set([m
 			0.5, 0.0, 0.0, 0.5,[m
[36m@@ -38204,11 +38665,11 @@[m [mSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype[m
 [m
 	isSpotLightShadow: true,[m
 [m
[31m-	updateMatrices: function ( light, viewCamera, viewportIndex ) {[m
[32m+[m	[32mupdateMatrices: function ( light ) {[m
 [m
 		var camera = this.camera;[m
 [m
[31m-		var fov = _Math.RAD2DEG * 2 * light.angle;[m
[32m+[m		[32mvar fov = MathUtils.RAD2DEG * 2 * light.angle;[m
 		var aspect = this.mapSize.width / this.mapSize.height;[m
 		var far = light.distance || camera.far;[m
 [m
[36m@@ -38221,7 +38682,7 @@[m [mSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype[m
 [m
 		}[m
 [m
[31m-		LightShadow.prototype.updateMatrices.call( this, light, viewCamera, viewportIndex );[m
[32m+[m		[32mLightShadow.prototype.updateMatrices.call( this, light );[m
 [m
 	}[m
 [m
[36m@@ -38347,7 +38808,9 @@[m [mPointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype[m
 [m
 	isPointLightShadow: true,[m
 [m
[31m-	updateMatrices: function ( light, viewCamera, viewportIndex ) {[m
[32m+[m	[32mupdateMatrices: function ( light, viewportIndex ) {[m
[32m+[m
[32m+[m		[32mif ( viewportIndex === undefined ) viewportIndex = 0;[m
 [m
 		var camera = this.camera,[m
 			shadowMatrix = this.matrix,[m
[36m@@ -38367,7 +38830,7 @@[m [mPointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype[m
 		shadowMatrix.makeTranslation( - lightPositionWorld.x, - lightPositionWorld.y, - lightPositionWorld.z );[m
 [m
 		projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );[m
[31m-		this._frustum.setFromMatrix( projScreenMatrix );[m
[32m+[m		[32mthis._frustum.setFromProjectionMatrix( projScreenMatrix );[m
 [m
 	}[m
 [m
[36m@@ -38533,15 +38996,13 @@[m [mOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ),[m
 [m
 		if ( this.view !== null && this.view.enabled ) {[m
 [m
[31m-			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );[m
[31m-			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );[m
[31m-			var scaleW = ( this.right - this.left ) / this.view.width;[m
[31m-			var scaleH = ( this.top - this.bottom ) / this.view.height;[m
[32m+[m			[32mvar scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;[m
[32m+[m			[32mvar scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;[m
 [m
[31m-			left += scaleW * ( this.view.offsetX / zoomW );[m
[31m-			right = left + scaleW * ( this.view.width / zoomW );[m
[31m-			top -= scaleH * ( this.view.offsetY / zoomH );[m
[31m-			bottom = top - scaleH * ( this.view.height / zoomH );[m
[32m+[m			[32mleft += scaleW * this.view.offsetX;[m
[32m+[m			[32mright = left + scaleW * this.view.width;[m
[32m+[m			[32mtop -= scaleH * this.view.offsetY;[m
[32m+[m			[32mbottom = top - scaleH * this.view.height;[m
 [m
 		}[m
 [m
[36m@@ -38587,9 +39048,9 @@[m [mDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.pro[m
 [m
 	isDirectionalLightShadow: true,[m
 [m
[31m-	updateMatrices: function ( light, viewCamera, viewportIndex ) {[m
[32m+[m	[32mupdateMatrices: function ( light ) {[m
 [m
[31m-		LightShadow.prototype.updateMatrices.call( this, light, viewCamera, viewportIndex );[m
[32m+[m		[32mLightShadow.prototype.updateMatrices.call( this, light );[m
 [m
 	}[m
 [m
[36m@@ -38761,7 +39222,6 @@[m [mMaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 		if ( json.shininess !== undefined ) material.shininess = json.shininess;[m
 		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;[m
 		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;[m
[31m-		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;[m
 		if ( json.fog !== undefined ) material.fog = json.fog;[m
 		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;[m
 		if ( json.blending !== undefined ) material.blending = json.blending;[m
[36m@@ -38804,12 +39264,28 @@[m [mMaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;[m
 		if ( json.dithering !== undefined ) material.dithering = json.dithering;[m
 [m
[32m+[m		[32mif ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;[m
[32m+[m
 		if ( json.visible !== undefined ) material.visible = json.visible;[m
 [m
 		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;[m
 [m
 		if ( json.userData !== undefined ) material.userData = json.userData;[m
 [m
[32m+[m		[32mif ( json.vertexColors !== undefined ) {[m
[32m+[m
[32m+[m			[32mif ( typeof json.vertexColors === 'number' ) {[m
[32m+[m
[32m+[m				[32mmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;[m
[32m+[m
[32m+[m			[32m} else {[m
[32m+[m
[32m+[m				[32mmaterial.vertexColors = json.vertexColors;[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 		// Shader Material[m
 [m
 		if ( json.uniforms !== undefined ) {[m
[36m@@ -38886,12 +39362,7 @@[m [mMaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 		if ( json.map !== undefined ) material.map = getTexture( json.map );[m
 		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );[m
 [m
[31m-		if ( json.alphaMap !== undefined ) {[m
[31m-[m
[31m-			material.alphaMap = getTexture( json.alphaMap );[m
[31m-			material.transparent = true;[m
[31m-[m
[31m-		}[m
[32m+[m		[32mif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );[m
 [m
 		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );[m
 		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;[m
[36m@@ -38940,6 +39411,8 @@[m [mMaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 [m
 		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );[m
 [m
[32m+[m		[32mif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );[m
[32m+[m		[32mif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );[m
 		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );[m
 		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );[m
 [m
[36m@@ -39159,7 +39632,7 @@[m [mBufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype[m
 			var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;[m
 			var bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );[m
 			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;[m
[31m-			geometry.addAttribute( key, bufferAttribute );[m
[32m+[m			[32mgeometry.setAttribute( key, bufferAttribute );[m
 [m
 		}[m
 [m
[36m@@ -39190,6 +39663,14 @@[m [mBufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype[m
 [m
 		}[m
 [m
[32m+[m		[32mvar morphTargetsRelative = json.data.morphTargetsRelative;[m
[32m+[m
[32m+[m		[32mif ( morphTargetsRelative ) {[m
[32m+[m
[32m+[m			[32mgeometry.morphTargetsRelative = true;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
 		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;[m
 [m
 		if ( groups !== undefined ) {[m
[36m@@ -39604,17 +40085,7 @@[m [mObjectLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 [m
 					case 'Geometry':[m
 [m
[31m-						if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) {[m
[31m-[m
[31m-							var geometryLoader = new THREE.LegacyJSONLoader();[m
[31m-							geometry = geometryLoader.parse( data, this.resourcePath ).geometry;[m
[31m-[m
[31m-[m
[31m-						} else {[m
[31m-[m
[31m-							console.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".' );[m
[31m-[m
[31m-						}[m
[32m+[m						[32mconsole.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );[m
 [m
 						break;[m
 [m
[36m@@ -40022,17 +40493,19 @@[m [mObjectLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 				var geometry = getGeometry( data.geometry );[m
 				var material = getMaterial( data.material );[m
 [m
[31m-				if ( geometry.bones && geometry.bones.length > 0 ) {[m
[31m-[m
[31m-					object = new SkinnedMesh( geometry, material );[m
[32m+[m				[32mobject = new Mesh( geometry, material );[m
 [m
[31m-				} else {[m
[32m+[m				[32mbreak;[m
 [m
[31m-					object = new Mesh( geometry, material );[m
[32m+[m			[32mcase 'InstancedMesh':[m
 [m
[31m-				}[m
[32m+[m				[32mvar geometry = getGeometry( data.geometry );[m
[32m+[m				[32mvar material = getMaterial( data.material );[m
[32m+[m				[32mvar count = data.count;[m
[32m+[m				[32mvar instanceMatrix = data.instanceMatrix;[m
 [m
[31m-				if ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode );[m
[32m+[m				[32mobject = new InstancedMesh( geometry, material, count );[m
[32m+[m				[32mobject.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );[m
 [m
 				break;[m
 [m
[36m@@ -40137,6 +40610,8 @@[m [mObjectLoader.prototype = Object.assign( Object.create( Loader.prototype ), {[m
 [m
 		if ( data.type === 'LOD' ) {[m
 [m
[32m+[m			[32mif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;[m
[32m+[m
 			var levels = data.levels;[m
 [m
 			for ( var l = 0; l < levels.length; l ++ ) {[m
[36m@@ -40315,30 +40790,40 @@[m [mObject.assign( ShapePath.prototype, {[m
 		this.subPaths.push( this.currentPath );[m
 		this.currentPath.moveTo( x, y );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	lineTo: function ( x, y ) {[m
 [m
 		this.currentPath.lineTo( x, y );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {[m
 [m
 		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {[m
 [m
 		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	splineThru: function ( pts ) {[m
 [m
 		this.currentPath.splineThru( pts );[m
 [m
[32m+[m		[32mreturn this;[m
[32m+[m
 	},[m
 [m
 	toShapes: function ( isCCW, noHoles ) {[m
[36m@@ -40609,7 +41094,7 @@[m [mObject.assign( Font.prototype, {[m
 [m
 function createPaths( text, size, data ) {[m
 [m
[31m-	var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988[m
[32m+[m	[32mvar chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // workaround for IE11, see #13988[m
 	var scale = size / data.resolution;[m
 	var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;[m
 [m
[36m@@ -40902,16 +41387,16 @@[m [mObject.assign( SphericalHarmonics3.prototype, {[m
 		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );[m
 [m
 		// band 1[m
[31m-		target.addScale( coeff[ 1 ], 0.488603 * y );[m
[31m-		target.addScale( coeff[ 2 ], 0.488603 * z );[m
[31m-		target.addScale( coeff[ 3 ], 0.488603 * x );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 1 ], 0.488603 * y );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 2 ], 0.488603 * z );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 3 ], 0.488603 * x );[m
 [m
 		// band 2[m
[31m-		target.addScale( coeff[ 4 ], 1.092548 * ( x * y ) );[m
[31m-		target.addScale( coeff[ 5 ], 1.092548 * ( y * z ) );[m
[31m-		target.addScale( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );[m
[31m-		target.addScale( coeff[ 7 ], 1.092548 * ( x * z ) );[m
[31m-		target.addScale( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );[m
 [m
 		return target;[m
 [m
[36m@@ -40932,16 +41417,16 @@[m [mObject.assign( SphericalHarmonics3.prototype, {[m
 		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095[m
 [m
 		// band 1[m
[31m-		target.addScale( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603[m
[31m-		target.addScale( coeff[ 2 ], 2.0 * 0.511664 * z );[m
[31m-		target.addScale( coeff[ 3 ], 2.0 * 0.511664 * x );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );[m
 [m
 		// band 2[m
[31m-		target.addScale( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548[m
[31m-		target.addScale( coeff[ 5 ], 2.0 * 0.429043 * y * z );[m
[31m-		target.addScale( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3[m
[31m-		target.addScale( coeff[ 7 ], 2.0 * 0.429043 * x * z );[m
[31m-		target.addScale( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );[m
[32m+[m		[32mtarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274[m
 [m
 		return target;[m
 [m
[36m@@ -40959,6 +41444,17 @@[m [mObject.assign( SphericalHarmonics3.prototype, {[m
 [m
 	},[m
 [m
[32m+[m	[32maddScaledSH: function ( sh, s ) {[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < 9; i ++ ) {[m
[32m+[m
[32m+[m			[32mthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
 [m
 	scale: function ( s ) {[m
 [m
[36m@@ -41270,7 +41766,7 @@[m [mObject.assign( StereoCamera.prototype, {[m
 			var projectionMatrix = camera.projectionMatrix.clone();[m
 			var eyeSepHalf = cache.eyeSep / 2;[m
 			var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;[m
[31m-			var ymax = ( cache.near * Math.tan( _Math.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;[m
[32m+[m			[32mvar ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;[m
 			var xmin, xmax;[m
 [m
 			// translate xOffset[m
[36m@@ -41536,7 +42032,8 @@[m [mfunction Audio( listener ) {[m
 	this.buffer = null;[m
 	this.detune = 0;[m
 	this.loop = false;[m
[31m-	this.startTime = 0;[m
[32m+[m	[32mthis.loopStart = 0;[m
[32m+[m	[32mthis.loopEnd = 0;[m
 	this.offset = 0;[m
 	this.duration = undefined;[m
 	this.playbackRate = 1;[m
[36m@@ -41544,6 +42041,9 @@[m [mfunction Audio( listener ) {[m
 	this.hasPlaybackControl = true;[m
 	this.sourceType = 'empty';[m
 [m
[32m+[m	[32mthis._startedAt = 0;[m
[32m+[m	[32mthis._pausedAt = 0;[m
[32m+[m
 	this.filters = [];[m
 [m
 }[m
[36m@@ -41602,7 +42102,9 @@[m [mAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 	},[m
 [m
[31m-	play: function () {[m
[32m+[m	[32mplay: function ( delay ) {[m
[32m+[m
[32m+[m		[32mif ( delay === undefined ) delay = 0;[m
 [m
 		if ( this.isPlaying === true ) {[m
 [m
[36m@@ -41618,13 +42120,15 @@[m [mAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 		}[m
 [m
[31m-		var source = this.context.createBufferSource();[m
[32m+[m		[32mthis._startedAt = this.context.currentTime + delay;[m
 [m
[32m+[m		[32mvar source = this.context.createBufferSource();[m
 		source.buffer = this.buffer;[m
 		source.loop = this.loop;[m
[32m+[m		[32msource.loopStart = this.loopStart;[m
[32m+[m		[32msource.loopEnd = this.loopEnd;[m
 		source.onended = this.onEnded.bind( this );[m
[31m-		this.startTime = this.context.currentTime;[m
[31m-		source.start( this.startTime, this.offset, this.duration );[m
[32m+[m		[32msource.start( this._startedAt, this._pausedAt + this.offset, this.duration );[m
 [m
 		this.isPlaying = true;[m
 [m
[36m@@ -41648,9 +42152,11 @@[m [mAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 		if ( this.isPlaying === true ) {[m
 [m
[32m+[m			[32mthis._pausedAt += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;[m
[32m+[m
 			this.source.stop();[m
 			this.source.onended = null;[m
[31m-			this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;[m
[32m+[m
 			this.isPlaying = false;[m
 [m
 		}[m
[36m@@ -41668,9 +42174,10 @@[m [mAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 		}[m
 [m
[32m+[m		[32mthis._pausedAt = 0;[m
[32m+[m
 		this.source.stop();[m
 		this.source.onended = null;[m
[31m-		this.offset = 0;[m
 		this.isPlaying = false;[m
 [m
 		return this;[m
[36m@@ -41852,6 +42359,22 @@[m [mAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {[m
 [m
 	},[m
 [m
[32m+[m	[32msetLoopStart: function ( value ) {[m
[32m+[m
[32m+[m		[32mthis.loopStart = value;[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32msetLoopEnd: function ( value ) {[m
[32m+[m
[32m+[m		[32mthis.loopEnd = value;[m
[32m+[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
 	getVolume: function () {[m
 [m
 		return this.gain.gain.value;[m
[36m@@ -42445,7 +42968,7 @@[m [mObject.assign( PropertyBinding, {[m
 [m
 	findNode: function ( root, nodeName ) {[m
 [m
[31m-		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {[m
[32m+[m		[32mif ( ! nodeName || nodeName === "" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {[m
 [m
 			return root;[m
 [m
[36m@@ -42949,7 +43472,7 @@[m [mObject.assign( PropertyBinding.prototype, { // prototype, continued[m
 [m
 } );[m
 [m
[31m-//!\ DECLARE ALIAS AFTER assign prototype ![m
[32m+[m[32m// DECLARE ALIAS AFTER assign prototype[m
 Object.assign( PropertyBinding.prototype, {[m
 [m
 	// initial state of these methods that calls 'bind'[m
[36m@@ -42991,7 +43514,7 @@[m [mObject.assign( PropertyBinding.prototype, {[m
 [m
 function AnimationObjectGroup() {[m
 [m
[31m-	this.uuid = _Math.generateUUID();[m
[32m+[m	[32mthis.uuid = MathUtils.generateUUID();[m
 [m
 	// cached objects followed by the active ones[m
 	this._objects = Array.prototype.slice.call( arguments );[m
[36m@@ -44849,10 +45372,11 @@[m [mfunction Raycaster( origin, direction, near, far ) {[m
 	this.near = near || 0;[m
 	this.far = far || Infinity;[m
 	this.camera = null;[m
[32m+[m	[32mthis.layers = new Layers();[m
 [m
 	this.params = {[m
 		Mesh: {},[m
[31m-		Line: {},[m
[32m+[m		[32mLine: { threshold: 1 },[m
 		LOD: {},[m
 		Points: { threshold: 1 },[m
 		Sprite: {}[m
[36m@@ -44879,9 +45403,11 @@[m [mfunction ascSort( a, b ) {[m
 [m
 function intersectObject( object, raycaster, intersects, recursive ) {[m
 [m
[31m-	if ( object.visible === false ) return;[m
[32m+[m	[32mif ( object.layers.test( raycaster.layers ) ) {[m
 [m
[31m-	object.raycast( raycaster, intersects );[m
[32m+[m		[32mobject.raycast( raycaster, intersects );[m
[32m+[m
[32m+[m	[32m}[m
 [m
 	if ( recursive === true ) {[m
 [m
[36m@@ -44899,8 +45425,6 @@[m [mfunction intersectObject( object, raycaster, intersects, recursive ) {[m
 [m
 Object.assign( Raycaster.prototype, {[m
 [m
[31m-	linePrecision: 1,[m
[31m-[m
 	set: function ( origin, direction ) {[m
 [m
 		// direction is assumed to be normalized (for accurate distance calculations)[m
[36m@@ -44975,7 +45499,7 @@[m [mObject.assign( Raycaster.prototype, {[m
  * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system[m
  *[m
  * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.[m
[31m- * The azimuthal angle (theta) is measured from the positive z-axiz.[m
[32m+[m[32m * The azimuthal angle (theta) is measured from the positive z-axis.[m
  */[m
 [m
 function Spherical( radius, phi, theta ) {[m
[36m@@ -45044,7 +45568,7 @@[m [mObject.assign( Spherical.prototype, {[m
 		} else {[m
 [m
 			this.theta = Math.atan2( x, z );[m
[31m-			this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );[m
[32m+[m			[32mthis.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );[m
 [m
 		}[m
 [m
[36m@@ -45121,7 +45645,7 @@[m [mObject.assign( Cylindrical.prototype, {[m
  * @author bhouston / http://clara.io[m
  */[m
 [m
[31m-var _vector$6 = new Vector2();[m
[32m+[m[32mvar _vector$7 = new Vector2();[m
 [m
 function Box2( min, max ) {[m
 [m
[36m@@ -45157,7 +45681,7 @@[m [mObject.assign( Box2.prototype, {[m
 [m
 	setFromCenterAndSize: function ( center, size ) {[m
 [m
[31m-		var halfSize = _vector$6.copy( size ).multiplyScalar( 0.5 );[m
[32m+[m		[32mvar halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );[m
 		this.min.copy( center ).sub( halfSize );[m
 		this.max.copy( center ).add( halfSize );[m
 [m
[36m@@ -45307,7 +45831,7 @@[m [mObject.assign( Box2.prototype, {[m
 [m
 	distanceToPoint: function ( point ) {[m
 [m
[31m-		var clampedPoint = _vector$6.copy( point ).clamp( this.min, this.max );[m
[32m+[m		[32mvar clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );[m
 		return clampedPoint.sub( point ).length();[m
 [m
 	},[m
[36m@@ -45450,7 +45974,7 @@[m [mObject.assign( Line3.prototype, {[m
 [m
 		if ( clampToLine ) {[m
 [m
[31m-			t = _Math.clamp( t, 0, 1 );[m
[32m+[m			[32mt = MathUtils.clamp( t, 0, 1 );[m
 [m
 		}[m
 [m
[36m@@ -45508,152 +46032,13 @@[m [mImmediateRenderObject.prototype.constructor = ImmediateRenderObject;[m
 [m
 ImmediateRenderObject.prototype.isImmediateRenderObject = true;[m
 [m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- * @author WestLangley / http://github.com/WestLangley[m
[31m- */[m
[31m-[m
[31m-var _v1$5 = new Vector3();[m
[31m-var _v2$3 = new Vector3();[m
[31m-var _normalMatrix$1 = new Matrix3();[m
[31m-var _keys = [ 'a', 'b', 'c' ];[m
[31m-[m
[31m-function VertexNormalsHelper( object, size, hex, linewidth ) {[m
[31m-[m
[31m-	this.object = object;[m
[31m-[m
[31m-	this.size = ( size !== undefined ) ? size : 1;[m
[31m-[m
[31m-	var color = ( hex !== undefined ) ? hex : 0xff0000;[m
[31m-[m
[31m-	var width = ( linewidth !== undefined ) ? linewidth : 1;[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	var nNormals = 0;[m
[31m-[m
[31m-	var objGeometry = this.object.geometry;[m
[31m-[m
[31m-	if ( objGeometry && objGeometry.isGeometry ) {[m
[31m-[m
[31m-		nNormals = objGeometry.faces.length * 3;[m
[31m-[m
[31m-	} else if ( objGeometry && objGeometry.isBufferGeometry ) {[m
[31m-[m
[31m-		nNormals = objGeometry.attributes.normal.count;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	var geometry = new BufferGeometry();[m
[31m-[m
[31m-	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );[m
[31m-[m
[31m-	geometry.addAttribute( 'position', positions );[m
[31m-[m
[31m-	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	this.matrixAutoUpdate = false;[m
[31m-[m
[31m-	this.update();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );[m
[31m-VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;[m
[31m-[m
[31m-VertexNormalsHelper.prototype.update = function () {[m
[31m-[m
[31m-	this.object.updateMatrixWorld( true );[m
[31m-[m
[31m-	_normalMatrix$1.getNormalMatrix( this.object.matrixWorld );[m
[31m-[m
[31m-	var matrixWorld = this.object.matrixWorld;[m
[31m-[m
[31m-	var position = this.geometry.attributes.position;[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	var objGeometry = this.object.geometry;[m
[31m-[m
[31m-	if ( objGeometry && objGeometry.isGeometry ) {[m
[31m-[m
[31m-		var vertices = objGeometry.vertices;[m
[31m-[m
[31m-		var faces = objGeometry.faces;[m
[31m-[m
[31m-		var idx = 0;[m
[31m-[m
[31m-		for ( var i = 0, l = faces.length; i < l; i ++ ) {[m
[31m-[m
[31m-			var face = faces[ i ];[m
[31m-[m
[31m-			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {[m
[31m-[m
[31m-				var vertex = vertices[ face[ _keys[ j ] ] ];[m
[31m-[m
[31m-				var normal = face.vertexNormals[ j ];[m
[31m-[m
[31m-				_v1$5.copy( vertex ).applyMatrix4( matrixWorld );[m
[31m-[m
[31m-				_v2$3.copy( normal ).applyMatrix3( _normalMatrix$1 ).normalize().multiplyScalar( this.size ).add( _v1$5 );[m
[31m-[m
[31m-				position.setXYZ( idx, _v1$5.x, _v1$5.y, _v1$5.z );[m
[31m-[m
[31m-				idx = idx + 1;[m
[31m-[m
[31m-				position.setXYZ( idx, _v2$3.x, _v2$3.y, _v2$3.z );[m
[31m-[m
[31m-				idx = idx + 1;[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	} else if ( objGeometry && objGeometry.isBufferGeometry ) {[m
[31m-[m
[31m-		var objPos = objGeometry.attributes.position;[m
[31m-[m
[31m-		var objNorm = objGeometry.attributes.normal;[m
[31m-[m
[31m-		var idx = 0;[m
[31m-[m
[31m-		// for simplicity, ignore index and drawcalls, and render every normal[m
[31m-[m
[31m-		for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {[m
[31m-[m
[31m-			_v1$5.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );[m
[31m-[m
[31m-			_v2$3.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );[m
[31m-[m
[31m-			_v2$3.applyMatrix3( _normalMatrix$1 ).normalize().multiplyScalar( this.size ).add( _v1$5 );[m
[31m-[m
[31m-			position.setXYZ( idx, _v1$5.x, _v1$5.y, _v1$5.z );[m
[31m-[m
[31m-			idx = idx + 1;[m
[31m-[m
[31m-			position.setXYZ( idx, _v2$3.x, _v2$3.y, _v2$3.z );[m
[31m-[m
[31m-			idx = idx + 1;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	position.needsUpdate = true;[m
[31m-[m
[31m-};[m
[31m-[m
 /**[m
  * @author alteredq / http://alteredqualia.com/[m
  * @author mrdoob / http://mrdoob.com/[m
  * @author WestLangley / http://github.com/WestLangley[m
  */[m
 [m
[31m-var _vector$7 = new Vector3();[m
[32m+[m[32mvar _vector$8 = new Vector3();[m
 [m
 function SpotLightHelper( light, color ) {[m
 [m
[36m@@ -45689,9 +46074,9 @@[m [mfunction SpotLightHelper( light, color ) {[m
 [m
 	}[m
 [m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );[m
 [m
[31m-	var material = new LineBasicMaterial( { fog: false } );[m
[32m+[m	[32mvar material = new LineBasicMaterial( { fog: false, toneMapped: false } );[m
 [m
 	this.cone = new LineSegments( geometry, material );[m
 	this.add( this.cone );[m
[36m@@ -45719,9 +46104,9 @@[m [mSpotLightHelper.prototype.update = function () {[m
 [m
 	this.cone.scale.set( coneWidth, coneWidth, coneLength );[m
 [m
[31m-	_vector$7.setFromMatrixPosition( this.light.target.matrixWorld );[m
[32m+[m	[32m_vector$8.setFromMatrixPosition( this.light.target.matrixWorld );[m
 [m
[31m-	this.cone.lookAt( _vector$7 );[m
[32m+[m	[32mthis.cone.lookAt( _vector$8 );[m
 [m
 	if ( this.color !== undefined ) {[m
 [m
[36m@@ -45743,7 +46128,7 @@[m [mSpotLightHelper.prototype.update = function () {[m
  * @author Mugen87 / https://github.com/Mugen87[m
  */[m
 [m
[31m-var _vector$8 = new Vector3();[m
[32m+[m[32mvar _vector$9 = new Vector3();[m
 var _boneMatrix = new Matrix4();[m
 var _matrixWorldInv = new Matrix4();[m
 [m
[36m@@ -45794,10 +46179,10 @@[m [mfunction SkeletonHelper( object ) {[m
 [m
 	}[m
 [m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
 [m
[31m-	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );[m
[32m+[m	[32mvar material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );[m
 [m
 	LineSegments.call( this, geometry, material );[m
 [m
[36m@@ -45812,6 +46197,8 @@[m [mfunction SkeletonHelper( object ) {[m
 SkeletonHelper.prototype = Object.create( LineSegments.prototype );[m
 SkeletonHelper.prototype.constructor = SkeletonHelper;[m
 [m
[32m+[m[32mSkeletonHelper.prototype.isSkeletonHelper = true;[m
[32m+[m
 SkeletonHelper.prototype.updateMatrixWorld = function ( force ) {[m
 [m
 	var bones = this.bones;[m
[36m@@ -45828,12 +46215,12 @@[m [mSkeletonHelper.prototype.updateMatrixWorld = function ( force ) {[m
 		if ( bone.parent && bone.parent.isBone ) {[m
 [m
 			_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );[m
[31m-			_vector$8.setFromMatrixPosition( _boneMatrix );[m
[31m-			position.setXYZ( j, _vector$8.x, _vector$8.y, _vector$8.z );[m
[32m+[m			[32m_vector$9.setFromMatrixPosition( _boneMatrix );[m
[32m+[m			[32mposition.setXYZ( j, _vector$9.x, _vector$9.y, _vector$9.z );[m
 [m
 			_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );[m
[31m-			_vector$8.setFromMatrixPosition( _boneMatrix );[m
[31m-			position.setXYZ( j + 1, _vector$8.x, _vector$8.y, _vector$8.z );[m
[32m+[m			[32m_vector$9.setFromMatrixPosition( _boneMatrix );[m
[32m+[m			[32mposition.setXYZ( j + 1, _vector$9.x, _vector$9.y, _vector$9.z );[m
 [m
 			j += 2;[m
 [m
[36m@@ -45860,7 +46247,7 @@[m [mfunction PointLightHelper( light, sphereSize, color ) {[m
 	this.color = color;[m
 [m
 	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );[m
[31m-	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );[m
[32m+[m	[32mvar material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );[m
 [m
 	Mesh.call( this, geometry, material );[m
 [m
[36m@@ -45933,89 +46320,13 @@[m [mPointLightHelper.prototype.update = function () {[m
 [m
 };[m
 [m
[31m-/**[m
[31m- * @author abelnation / http://github.com/abelnation[m
[31m- * @author Mugen87 / http://github.com/Mugen87[m
[31m- * @author WestLangley / http://github.com/WestLangley[m
[31m- *[m
[31m- *  This helper must be added as a child of the light[m
[31m- */[m
[31m-[m
[31m-function RectAreaLightHelper( light, color ) {[m
[31m-[m
[31m-	this.type = 'RectAreaLightHelper';[m
[31m-[m
[31m-	this.light = light;[m
[31m-[m
[31m-	this.color = color; // optional hardwired color for the helper[m
[31m-[m
[31m-	var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];[m
[31m-[m
[31m-	var geometry = new BufferGeometry();[m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );[m
[31m-	geometry.computeBoundingSphere();[m
[31m-[m
[31m-	var material = new LineBasicMaterial( { fog: false } );[m
[31m-[m
[31m-	Line.call( this, geometry, material );[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];[m
[31m-[m
[31m-	var geometry2 = new BufferGeometry();[m
[31m-	geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );[m
[31m-	geometry2.computeBoundingSphere();[m
[31m-[m
[31m-	this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );[m
[31m-[m
[31m-	this.update();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-RectAreaLightHelper.prototype = Object.create( Line.prototype );[m
[31m-RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;[m
[31m-[m
[31m-RectAreaLightHelper.prototype.update = function () {[m
[31m-[m
[31m-	this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );[m
[31m-[m
[31m-	if ( this.color !== undefined ) {[m
[31m-[m
[31m-		this.material.color.set( this.color );[m
[31m-		this.children[ 0 ].material.color.set( this.color );[m
[31m-[m
[31m-	} else {[m
[31m-[m
[31m-		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );[m
[31m-[m
[31m-		// prevent hue shift[m
[31m-		var c = this.material.color;[m
[31m-		var max = Math.max( c.r, c.g, c.b );[m
[31m-		if ( max > 1 ) c.multiplyScalar( 1 / max );[m
[31m-[m
[31m-		this.children[ 0 ].material.color.copy( this.material.color );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-};[m
[31m-[m
[31m-RectAreaLightHelper.prototype.dispose = function () {[m
[31m-[m
[31m-	this.geometry.dispose();[m
[31m-	this.material.dispose();[m
[31m-	this.children[ 0 ].geometry.dispose();[m
[31m-	this.children[ 0 ].material.dispose();[m
[31m-[m
[31m-};[m
[31m-[m
 /**[m
  * @author alteredq / http://alteredqualia.com/[m
  * @author mrdoob / http://mrdoob.com/[m
  * @author Mugen87 / https://github.com/Mugen87[m
  */[m
 [m
[31m-var _vector$9 = new Vector3();[m
[32m+[m[32mvar _vector$a = new Vector3();[m
 var _color1 = new Color();[m
 var _color2 = new Color();[m
 [m
[36m@@ -46034,13 +46345,13 @@[m [mfunction HemisphereLightHelper( light, size, color ) {[m
 	var geometry = new OctahedronBufferGeometry( size );[m
 	geometry.rotateY( Math.PI * 0.5 );[m
 [m
[31m-	this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );[m
[31m-	if ( this.color === undefined ) this.material.vertexColors = VertexColors;[m
[32m+[m	[32mthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );[m
[32m+[m	[32mif ( this.color === undefined ) this.material.vertexColors = true;[m
 [m
 	var position = geometry.getAttribute( 'position' );[m
 	var colors = new Float32Array( position.count * 3 );[m
 [m
[31m-	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );[m
 [m
 	this.add( new Mesh( geometry, this.material ) );[m
 [m
[36m@@ -46085,153 +46396,7 @@[m [mHemisphereLightHelper.prototype.update = function () {[m
 [m
 	}[m
 [m
[31m-	mesh.lookAt( _vector$9.setFromMatrixPosition( this.light.matrixWorld ).negate() );[m
[31m-[m
[31m-};[m
[31m-[m
[31m-/**[m
[31m- * @author WestLangley / http://github.com/WestLangley[m
[31m- */[m
[31m-[m
[31m-function LightProbeHelper( lightProbe, size ) {[m
[31m-[m
[31m-	this.lightProbe = lightProbe;[m
[31m-[m
[31m-	this.size = size;[m
[31m-[m
[31m-	var defines = {};[m
[31m-	defines[ 'GAMMA_OUTPUT' ] = "";[m
[31m-[m
[31m-	// material[m
[31m-	var material = new ShaderMaterial( {[m
[31m-[m
[31m-		defines: defines,[m
[31m-[m
[31m-		uniforms: {[m
[31m-[m
[31m-			sh: { value: this.lightProbe.sh.coefficients }, // by reference[m
[31m-[m
[31m-			intensity: { value: this.lightProbe.intensity }[m
[31m-[m
[31m-		},[m
[31m-[m
[31m-		vertexShader: [[m
[31m-[m
[31m-			'varying vec3 vNormal;',[m
[31m-[m
[31m-			'void main() {',[m
[31m-[m
[31m-			'	vNormal = normalize( normalMatrix * normal );',[m
[31m-[m
[31m-			'	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',[m
[31m-[m
[31m-			'}',[m
[31m-[m
[31m-		].join( '\n' ),[m
[31m-[m
[31m-		fragmentShader: [[m
[31m-[m
[31m-			'#define RECIPROCAL_PI 0.318309886',[m
[31m-[m
[31m-			'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {',[m
[31m-[m
[31m-			'	// matrix is assumed to be orthogonal',[m
[31m-[m
[31m-			'	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );',[m
[31m-[m
[31m-			'}',[m
[31m-[m
[31m-			'vec3 linearToOutput( in vec3 a ) {',[m
[31m-[m
[31m-			'	#ifdef GAMMA_OUTPUT',[m
[31m-[m
[31m-			'		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );',[m
[31m-[m
[31m-			'	#else',[m
[31m-[m
[31m-			'		return a;',[m
[31m-[m
[31m-			'	#endif',[m
[31m-[m
[31m-			'}',[m
[31m-[m
[31m-			'// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf',[m
[31m-			'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {',[m
[31m-[m
[31m-			'	// normal is assumed to have unit length',[m
[31m-[m
[31m-			'	float x = normal.x, y = normal.y, z = normal.z;',[m
[31m-[m
[31m-			'	// band 0',[m
[31m-			'	vec3 result = shCoefficients[ 0 ] * 0.886227;',[m
[31m-[m
[31m-			'	// band 1',[m
[31m-			'	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;',[m
[31m-			'	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;',[m
[31m-			'	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;',[m
[31m-[m
[31m-			'	// band 2',[m
[31m-			'	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;',[m
[31m-			'	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;',[m
[31m-			'	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );',[m
[31m-			'	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;',[m
[31m-			'	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );',[m
[31m-[m
[31m-			'	return result;',[m
[31m-[m
[31m-			'}',[m
[31m-[m
[31m-			'uniform vec3 sh[ 9 ]; // sh coefficients',[m
[31m-[m
[31m-			'uniform float intensity; // light probe intensity',[m
[31m-[m
[31m-			'varying vec3 vNormal;',[m
[31m-[m
[31m-			'void main() {',[m
[31m-[m
[31m-			'	vec3 normal = normalize( vNormal );',[m
[31m-[m
[31m-			'	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );',[m
[31m-[m
[31m-			'	vec3 irradiance = shGetIrradianceAt( worldNormal, sh );',[m
[31m-[m
[31m-			'	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;',[m
[31m-[m
[31m-			'	outgoingLight = linearToOutput( outgoingLight );',[m
[31m-[m
[31m-			'	gl_FragColor = vec4( outgoingLight, 1.0 );',[m
[31m-[m
[31m-			'}'[m
[31m-[m
[31m-		].join( '\n' )[m
[31m-[m
[31m-	} );[m
[31m-[m
[31m-	var geometry = new SphereBufferGeometry( 1, 32, 16 );[m
[31m-[m
[31m-	Mesh.call( this, geometry, material );[m
[31m-[m
[31m-	this.onBeforeRender();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-LightProbeHelper.prototype = Object.create( Mesh.prototype );[m
[31m-LightProbeHelper.prototype.constructor = LightProbeHelper;[m
[31m-[m
[31m-LightProbeHelper.prototype.dispose = function () {[m
[31m-[m
[31m-	this.geometry.dispose();[m
[31m-	this.material.dispose();[m
[31m-[m
[31m-};[m
[31m-[m
[31m-LightProbeHelper.prototype.onBeforeRender = function () {[m
[31m-[m
[31m-	this.position.copy( this.lightProbe.position );[m
[31m-[m
[31m-	this.scale.set( 1, 1, 1 ).multiplyScalar( this.size );[m
[31m-[m
[31m-	this.material.uniforms.intensity.value = this.lightProbe.intensity;[m
[32m+[m	[32mmesh.lookAt( _vector$a.setFromMatrixPosition( this.light.matrixWorld ).negate() );[m
 [m
 };[m
 [m
[36m@@ -46267,10 +46432,10 @@[m [mfunction GridHelper( size, divisions, color1, color2 ) {[m
 	}[m
 [m
 	var geometry = new BufferGeometry();[m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
 [m
[31m-	var material = new LineBasicMaterial( { vertexColors: VertexColors } );[m
[32m+[m	[32mvar material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );[m
 [m
 	LineSegments.call( this, geometry, material );[m
 [m
[36m@@ -46374,10 +46539,10 @@[m [mfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 )[m
 	}[m
 [m
 	var geometry = new BufferGeometry();[m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
 [m
[31m-	var material = new LineBasicMaterial( { vertexColors: VertexColors } );[m
[32m+[m	[32mvar material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );[m
 [m
 	LineSegments.call( this, geometry, material );[m
 [m
[36m@@ -46386,219 +46551,14 @@[m [mfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 )[m
 PolarGridHelper.prototype = Object.create( LineSegments.prototype );[m
 PolarGridHelper.prototype.constructor = PolarGridHelper;[m
 [m
[31m-/**[m
[31m- * @author Mugen87 / http://github.com/Mugen87[m
[31m- */[m
[31m-[m
[31m-function PositionalAudioHelper( audio, range, divisionsInnerAngle, divisionsOuterAngle ) {[m
[31m-[m
[31m-	this.audio = audio;[m
[31m-	this.range = range || 1;[m
[31m-	this.divisionsInnerAngle = divisionsInnerAngle || 16;[m
[31m-	this.divisionsOuterAngle = divisionsOuterAngle || 2;[m
[31m-[m
[31m-	var geometry = new BufferGeometry();[m
[31m-	var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;[m
[31m-	var positions = new Float32Array( ( divisions * 3 + 3 ) * 3 );[m
[31m-	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );[m
[31m-[m
[31m-	var materialInnerAngle = new LineBasicMaterial( { color: 0x00ff00 } );[m
[31m-	var materialOuterAngle = new LineBasicMaterial( { color: 0xffff00 } );[m
[31m-[m
[31m-	Line.call( this, geometry, [ materialOuterAngle, materialInnerAngle ] );[m
[31m-[m
[31m-	this.update();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-PositionalAudioHelper.prototype = Object.create( Line.prototype );[m
[31m-PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;[m
[31m-[m
[31m-PositionalAudioHelper.prototype.update = function () {[m
[31m-[m
[31m-	var audio = this.audio;[m
[31m-	var range = this.range;[m
[31m-	var divisionsInnerAngle = this.divisionsInnerAngle;[m
[31m-	var divisionsOuterAngle = this.divisionsOuterAngle;[m
[31m-[m
[31m-	var coneInnerAngle = _Math.degToRad( audio.panner.coneInnerAngle );[m
[31m-	var coneOuterAngle = _Math.degToRad( audio.panner.coneOuterAngle );[m
[31m-[m
[31m-	var halfConeInnerAngle = coneInnerAngle / 2;[m
[31m-	var halfConeOuterAngle = coneOuterAngle / 2;[m
[31m-[m
[31m-	var start = 0;[m
[31m-	var count = 0;[m
[31m-	var i, stride;[m
[31m-[m
[31m-	var geometry = this.geometry;[m
[31m-	var positionAttribute = geometry.attributes.position;[m
[31m-[m
[31m-	geometry.clearGroups();[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	function generateSegment( from, to, divisions, materialIndex ) {[m
[31m-[m
[31m-		var step = ( to - from ) / divisions;[m
[31m-[m
[31m-		positionAttribute.setXYZ( start, 0, 0, 0 );[m
[31m-		count ++;[m
[31m-[m
[31m-		for ( i = from; i < to; i += step ) {[m
[31m-[m
[31m-			stride = start + count;[m
[31m-[m
[31m-			positionAttribute.setXYZ( stride, Math.sin( i ) * range, 0, Math.cos( i ) * range );[m
[31m-			positionAttribute.setXYZ( stride + 1, Math.sin( Math.min( i + step, to ) ) * range, 0, Math.cos( Math.min( i + step, to ) ) * range );[m
[31m-			positionAttribute.setXYZ( stride + 2, 0, 0, 0 );[m
[31m-[m
[31m-			count += 3;[m
[31m-[m
[31m-		}[m
[31m-[m
[31m-		geometry.addGroup( start, count, materialIndex );[m
[31m-[m
[31m-		start += count;[m
[31m-		count = 0;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	generateSegment( - halfConeOuterAngle, - halfConeInnerAngle, divisionsOuterAngle, 0 );[m
[31m-	generateSegment( - halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1 );[m
[31m-	generateSegment( halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0 );[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	positionAttribute.needsUpdate = true;[m
[31m-[m
[31m-	if ( coneInnerAngle === coneOuterAngle ) this.material[ 0 ].visible = false;[m
[31m-[m
[31m-};[m
[31m-[m
[31m-PositionalAudioHelper.prototype.dispose = function () {[m
[31m-[m
[31m-	this.geometry.dispose();[m
[31m-	this.material[ 0 ].dispose();[m
[31m-	this.material[ 1 ].dispose();[m
[31m-[m
[31m-};[m
[31m-[m
[31m-/**[m
[31m- * @author mrdoob / http://mrdoob.com/[m
[31m- * @author WestLangley / http://github.com/WestLangley[m
[31m- */[m
[31m-[m
[31m-var _v1$6 = new Vector3();[m
[31m-var _v2$4 = new Vector3();[m
[31m-var _normalMatrix$2 = new Matrix3();[m
[31m-[m
[31m-function FaceNormalsHelper( object, size, hex, linewidth ) {[m
[31m-[m
[31m-	// FaceNormalsHelper only supports THREE.Geometry[m
[31m-[m
[31m-	this.object = object;[m
[31m-[m
[31m-	this.size = ( size !== undefined ) ? size : 1;[m
[31m-[m
[31m-	var color = ( hex !== undefined ) ? hex : 0xffff00;[m
[31m-[m
[31m-	var width = ( linewidth !== undefined ) ? linewidth : 1;[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	var nNormals = 0;[m
[31m-[m
[31m-	var objGeometry = this.object.geometry;[m
[31m-[m
[31m-	if ( objGeometry && objGeometry.isGeometry ) {[m
[31m-[m
[31m-		nNormals = objGeometry.faces.length;[m
[31m-[m
[31m-	} else {[m
[31m-[m
[31m-		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	var geometry = new BufferGeometry();[m
[31m-[m
[31m-	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );[m
[31m-[m
[31m-	geometry.addAttribute( 'position', positions );[m
[31m-[m
[31m-	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	this.matrixAutoUpdate = false;[m
[31m-	this.update();[m
[31m-[m
[31m-}[m
[31m-[m
[31m-FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );[m
[31m-FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;[m
[31m-[m
[31m-FaceNormalsHelper.prototype.update = function () {[m
[31m-[m
[31m-	this.object.updateMatrixWorld( true );[m
[31m-[m
[31m-	_normalMatrix$2.getNormalMatrix( this.object.matrixWorld );[m
[31m-[m
[31m-	var matrixWorld = this.object.matrixWorld;[m
[31m-[m
[31m-	var position = this.geometry.attributes.position;[m
[31m-[m
[31m-	//[m
[31m-[m
[31m-	var objGeometry = this.object.geometry;[m
[31m-[m
[31m-	var vertices = objGeometry.vertices;[m
[31m-[m
[31m-	var faces = objGeometry.faces;[m
[31m-[m
[31m-	var idx = 0;[m
[31m-[m
[31m-	for ( var i = 0, l = faces.length; i < l; i ++ ) {[m
[31m-[m
[31m-		var face = faces[ i ];[m
[31m-[m
[31m-		var normal = face.normal;[m
[31m-[m
[31m-		_v1$6.copy( vertices[ face.a ] )[m
[31m-			.add( vertices[ face.b ] )[m
[31m-			.add( vertices[ face.c ] )[m
[31m-			.divideScalar( 3 )[m
[31m-			.applyMatrix4( matrixWorld );[m
[31m-[m
[31m-		_v2$4.copy( normal ).applyMatrix3( _normalMatrix$2 ).normalize().multiplyScalar( this.size ).add( _v1$6 );[m
[31m-[m
[31m-		position.setXYZ( idx, _v1$6.x, _v1$6.y, _v1$6.z );[m
[31m-[m
[31m-		idx = idx + 1;[m
[31m-[m
[31m-		position.setXYZ( idx, _v2$4.x, _v2$4.y, _v2$4.z );[m
[31m-[m
[31m-		idx = idx + 1;[m
[31m-[m
[31m-	}[m
[31m-[m
[31m-	position.needsUpdate = true;[m
[31m-[m
[31m-};[m
[31m-[m
 /**[m
  * @author alteredq / http://alteredqualia.com/[m
  * @author mrdoob / http://mrdoob.com/[m
  * @author WestLangley / http://github.com/WestLangley[m
  */[m
 [m
[31m-var _v1$7 = new Vector3();[m
[31m-var _v2$5 = new Vector3();[m
[32m+[m[32mvar _v1$5 = new Vector3();[m
[32m+[m[32mvar _v2$3 = new Vector3();[m
 var _v3$1 = new Vector3();[m
 [m
 function DirectionalLightHelper( light, size, color ) {[m
[36m@@ -46616,7 +46576,7 @@[m [mfunction DirectionalLightHelper( light, size, color ) {[m
 	if ( size === undefined ) size = 1;[m
 [m
 	var geometry = new BufferGeometry();[m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( [[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( [[m
 		- size, size, 0,[m
 		size, size, 0,[m
 		size, - size, 0,[m
[36m@@ -46624,13 +46584,13 @@[m [mfunction DirectionalLightHelper( light, size, color ) {[m
 		- size, size, 0[m
 	], 3 ) );[m
 [m
[31m-	var material = new LineBasicMaterial( { fog: false } );[m
[32m+[m	[32mvar material = new LineBasicMaterial( { fog: false, toneMapped: false } );[m
 [m
 	this.lightPlane = new Line( geometry, material );[m
 	this.add( this.lightPlane );[m
 [m
 	geometry = new BufferGeometry();[m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );[m
 [m
 	this.targetLine = new Line( geometry, material );[m
 	this.add( this.targetLine );[m
[36m@@ -46653,11 +46613,11 @@[m [mDirectionalLightHelper.prototype.dispose = function () {[m
 [m
 DirectionalLightHelper.prototype.update = function () {[m
 [m
[31m-	_v1$7.setFromMatrixPosition( this.light.matrixWorld );[m
[31m-	_v2$5.setFromMatrixPosition( this.light.target.matrixWorld );[m
[31m-	_v3$1.subVectors( _v2$5, _v1$7 );[m
[32m+[m	[32m_v1$5.setFromMatrixPosition( this.light.matrixWorld );[m
[32m+[m	[32m_v2$3.setFromMatrixPosition( this.light.target.matrixWorld );[m
[32m+[m	[32m_v3$1.subVectors( _v2$3, _v1$5 );[m
 [m
[31m-	this.lightPlane.lookAt( _v2$5 );[m
[32m+[m	[32mthis.lightPlane.lookAt( _v2$3 );[m
 [m
 	if ( this.color !== undefined ) {[m
 [m
[36m@@ -46671,7 +46631,7 @@[m [mDirectionalLightHelper.prototype.update = function () {[m
 [m
 	}[m
 [m
[31m-	this.targetLine.lookAt( _v2$5 );[m
[32m+[m	[32mthis.targetLine.lookAt( _v2$3 );[m
 	this.targetLine.scale.z = _v3$1.length();[m
 [m
 };[m
[36m@@ -46686,13 +46646,13 @@[m [mDirectionalLightHelper.prototype.update = function () {[m
  *		http://evanw.github.com/lightgl.js/tests/shadowmap.html[m
  */[m
 [m
[31m-var _vector$a = new Vector3();[m
[32m+[m[32mvar _vector$b = new Vector3();[m
 var _camera = new Camera();[m
 [m
 function CameraHelper( camera ) {[m
 [m
 	var geometry = new BufferGeometry();[m
[31m-	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );[m
[32m+[m	[32mvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );[m
 [m
 	var vertices = [];[m
 	var colors = [];[m
[36m@@ -46776,8 +46736,8 @@[m [mfunction CameraHelper( camera ) {[m
 [m
 	}[m
 [m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
 [m
 	LineSegments.call( this, geometry, material );[m
 [m
[36m@@ -46851,7 +46811,7 @@[m [mCameraHelper.prototype.update = function () {[m
 [m
 function setPoint( point, pointMap, geometry, camera, x, y, z ) {[m
 [m
[31m-	_vector$a.set( x, y, z ).unproject( camera );[m
[32m+[m	[32m_vector$b.set( x, y, z ).unproject( camera );[m
 [m
 	var points = pointMap[ point ];[m
 [m
[36m@@ -46861,7 +46821,7 @@[m [mfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {[m
 [m
 		for ( var i = 0, l = points.length; i < l; i ++ ) {[m
 [m
[31m-			position.setXYZ( points[ i ], _vector$a.x, _vector$a.y, _vector$a.z );[m
[32m+[m			[32mposition.setXYZ( points[ i ], _vector$b.x, _vector$b.y, _vector$b.z );[m
 [m
 		}[m
 [m
[36m@@ -46874,7 +46834,7 @@[m [mfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {[m
  * @author Mugen87 / http://github.com/Mugen87[m
  */[m
 [m
[31m-var _box$2 = new Box3();[m
[32m+[m[32mvar _box$3 = new Box3();[m
 [m
 function BoxHelper( object, color ) {[m
 [m
[36m@@ -46887,9 +46847,9 @@[m [mfunction BoxHelper( object, color ) {[m
 [m
 	var geometry = new BufferGeometry();[m
 	geometry.setIndex( new BufferAttribute( indices, 1 ) );[m
[31m-	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );[m
 [m
[31m-	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );[m
[32m+[m	[32mLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );[m
 [m
 	this.matrixAutoUpdate = false;[m
 [m
[36m@@ -46910,14 +46870,14 @@[m [mBoxHelper.prototype.update = function ( object ) {[m
 [m
 	if ( this.object !== undefined ) {[m
 [m
[31m-		_box$2.setFromObject( this.object );[m
[32m+[m		[32m_box$3.setFromObject( this.object );[m
 [m
 	}[m
 [m
[31m-	if ( _box$2.isEmpty() ) return;[m
[32m+[m	[32mif ( _box$3.isEmpty() ) return;[m
 [m
[31m-	var min = _box$2.min;[m
[31m-	var max = _box$2.max;[m
[32m+[m	[32mvar min = _box$3.min;[m
[32m+[m	[32mvar max = _box$3.max;[m
 [m
 	/*[m
 	  5____4[m
[36m@@ -46999,9 +46959,9 @@[m [mfunction Box3Helper( box, color ) {[m
 [m
 	geometry.setIndex( new BufferAttribute( indices, 1 ) );[m
 [m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );[m
 [m
[31m-	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );[m
[32m+[m	[32mLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );[m
 [m
 	this.geometry.computeBoundingSphere();[m
 [m
[36m@@ -47043,20 +47003,20 @@[m [mfunction PlaneHelper( plane, size, hex ) {[m
 	var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];[m
 [m
 	var geometry = new BufferGeometry();[m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );[m
 	geometry.computeBoundingSphere();[m
 [m
[31m-	Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );[m
[32m+[m	[32mLine.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );[m
 [m
 	//[m
 [m
 	var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];[m
 [m
 	var geometry2 = new BufferGeometry();[m
[31m-	geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );[m
[32m+[m	[32mgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );[m
 	geometry2.computeBoundingSphere();[m
 [m
[31m-	this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );[m
[32m+[m	[32mthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );[m
 [m
 }[m
 [m
[36m@@ -47114,7 +47074,7 @@[m [mfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {[m
 	if ( _lineGeometry === undefined ) {[m
 [m
 		_lineGeometry = new BufferGeometry();[m
[31m-		_lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );[m
[32m+[m		[32m_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );[m
 [m
 		_coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );[m
 		_coneGeometry.translate( 0, - 0.5, 0 );[m
[36m@@ -47123,11 +47083,11 @@[m [mfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {[m
 [m
 	this.position.copy( origin );[m
 [m
[31m-	this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color } ) );[m
[32m+[m	[32mthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );[m
 	this.line.matrixAutoUpdate = false;[m
 	this.add( this.line );[m
 [m
[31m-	this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color } ) );[m
[32m+[m	[32mthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );[m
 	this.cone.matrixAutoUpdate = false;[m
 	this.add( this.cone );[m
 [m
[36m@@ -47223,10 +47183,10 @@[m [mfunction AxesHelper( size ) {[m
 	];[m
 [m
 	var geometry = new BufferGeometry();[m
[31m-	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[31m-	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );[m
[32m+[m	[32mgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );[m
 [m
[31m-	var material = new LineBasicMaterial( { vertexColors: VertexColors } );[m
[32m+[m	[32mvar material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );[m
 [m
 	LineSegments.call( this, geometry, material );[m
 [m
[36m@@ -47235,6 +47195,831 @@[m [mfunction AxesHelper( size ) {[m
 AxesHelper.prototype = Object.create( LineSegments.prototype );[m
 AxesHelper.prototype.constructor = AxesHelper;[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * @author Emmett Lalish / elalish[m
[32m+[m[32m *[m
[32m+[m[32m * This class generates a Prefiltered, Mipmapped Radiance Environment Map[m
[32m+[m[32m * (PMREM) from a cubeMap environment texture. This allows different levels of[m
[32m+[m[32m * blur to be quickly accessed based on material roughness. It is packed into a[m
[32m+[m[32m * special CubeUV format that allows us to perform custom interpolation so that[m
[32m+[m[32m * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap[m
[32m+[m[32m * chain, it only goes down to the LOD_MIN level (above), and then creates extra[m
[32m+[m[32m * even more filtered 'mips' at the same LOD_MIN resolution, associated with[m
[32m+[m[32m * higher roughness levels. In this way we maintain resolution to smoothly[m
[32m+[m[32m * interpolate diffuse lighting while limiting sampling computation.[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mvar LOD_MIN = 4;[m
[32m+[m[32mvar LOD_MAX = 8;[m
[32m+[m[32mvar SIZE_MAX = Math.pow( 2, LOD_MAX );[m
[32m+[m[32m// The standard deviations (radians) associated with the extra mips. These are[m
[32m+[m[32m// chosen to approximate a Trowbridge-Reitz distribution function times the[m
[32m+[m[32m// geometric shadowing function. These sigma values squared must match the[m
[32m+[m[32m// variance #defines in cube_uv_reflection_fragment.glsl.js.[m
[32m+[m[32mvar EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];[m
[32m+[m[32mvar TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;[m
[32m+[m[32m// The maximum length of the blur for loop. Smaller sigmas will use fewer[m
[32m+[m[32m// samples and exit early, but not recompile the shader.[m
[32m+[m[32mvar MAX_SAMPLES = 20;[m
[32m+[m[32mvar ENCODINGS = {[m
[32m+[m	[32m[ LinearEncoding ]: 0,[m
[32m+[m	[32m[ sRGBEncoding ]: 1,[m
[32m+[m	[32m[ RGBEEncoding ]: 2,[m
[32m+[m	[32m[ RGBM7Encoding ]: 3,[m
[32m+[m	[32m[ RGBM16Encoding ]: 4,[m
[32m+[m	[32m[ RGBDEncoding ]: 5,[m
[32m+[m	[32m[ GammaEncoding ]: 6[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mvar _flatCamera = new OrthographicCamera();[m
[32m+[m[32mvar { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();[m
[32m+[m[32mvar _oldTarget = null;[m
[32m+[m
[32m+[m[32m// Golden Ratio[m
[32m+[m[32mvar PHI = ( 1 + Math.sqrt( 5 ) ) / 2;[m
[32m+[m[32mvar INV_PHI = 1 / PHI;[m
[32m+[m[32m// Vertices of a dodecahedron (except the opposites, which represent the[m
[32m+[m[32m// same axis), used as axis directions evenly spread on a sphere.[m
[32m+[m[32mvar _axisDirections = [[m
[32m+[m	[32mnew Vector3( 1, 1, 1 ),[m
[32m+[m	[32mnew Vector3( - 1, 1, 1 ),[m
[32m+[m	[32mnew Vector3( 1, 1, - 1 ),[m
[32m+[m	[32mnew Vector3( - 1, 1, - 1 ),[m
[32m+[m	[32mnew Vector3( 0, PHI, INV_PHI ),[m
[32m+[m	[32mnew Vector3( 0, PHI, - INV_PHI ),[m
[32m+[m	[32mnew Vector3( INV_PHI, 0, PHI ),[m
[32m+[m	[32mnew Vector3( - INV_PHI, 0, PHI ),[m
[32m+[m	[32mnew Vector3( PHI, INV_PHI, 0 ),[m
[32m+[m	[32mnew Vector3( - PHI, INV_PHI, 0 ) ];[m
[32m+[m
[32m+[m[32mfunction PMREMGenerator( renderer ) {[m
[32m+[m
[32m+[m	[32mthis._renderer = renderer;[m
[32m+[m	[32mthis._pingPongRenderTarget = null;[m
[32m+[m
[32m+[m	[32mthis._blurMaterial = _getBlurShader( MAX_SAMPLES );[m
[32m+[m	[32mthis._equirectShader = null;[m
[32m+[m	[32mthis._cubemapShader = null;[m
[32m+[m
[32m+[m	[32mthis._compileMaterial( this._blurMaterial );[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mPMREMGenerator.prototype = {[m
[32m+[m
[32m+[m	[32mconstructor: PMREMGenerator,[m
[32m+[m
[32m+[m	[32m/**[m
[32m+[m	[32m * Generates a PMREM from a supplied Scene, which can be faster than using an[m
[32m+[m	[32m * image if networking bandwidth is low. Optional sigma specifies a blur radius[m
[32m+[m	[32m * in radians to be applied to the scene before PMREM generation. Optional near[m
[32m+[m	[32m * and far planes ensure the scene is rendered in its entirety (the cubeCamera[m
[32m+[m	[32m * is placed at the origin).[m
[32m+[m	[32m */[m
[32m+[m	[32mfromScene: function ( scene, sigma = 0, near = 0.1, far = 100 ) {[m
[32m+[m
[32m+[m		[32m_oldTarget = this._renderer.getRenderTarget();[m
[32m+[m		[32mvar cubeUVRenderTarget = this._allocateTargets();[m
[32m+[m
[32m+[m		[32mthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );[m
[32m+[m		[32mif ( sigma > 0 ) {[m
[32m+[m
[32m+[m			[32mthis._blur( cubeUVRenderTarget, 0, 0, sigma );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m		[32mthis._applyPMREM( cubeUVRenderTarget );[m
[32m+[m		[32mthis._cleanup( cubeUVRenderTarget );[m
[32m+[m
[32m+[m		[32mreturn cubeUVRenderTarget;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m/**[m
[32m+[m	[32m * Generates a PMREM from an equirectangular texture, which can be either LDR[m
[32m+[m	[32m * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),[m
[32m+[m	[32m * as this matches best with the 256 x 256 cubemap output.[m
[32m+[m	[32m */[m
[32m+[m	[32mfromEquirectangular: function ( equirectangular ) {[m
[32m+[m
[32m+[m		[32mequirectangular.magFilter = NearestFilter;[m
[32m+[m		[32mequirectangular.minFilter = NearestFilter;[m
[32m+[m		[32mequirectangular.generateMipmaps = false;[m
[32m+[m
[32m+[m		[32mreturn this.fromCubemap( equirectangular );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m/**[m
[32m+[m	[32m * Generates a PMREM from an cubemap texture, which can be either LDR[m
[32m+[m	[32m * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,[m
[32m+[m	[32m * as this matches best with the 256 x 256 cubemap output.[m
[32m+[m	[32m */[m
[32m+[m	[32mfromCubemap: function ( cubemap ) {[m
[32m+[m
[32m+[m		[32m_oldTarget = this._renderer.getRenderTarget();[m
[32m+[m		[32mvar cubeUVRenderTarget = this._allocateTargets( cubemap );[m
[32m+[m		[32mthis._textureToCubeUV( cubemap, cubeUVRenderTarget );[m
[32m+[m		[32mthis._applyPMREM( cubeUVRenderTarget );[m
[32m+[m		[32mthis._cleanup( cubeUVRenderTarget );[m
[32m+[m
[32m+[m		[32mreturn cubeUVRenderTarget;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m/**[m
[32m+[m	[32m * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during[m
[32m+[m	[32m * your texture's network fetch for increased concurrency.[m
[32m+[m	[32m */[m
[32m+[m	[32mcompileCubemapShader: function () {[m
[32m+[m
[32m+[m		[32mif ( this._cubemapShader === null ) {[m
[32m+[m
[32m+[m			[32mthis._cubemapShader = _getCubemapShader();[m
[32m+[m			[32mthis._compileMaterial( this._cubemapShader );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m/**[m
[32m+[m	[32m * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during[m
[32m+[m	[32m * your texture's network fetch for increased concurrency.[m
[32m+[m	[32m */[m
[32m+[m	[32mcompileEquirectangularShader: function () {[m
[32m+[m
[32m+[m		[32mif ( this._equirectShader === null ) {[m
[32m+[m
[32m+[m			[32mthis._equirectShader = _getEquirectShader();[m
[32m+[m			[32mthis._compileMaterial( this._equirectShader );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m/**[m
[32m+[m	[32m * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,[m
[32m+[m	[32m * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on[m
[32m+[m	[32m * one of them will cause any others to also become unusable.[m
[32m+[m	[32m */[m
[32m+[m	[32mdispose: function () {[m
[32m+[m
[32m+[m		[32mthis._blurMaterial.dispose();[m
[32m+[m
[32m+[m		[32mif ( this._cubemapShader !== null ) this._cubemapShader.dispose();[m
[32m+[m		[32mif ( this._equirectShader !== null ) this._equirectShader.dispose();[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < _lodPlanes.length; i ++ ) {[m
[32m+[m
[32m+[m			[32m_lodPlanes[ i ].dispose();[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m// private interface[m
[32m+[m
[32m+[m	[32m_cleanup: function ( outputTarget ) {[m
[32m+[m
[32m+[m		[32mthis._pingPongRenderTarget.dispose();[m
[32m+[m		[32mthis._renderer.setRenderTarget( _oldTarget );[m
[32m+[m		[32moutputTarget.scissorTest = false;[m
[32m+[m		[32m// reset viewport and scissor[m
[32m+[m		[32moutputTarget.setSize( outputTarget.width, outputTarget.height );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m_allocateTargets: function ( equirectangular ) {[m
[32m+[m
[32m+[m		[32mvar params = {[m
[32m+[m			[32mmagFilter: NearestFilter,[m
[32m+[m			[32mminFilter: NearestFilter,[m
[32m+[m			[32mgenerateMipmaps: false,[m
[32m+[m			[32mtype: equirectangular ? equirectangular.type : UnsignedByteType,[m
[32m+[m			[32mformat: equirectangular ? equirectangular.format : RGBEFormat,[m
[32m+[m			[32mencoding: equirectangular ? equirectangular.encoding : RGBEEncoding,[m
[32m+[m			[32mdepthBuffer: false,[m
[32m+[m			[32mstencilBuffer: false[m
[32m+[m		[32m};[m
[32m+[m		[32mvar cubeUVRenderTarget = _createRenderTarget( params );[m
[32m+[m		[32mcubeUVRenderTarget.depthBuffer = equirectangular ? false : true;[m
[32m+[m		[32mthis._pingPongRenderTarget = _createRenderTarget( params );[m
[32m+[m		[32mreturn cubeUVRenderTarget;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m_compileMaterial: function ( material ) {[m
[32m+[m
[32m+[m		[32mvar tmpScene = new Scene();[m
[32m+[m		[32mtmpScene.add( new Mesh( _lodPlanes[ 0 ], material ) );[m
[32m+[m		[32mthis._renderer.compile( tmpScene, _flatCamera );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m_sceneToCubeUV: function ( scene, near, far, cubeUVRenderTarget ) {[m
[32m+[m
[32m+[m		[32mvar fov = 90;[m
[32m+[m		[32mvar aspect = 1;[m
[32m+[m		[32mvar cubeCamera = new PerspectiveCamera( fov, aspect, near, far );[m
[32m+[m		[32mvar upSign = [ 1, 1, 1, 1, - 1, 1 ];[m
[32m+[m		[32mvar forwardSign = [ 1, 1, - 1, - 1, - 1, 1 ];[m
[32m+[m		[32mvar renderer = this._renderer;[m
[32m+[m
[32m+[m		[32mvar outputEncoding = renderer.outputEncoding;[m
[32m+[m		[32mvar toneMapping = renderer.toneMapping;[m
[32m+[m		[32mvar toneMappingExposure = renderer.toneMappingExposure;[m
[32m+[m		[32mvar clearColor = renderer.getClearColor();[m
[32m+[m		[32mvar clearAlpha = renderer.getClearAlpha();[m
[32m+[m
[32m+[m		[32mrenderer.toneMapping = LinearToneMapping;[m
[32m+[m		[32mrenderer.toneMappingExposure = 1.0;[m
[32m+[m		[32mrenderer.outputEncoding = LinearEncoding;[m
[32m+[m		[32mscene.scale.z *= - 1;[m
[32m+[m
[32m+[m		[32mvar background = scene.background;[m
[32m+[m		[32mif ( background && background.isColor ) {[m
[32m+[m
[32m+[m			[32mbackground.convertSRGBToLinear();[m
[32m+[m			[32m// Convert linear to RGBE[m
[32m+[m			[32mvar maxComponent = Math.max( background.r, background.g, background.b );[m
[32m+[m			[32mvar fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );[m
[32m+[m			[32mbackground = background.multiplyScalar( Math.pow( 2.0, - fExp ) );[m
[32m+[m			[32mvar alpha = ( fExp + 128.0 ) / 255.0;[m
[32m+[m			[32mrenderer.setClearColor( background, alpha );[m
[32m+[m			[32mscene.background = null;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < 6; i ++ ) {[m
[32m+[m
[32m+[m			[32mvar col = i % 3;[m
[32m+[m			[32mif ( col == 0 ) {[m
[32m+[m
[32m+[m				[32mcubeCamera.up.set( 0, upSign[ i ], 0 );[m
[32m+[m				[32mcubeCamera.lookAt( forwardSign[ i ], 0, 0 );[m
[32m+[m
[32m+[m			[32m} else if ( col == 1 ) {[m
[32m+[m
[32m+[m				[32mcubeCamera.up.set( 0, 0, upSign[ i ] );[m
[32m+[m				[32mcubeCamera.lookAt( 0, forwardSign[ i ], 0 );[m
[32m+[m
[32m+[m			[32m} else {[m
[32m+[m
[32m+[m				[32mcubeCamera.up.set( 0, upSign[ i ], 0 );[m
[32m+[m				[32mcubeCamera.lookAt( 0, 0, forwardSign[ i ] );[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m			[32m_setViewport( cubeUVRenderTarget,[m
[32m+[m				[32mcol * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );[m
[32m+[m			[32mrenderer.setRenderTarget( cubeUVRenderTarget );[m
[32m+[m			[32mrenderer.render( scene, cubeCamera );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mrenderer.toneMapping = toneMapping;[m
[32m+[m		[32mrenderer.toneMappingExposure = toneMappingExposure;[m
[32m+[m		[32mrenderer.outputEncoding = outputEncoding;[m
[32m+[m		[32mrenderer.setClearColor( clearColor, clearAlpha );[m
[32m+[m		[32mscene.scale.z *= - 1;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m_textureToCubeUV: function ( texture, cubeUVRenderTarget ) {[m
[32m+[m
[32m+[m		[32mvar scene = new Scene();[m
[32m+[m		[32mvar renderer = this._renderer;[m
[32m+[m
[32m+[m		[32mif ( texture.isCubeTexture ) {[m
[32m+[m
[32m+[m			[32mif ( this._cubemapShader == null ) {[m
[32m+[m
[32m+[m				[32mthis._cubemapShader = _getCubemapShader();[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m} else {[m
[32m+[m
[32m+[m			[32mif ( this._equirectShader == null ) {[m
[32m+[m
[32m+[m				[32mthis._equirectShader = _getEquirectShader();[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mvar material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;[m
[32m+[m		[32mscene.add( new Mesh( _lodPlanes[ 0 ], material ) );[m
[32m+[m		[32mvar uniforms = material.uniforms;[m
[32m+[m
[32m+[m		[32muniforms[ 'envMap' ].value = texture;[m
[32m+[m		[32mif ( ! texture.isCubeTexture ) {[m
[32m+[m
[32m+[m			[32muniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m		[32muniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];[m
[32m+[m		[32muniforms[ 'outputEncoding' ].value = ENCODINGS[ texture.encoding ];[m
[32m+[m
[32m+[m		[32m_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );[m
[32m+[m		[32mrenderer.setRenderTarget( cubeUVRenderTarget );[m
[32m+[m		[32mrenderer.render( scene, _flatCamera );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m_applyPMREM: function ( cubeUVRenderTarget ) {[m
[32m+[m
[32m+[m		[32mvar renderer = this._renderer;[m
[32m+[m		[32mvar autoClear = renderer.autoClear;[m
[32m+[m		[32mrenderer.autoClear = false;[m
[32m+[m
[32m+[m		[32mfor ( var i = 1; i < TOTAL_LODS; i ++ ) {[m
[32m+[m
[32m+[m			[32mvar sigma = Math.sqrt([m
[32m+[m				[32m_sigmas[ i ] * _sigmas[ i ] -[m
[32m+[m			[32m_sigmas[ i - 1 ] * _sigmas[ i - 1 ] );[m
[32m+[m			[32mvar poleAxis =[m
[32m+[m			[32m_axisDirections[ ( i - 1 ) % _axisDirections.length ];[m
[32m+[m			[32mthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mrenderer.autoClear = autoClear;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m/**[m
[32m+[m	[32m * This is a two-pass Gaussian blur for a cubemap. Normally this is done[m
[32m+[m	[32m * vertically and horizontally, but this breaks down on a cube. Here we apply[m
[32m+[m	[32m * the blur latitudinally (around the poles), and then longitudinally (towards[m
[32m+[m	[32m * the poles) to approximate the orthogonally-separable blur. It is least[m
[32m+[m	[32m * accurate at the poles, but still does a decent job.[m
[32m+[m	[32m */[m
[32m+[m	[32m_blur: function ( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {[m
[32m+[m
[32m+[m		[32mvar pingPongRenderTarget = this._pingPongRenderTarget;[m
[32m+[m
[32m+[m		[32mthis._halfBlur([m
[32m+[m			[32mcubeUVRenderTarget,[m
[32m+[m			[32mpingPongRenderTarget,[m
[32m+[m			[32mlodIn,[m
[32m+[m			[32mlodOut,[m
[32m+[m			[32msigma,[m
[32m+[m			[32m'latitudinal',[m
[32m+[m			[32mpoleAxis );[m
[32m+[m
[32m+[m		[32mthis._halfBlur([m
[32m+[m			[32mpingPongRenderTarget,[m
[32m+[m			[32mcubeUVRenderTarget,[m
[32m+[m			[32mlodOut,[m
[32m+[m			[32mlodOut,[m
[32m+[m			[32msigma,[m
[32m+[m			[32m'longitudinal',[m
[32m+[m			[32mpoleAxis );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m	[32m_halfBlur: function ( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {[m
[32m+[m
[32m+[m		[32mvar renderer = this._renderer;[m
[32m+[m		[32mvar blurMaterial = this._blurMaterial;[m
[32m+[m
[32m+[m		[32mif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {[m
[32m+[m
[32m+[m			[32mconsole.error([m
[32m+[m				[32m'blur direction must be either latitudinal or longitudinal!' );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32m// Number of standard deviations at which to cut off the discrete approximation.[m
[32m+[m		[32mvar STANDARD_DEVIATIONS = 3;[m
[32m+[m
[32m+[m		[32mvar blurScene = new Scene();[m
[32m+[m		[32mblurScene.add( new Mesh( _lodPlanes[ lodOut ], blurMaterial ) );[m
[32m+[m		[32mvar blurUniforms = blurMaterial.uniforms;[m
[32m+[m
[32m+[m		[32mvar pixels = _sizeLods[ lodIn ] - 1;[m
[32m+[m		[32mvar radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );[m
[32m+[m		[32mvar sigmaPixels = sigmaRadians / radiansPerPixel;[m
[32m+[m		[32mvar samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;[m
[32m+[m
[32m+[m		[32mif ( samples > MAX_SAMPLES ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( `sigmaRadians, ${[m
[32m+[m				[32msigmaRadians}, is too large and will clip, as it requested ${[m
[32m+[m				[32msamples} samples when the maximum is set to ${MAX_SAMPLES}` );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mvar weights = [];[m
[32m+[m		[32mvar sum = 0;[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < MAX_SAMPLES; ++ i ) {[m
[32m+[m
[32m+[m			[32mvar x = i / sigmaPixels;[m
[32m+[m			[32mvar weight = Math.exp( - x * x / 2 );[m
[32m+[m			[32mweights.push( weight );[m
[32m+[m
[32m+[m			[32mif ( i == 0 ) {[m
[32m+[m
[32m+[m				[32msum += weight;[m
[32m+[m
[32m+[m			[32m} else if ( i < samples ) {[m
[32m+[m
[32m+[m				[32msum += 2 * weight;[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mfor ( var i = 0; i < weights.length; i ++ ) {[m
[32m+[m
[32m+[m			[32mweights[ i ] = weights[ i ] / sum;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mblurUniforms[ 'envMap' ].value = targetIn.texture;[m
[32m+[m		[32mblurUniforms[ 'samples' ].value = samples;[m
[32m+[m		[32mblurUniforms[ 'weights' ].value = weights;[m
[32m+[m		[32mblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';[m
[32m+[m		[32mif ( poleAxis ) {[m
[32m+[m
[32m+[m			[32mblurUniforms[ 'poleAxis' ].value = poleAxis;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m		[32mblurUniforms[ 'dTheta' ].value = radiansPerPixel;[m
[32m+[m		[32mblurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;[m
[32m+[m		[32mblurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];[m
[32m+[m		[32mblurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];[m
[32m+[m
[32m+[m		[32mvar outputSize = _sizeLods[ lodOut ];[m
[32m+[m		[32mvar x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );[m
[32m+[m		[32mvar y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) +[m
[32m+[m		[32m2 * outputSize *[m
[32m+[m			[32m( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );[m
[32m+[m
[32m+[m		[32m_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );[m
[32m+[m		[32mrenderer.setRenderTarget( targetOut );[m
[32m+[m		[32mrenderer.render( blurScene, _flatCamera );[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mfunction _createPlanes() {[m
[32m+[m
[32m+[m	[32mvar _lodPlanes = [];[m
[32m+[m	[32mvar _sizeLods = [];[m
[32m+[m	[32mvar _sigmas = [];[m
[32m+[m
[32m+[m	[32mvar lod = LOD_MAX;[m
[32m+[m	[32mfor ( var i = 0; i < TOTAL_LODS; i ++ ) {[m
[32m+[m
[32m+[m		[32mvar sizeLod = Math.pow( 2, lod );[m
[32m+[m		[32m_sizeLods.push( sizeLod );[m
[32m+[m		[32mvar sigma = 1.0 / sizeLod;[m
[32m+[m		[32mif ( i > LOD_MAX - LOD_MIN ) {[m
[32m+[m
[32m+[m			[32msigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];[m
[32m+[m
[32m+[m		[32m} else if ( i == 0 ) {[m
[32m+[m
[32m+[m			[32msigma = 0;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m		[32m_sigmas.push( sigma );[m
[32m+[m
[32m+[m		[32mvar texelSize = 1.0 / ( sizeLod - 1 );[m
[32m+[m		[32mvar min = - texelSize / 2;[m
[32m+[m		[32mvar max = 1 + texelSize / 2;[m
[32m+[m		[32mvar uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];[m
[32m+[m
[32m+[m		[32mvar cubeFaces = 6;[m
[32m+[m		[32mvar vertices = 6;[m
[32m+[m		[32mvar positionSize = 3;[m
[32m+[m		[32mvar uvSize = 2;[m
[32m+[m		[32mvar faceIndexSize = 1;[m
[32m+[m
[32m+[m		[32mvar position = new Float32Array( positionSize * vertices * cubeFaces );[m
[32m+[m		[32mvar uv = new Float32Array( uvSize * vertices * cubeFaces );[m
[32m+[m		[32mvar faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );[m
[32m+[m
[32m+[m		[32mfor ( var face = 0; face < cubeFaces; face ++ ) {[m
[32m+[m
[32m+[m			[32mvar x = ( face % 3 ) * 2 / 3 - 1;[m
[32m+[m			[32mvar y = face > 2 ? 0 : - 1;[m
[32m+[m			[32mvar coordinates = [[m
[32m+[m				[32mx, y, 0,[m
[32m+[m				[32mx + 2 / 3, y, 0,[m
[32m+[m				[32mx + 2 / 3, y + 1, 0,[m
[32m+[m				[32mx, y, 0,[m
[32m+[m				[32mx + 2 / 3, y + 1, 0,[m
[32m+[m				[32mx, y + 1, 0[m
[32m+[m			[32m];[m
[32m+[m			[32mposition.set( coordinates, positionSize * vertices * face );[m
[32m+[m			[32muv.set( uv1, uvSize * vertices * face );[m
[32m+[m			[32mvar fill = [ face, face, face, face, face, face ];[m
[32m+[m			[32mfaceIndex.set( fill, faceIndexSize * vertices * face );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m		[32mvar planes = new BufferGeometry();[m
[32m+[m		[32mplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );[m
[32m+[m		[32mplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );[m
[32m+[m		[32mplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );[m
[32m+[m		[32m_lodPlanes.push( planes );[m
[32m+[m
[32m+[m		[32mif ( lod > LOD_MIN ) {[m
[32m+[m
[32m+[m			[32mlod --;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mreturn { _lodPlanes, _sizeLods, _sigmas };[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction _createRenderTarget( params ) {[m
[32m+[m
[32m+[m	[32mvar cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );[m
[32m+[m	[32mcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;[m
[32m+[m	[32mcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';[m
[32m+[m	[32mcubeUVRenderTarget.scissorTest = true;[m
[32m+[m	[32mreturn cubeUVRenderTarget;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction _setViewport( target, x, y, width, height ) {[m
[32m+[m
[32m+[m	[32mtarget.viewport.set( x, y, width, height );[m
[32m+[m	[32mtarget.scissor.set( x, y, width, height );[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction _getBlurShader( maxSamples ) {[m
[32m+[m
[32m+[m	[32mvar weights = new Float32Array( maxSamples );[m
[32m+[m	[32mvar poleAxis = new Vector3( 0, 1, 0 );[m
[32m+[m	[32mvar shaderMaterial = new RawShaderMaterial( {[m
[32m+[m
[32m+[m		[32mdefines: { 'n': maxSamples },[m
[32m+[m
[32m+[m		[32muniforms: {[m
[32m+[m			[32m'envMap': { value: null },[m
[32m+[m			[32m'samples': { value: 1 },[m
[32m+[m			[32m'weights': { value: weights },[m
[32m+[m			[32m'latitudinal': { value: false },[m
[32m+[m			[32m'dTheta': { value: 0 },[m
[32m+[m			[32m'mipInt': { value: 0 },[m
[32m+[m			[32m'poleAxis': { value: poleAxis },[m
[32m+[m			[32m'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },[m
[32m+[m			[32m'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }[m
[32m+[m		[32m},[m
[32m+[m
[32m+[m		[32mvertexShader: _getCommonVertexShader(),[m
[32m+[m
[32m+[m		[32mfragmentShader: `[m
[32m+[m[32mprecision mediump float;[m
[32m+[m[32mprecision mediump int;[m
[32m+[m[32mvarying vec3 vOutputDirection;[m
[32m+[m[32muniform sampler2D envMap;[m
[32m+[m[32muniform int samples;[m
[32m+[m[32muniform float weights[n];[m
[32m+[m[32muniform bool latitudinal;[m
[32m+[m[32muniform float dTheta;[m
[32m+[m[32muniform float mipInt;[m
[32m+[m[32muniform vec3 poleAxis;[m
[32m+[m
[32m+[m[32m${_getEncodings()}[m
[32m+[m
[32m+[m[32m#define ENVMAP_TYPE_CUBE_UV[m
[32m+[m[32m#include <cube_uv_reflection_fragment>[m
[32m+[m
[32m+[m[32mvec3 getSample(float theta, vec3 axis) {[m
[32m+[m	[32mfloat cosTheta = cos(theta);[m
[32m+[m	[32m// Rodrigues' axis-angle rotation[m
[32m+[m	[32mvec3 sampleDirection = vOutputDirection * cosTheta[m
[32m+[m		[32m+ cross(axis, vOutputDirection) * sin(theta)[m
[32m+[m		[32m+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);[m
[32m+[m	[32mreturn bilinearCubeUV(envMap, sampleDirection, mipInt);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid main() {[m
[32m+[m	[32mvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);[m
[32m+[m	[32mif (all(equal(axis, vec3(0.0))))[m
[32m+[m		[32maxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);[m
[32m+[m	[32maxis = normalize(axis);[m
[32m+[m	[32mgl_FragColor = vec4(0.0);[m
[32m+[m	[32mgl_FragColor.rgb += weights[0] * getSample(0.0, axis);[m
[32m+[m	[32mfor (int i = 1; i < n; i++) {[m
[32m+[m		[32mif (i >= samples)[m
[32m+[m			[32mbreak;[m
[32m+[m		[32mfloat theta = dTheta * float(i);[m
[32m+[m		[32mgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);[m
[32m+[m		[32mgl_FragColor.rgb += weights[i] * getSample(theta, axis);[m
[32m+[m	[32m}[m
[32m+[m	[32mgl_FragColor = linearToOutputTexel(gl_FragColor);[m
[32m+[m[32m}[m
[32m+[m		[32m`,[m
[32m+[m
[32m+[m		[32mblending: NoBlending,[m
[32m+[m		[32mdepthTest: false,[m
[32m+[m		[32mdepthWrite: false[m
[32m+[m
[32m+[m	[32m} );[m
[32m+[m
[32m+[m	[32mshaderMaterial.type = 'SphericalGaussianBlur';[m
[32m+[m
[32m+[m	[32mreturn shaderMaterial;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction _getEquirectShader() {[m
[32m+[m
[32m+[m	[32mvar texelSize = new Vector2( 1, 1 );[m
[32m+[m	[32mvar shaderMaterial = new RawShaderMaterial( {[m
[32m+[m
[32m+[m		[32muniforms: {[m
[32m+[m			[32m'envMap': { value: null },[m
[32m+[m			[32m'texelSize': { value: texelSize },[m
[32m+[m			[32m'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },[m
[32m+[m			[32m'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }[m
[32m+[m		[32m},[m
[32m+[m
[32m+[m		[32mvertexShader: _getCommonVertexShader(),[m
[32m+[m
[32m+[m		[32mfragmentShader: `[m
[32m+[m[32mprecision mediump float;[m
[32m+[m[32mprecision mediump int;[m
[32m+[m[32mvarying vec3 vOutputDirection;[m
[32m+[m[32muniform sampler2D envMap;[m
[32m+[m[32muniform vec2 texelSize;[m
[32m+[m
[32m+[m[32m${_getEncodings()}[m
[32m+[m
[32m+[m[32m#define RECIPROCAL_PI 0.31830988618[m
[32m+[m[32m#define RECIPROCAL_PI2 0.15915494[m
[32m+[m
[32m+[m[32mvoid main() {[m
[32m+[m	[32mgl_FragColor = vec4(0.0);[m
[32m+[m	[32mvec3 outputDirection = normalize(vOutputDirection);[m
[32m+[m	[32mvec2 uv;[m
[32m+[m	[32muv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;[m
[32m+[m	[32muv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;[m
[32m+[m	[32mvec2 f = fract(uv / texelSize - 0.5);[m
[32m+[m	[32muv -= f * texelSize;[m
[32m+[m	[32mvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;[m
[32m+[m	[32muv.x += texelSize.x;[m
[32m+[m	[32mvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;[m
[32m+[m	[32muv.y += texelSize.y;[m
[32m+[m	[32mvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;[m
[32m+[m	[32muv.x -= texelSize.x;[m
[32m+[m	[32mvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;[m
[32m+[m	[32mvec3 tm = mix(tl, tr, f.x);[m
[32m+[m	[32mvec3 bm = mix(bl, br, f.x);[m
[32m+[m	[32mgl_FragColor.rgb = mix(tm, bm, f.y);[m
[32m+[m	[32mgl_FragColor = linearToOutputTexel(gl_FragColor);[m
[32m+[m[32m}[m
[32m+[m		[32m`,[m
[32m+[m
[32m+[m		[32mblending: NoBlending,[m
[32m+[m		[32mdepthTest: false,[m
[32m+[m		[32mdepthWrite: false[m
[32m+[m
[32m+[m	[32m} );[m
[32m+[m
[32m+[m	[32mshaderMaterial.type = 'EquirectangularToCubeUV';[m
[32m+[m
[32m+[m	[32mreturn shaderMaterial;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction _getCubemapShader() {[m
[32m+[m
[32m+[m	[32mvar shaderMaterial = new RawShaderMaterial( {[m
[32m+[m
[32m+[m		[32muniforms: {[m
[32m+[m			[32m'envMap': { value: null },[m
[32m+[m			[32m'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },[m
[32m+[m			[32m'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }[m
[32m+[m		[32m},[m
[32m+[m
[32m+[m		[32mvertexShader: _getCommonVertexShader(),[m
[32m+[m
[32m+[m		[32mfragmentShader: `[m
[32m+[m[32mprecision mediump float;[m
[32m+[m[32mprecision mediump int;[m
[32m+[m[32mvarying vec3 vOutputDirection;[m
[32m+[m[32muniform samplerCube envMap;[m
[32m+[m
[32m+[m[32m${_getEncodings()}[m
[32m+[m
[32m+[m[32mvoid main() {[m
[32m+[m	[32mgl_FragColor = vec4(0.0);[m
[32m+[m	[32mgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;[m
[32m+[m	[32mgl_FragColor = linearToOutputTexel(gl_FragColor);[m
[32m+[m[32m}[m
[32m+[m		[32m`,[m
[32m+[m
[32m+[m		[32mblending: NoBlending,[m
[32m+[m		[32mdepthTest: false,[m
[32m+[m		[32mdepthWrite: false[m
[32m+[m
[32m+[m	[32m} );[m
[32m+[m
[32m+[m	[32mshaderMaterial.type = 'CubemapToCubeUV';[m
[32m+[m
[32m+[m	[32mreturn shaderMaterial;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction _getCommonVertexShader() {[m
[32m+[m
[32m+[m	[32mreturn `[m
[32m+[m[32mprecision mediump float;[m
[32m+[m[32mprecision mediump int;[m
[32m+[m[32mattribute vec3 position;[m
[32m+[m[32mattribute vec2 uv;[m
[32m+[m[32mattribute float faceIndex;[m
[32m+[m[32mvarying vec3 vOutputDirection;[m
[32m+[m[32mvec3 getDirection(vec2 uv, float face) {[m
[32m+[m	[32muv = 2.0 * uv - 1.0;[m
[32m+[m	[32mvec3 direction = vec3(uv, 1.0);[m
[32m+[m	[32mif (face == 0.0) {[m
[32m+[m		[32mdirection = direction.zyx;[m
[32m+[m		[32mdirection.z *= -1.0;[m
[32m+[m	[32m} else if (face == 1.0) {[m
[32m+[m		[32mdirection = direction.xzy;[m
[32m+[m		[32mdirection.z *= -1.0;[m
[32m+[m	[32m} else if (face == 3.0) {[m
[32m+[m		[32mdirection = direction.zyx;[m
[32m+[m		[32mdirection.x *= -1.0;[m
[32m+[m	[32m} else if (face == 4.0) {[m
[32m+[m		[32mdirection = direction.xzy;[m
[32m+[m		[32mdirection.y *= -1.0;[m
[32m+[m	[32m} else if (face == 5.0) {[m
[32m+[m		[32mdirection.xz *= -1.0;[m
[32m+[m	[32m}[m
[32m+[m	[32mreturn direction;[m
[32m+[m[32m}[m
[32m+[m[32mvoid main() {[m
[32m+[m	[32mvOutputDirection = getDirection(uv, faceIndex);[m
[32m+[m	[32mgl_Position = vec4( position, 1.0 );[m
[32m+[m[32m}[m
[32m+[m	[32m`;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction _getEncodings() {[m
[32m+[m
[32m+[m	[32mreturn `[m
[32m+[m[32muniform int inputEncoding;[m
[32m+[m[32muniform int outputEncoding;[m
[32m+[m
[32m+[m[32m#include <encodings_pars_fragment>[m
[32m+[m
[32m+[m[32mvec4 inputTexelToLinear(vec4 value){[m
[32m+[m	[32mif(inputEncoding == 0){[m
[32m+[m		[32mreturn value;[m
[32m+[m	[32m}else if(inputEncoding == 1){[m
[32m+[m		[32mreturn sRGBToLinear(value);[m
[32m+[m	[32m}else if(inputEncoding == 2){[m
[32m+[m		[32mreturn RGBEToLinear(value);[m
[32m+[m	[32m}else if(inputEncoding == 3){[m
[32m+[m		[32mreturn RGBMToLinear(value, 7.0);[m
[32m+[m	[32m}else if(inputEncoding == 4){[m
[32m+[m		[32mreturn RGBMToLinear(value, 16.0);[m
[32m+[m	[32m}else if(inputEncoding == 5){[m
[32m+[m		[32mreturn RGBDToLinear(value, 256.0);[m
[32m+[m	[32m}else{[m
[32m+[m		[32mreturn GammaToLinear(value, 2.2);[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvec4 linearToOutputTexel(vec4 value){[m
[32m+[m	[32mif(outputEncoding == 0){[m
[32m+[m		[32mreturn value;[m
[32m+[m	[32m}else if(outputEncoding == 1){[m
[32m+[m		[32mreturn LinearTosRGB(value);[m
[32m+[m	[32m}else if(outputEncoding == 2){[m
[32m+[m		[32mreturn LinearToRGBE(value);[m
[32m+[m	[32m}else if(outputEncoding == 3){[m
[32m+[m		[32mreturn LinearToRGBM(value, 7.0);[m
[32m+[m	[32m}else if(outputEncoding == 4){[m
[32m+[m		[32mreturn LinearToRGBM(value, 16.0);[m
[32m+[m	[32m}else if(outputEncoding == 5){[m
[32m+[m		[32mreturn LinearToRGBD(value, 256.0);[m
[32m+[m	[32m}else{[m
[32m+[m		[32mreturn LinearToGamma(value, 2.2);[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvec4 envMapTexelToLinear(vec4 color) {[m
[32m+[m	[32mreturn inputTexelToLinear(color);[m
[32m+[m[32m}[m
[32m+[m	[32m`;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
 /**[m
  * @author mrdoob / http://mrdoob.com/[m
  */[m
[36m@@ -47247,8 +48032,10 @@[m [mfunction Face4( a, b, c, d, normal, color, materialIndex ) {[m
 }[m
 [m
 var LineStrip = 0;[m
[31m-[m
 var LinePieces = 1;[m
[32m+[m[32mvar NoColors = 0;[m
[32m+[m[32mvar FaceColors = 1;[m
[32m+[m[32mvar VertexColors = 2;[m
 [m
 function MeshFaceMaterial( materials ) {[m
 [m
[36m@@ -47326,8 +48113,8 @@[m [mfunction Vertex( x, y, z ) {[m
 [m
 function DynamicBufferAttribute( array, itemSize ) {[m
 [m
[31m-	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );[m
[31m-	return new BufferAttribute( array, itemSize ).setDynamic( true );[m
[32m+[m	[32mconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );[m
[32m+[m	[32mreturn new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );[m
 [m
 }[m
 [m
[36m@@ -47460,7 +48247,7 @@[m [mObject.assign( Path.prototype, {[m
 	fromPoints: function ( points ) {[m
 [m
 		console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );[m
[31m-		this.setFromPoints( points );[m
[32m+[m		[32mreturn this.setFromPoints( points );[m
 [m
 	}[m
 [m
[36m@@ -47686,6 +48473,13 @@[m [mObject.assign( Box3.prototype, {[m
 	}[m
 } );[m
 [m
[32m+[m[32mFrustum.prototype.setFromMatrix = function ( m ) {[m
[32m+[m
[32m+[m	[32mconsole.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );[m
[32m+[m	[32mreturn this.setFromProjectionMatrix( m );[m
[32m+[m
[32m+[m[32m};[m
[32m+[m
 Line3.prototype.center = function ( optionalTarget ) {[m
 [m
 	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );[m
[36m@@ -47693,7 +48487,7 @@[m [mLine3.prototype.center = function ( optionalTarget ) {[m
 [m
 };[m
 [m
[31m-Object.assign( _Math, {[m
[32m+[m[32mObject.assign( MathUtils, {[m
 [m
 	random16: function () {[m
 [m
[36m@@ -47705,14 +48499,14 @@[m [mObject.assign( _Math, {[m
 	nearestPowerOfTwo: function ( value ) {[m
 [m
 		console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );[m
[31m-		return _Math.floorPowerOfTwo( value );[m
[32m+[m		[32mreturn MathUtils.floorPowerOfTwo( value );[m
 [m
 	},[m
 [m
 	nextPowerOfTwo: function ( value ) {[m
 [m
 		console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );[m
[31m-		return _Math.ceilPowerOfTwo( value );[m
[32m+[m		[32mreturn MathUtils.ceilPowerOfTwo( value );[m
 [m
 	}[m
 [m
[36m@@ -47737,10 +48531,10 @@[m [mObject.assign( Matrix3.prototype, {[m
 		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );[m
 [m
 	},[m
[31m-	applyToBuffer: function ( buffer /*, offset, length */ ) {[m
[32m+[m	[32mapplyToBufferAttribute: function ( attribute ) {[m
 [m
[31m-		console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );[m
[31m-		return this.applyToBufferAttribute( buffer );[m
[32m+[m		[32mconsole.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );[m
[32m+[m		[32mreturn attribute.applyMatrix3( this );[m
 [m
 	},[m
 	applyToVector3Array: function ( /* array, offset, length */ ) {[m
[36m@@ -47836,10 +48630,10 @@[m [mObject.assign( Matrix4.prototype, {[m
 		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );[m
 [m
 	},[m
[31m-	applyToBuffer: function ( buffer /*, offset, length */ ) {[m
[32m+[m	[32mapplyToBufferAttribute: function ( attribute ) {[m
 [m
[31m-		console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );[m
[31m-		return this.applyToBufferAttribute( buffer );[m
[32m+[m		[32mconsole.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );[m
[32m+[m		[32mreturn attribute.applyMatrix4( this );[m
 [m
 	},[m
 	applyToVector3Array: function ( /* array, offset, length */ ) {[m
[36m@@ -48078,6 +48872,12 @@[m [mObject.assign( Geometry.prototype, {[m
 [m
 		console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );[m
 [m
[32m+[m	[32m},[m
[32m+[m	[32mapplyMatrix: function ( matrix ) {[m
[32m+[m
[32m+[m		[32mconsole.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );[m
[32m+[m		[32mreturn this.applyMatrix4( matrix );[m
[32m+[m
 	}[m
 [m
 } );[m
[36m@@ -48105,6 +48905,12 @@[m [mObject.assign( Object3D.prototype, {[m
 [m
 		console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );[m
 [m
[32m+[m	[32m},[m
[32m+[m	[32mapplyMatrix: function ( matrix ) {[m
[32m+[m
[32m+[m		[32mconsole.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );[m
[32m+[m		[32mreturn this.applyMatrix4( matrix );[m
[32m+[m
 	}[m
 [m
 } );[m
[36m@@ -48140,6 +48946,34 @@[m [mObject.defineProperties( Object3D.prototype, {[m
 [m
 } );[m
 [m
[32m+[m[32mObject.assign( Mesh.prototype, {[m
[32m+[m
[32m+[m	[32msetDrawMode: function () {[m
[32m+[m
[32m+[m		[32mconsole.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m
[32m+[m[32m} );[m
[32m+[m
[32m+[m[32mObject.defineProperties( Mesh.prototype, {[m
[32m+[m
[32m+[m	[32mdrawMode: {[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mconsole.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );[m
[32m+[m			[32mreturn TrianglesDrawMode;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m		[32mset: function () {[m
[32m+[m
[32m+[m			[32mconsole.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m[32m} );[m
[32m+[m
 Object.defineProperties( LOD.prototype, {[m
 [m
 	objects: {[m
[36m@@ -48319,29 +49153,43 @@[m [mObject.defineProperties( BufferAttribute.prototype, {[m
 			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );[m
 			return this.array.length;[m
 [m
[32m+[m		[32m}[m
[32m+[m	[32m},[m
[32m+[m	[32mdynamic: {[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );[m
[32m+[m			[32mreturn this.usage === DynamicDrawUsage;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m		[32mset: function ( /* value */ ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );[m
[32m+[m			[32mthis.setUsage( DynamicDrawUsage );[m
[32m+[m
 		}[m
 	}[m
 [m
 } );[m
 [m
 Object.assign( BufferAttribute.prototype, {[m
[32m+[m	[32msetDynamic: function ( value ) {[m
 [m
[32m+[m		[32mconsole.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );[m
[32m+[m		[32mthis.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
 	copyIndicesArray: function ( /* indices */ ) {[m
 [m
 		console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );[m
 [m
 	},[m
[31m-	setArray: function ( array ) {[m
[31m-[m
[31m-		console.warn( 'THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );[m
[32m+[m	[32msetArray: function ( /* array */ ) {[m
 [m
[31m-		this.count = array !== undefined ? array.length / this.itemSize : 0;[m
[31m-		this.array = array;[m
[31m-[m
[31m-		return this;[m
[32m+[m		[32mconsole.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );[m
 [m
 	}[m
[31m-[m
 } );[m
 [m
 Object.assign( BufferGeometry.prototype, {[m
[36m@@ -48351,6 +49199,30 @@[m [mObject.assign( BufferGeometry.prototype, {[m
 		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );[m
 		this.setIndex( index );[m
 [m
[32m+[m	[32m},[m
[32m+[m	[32maddAttribute: function ( name, attribute ) {[m
[32m+[m
[32m+[m		[32mconsole.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );[m
[32m+[m
[32m+[m		[32mif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );[m
[32m+[m
[32m+[m			[32mreturn this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif ( name === 'index' ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );[m
[32m+[m			[32mthis.setIndex( attribute );[m
[32m+[m
[32m+[m			[32mreturn this;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mreturn this.setAttribute( name, attribute );[m
[32m+[m
 	},[m
 	addDrawCall: function ( start, count, indexOffset ) {[m
 [m
[36m@@ -48378,6 +49250,19 @@[m [mObject.assign( BufferGeometry.prototype, {[m
 [m
 		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );[m
 [m
[32m+[m	[32m},[m
[32m+[m	[32mremoveAttribute: function ( name ) {[m
[32m+[m
[32m+[m		[32mconsole.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );[m
[32m+[m
[32m+[m		[32mreturn this.deleteAttribute( name );[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m	[32mapplyMatrix: function ( matrix ) {[m
[32m+[m
[32m+[m		[32mconsole.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );[m
[32m+[m		[32mreturn this.applyMatrix4( matrix );[m
[32m+[m
 	}[m
 [m
 } );[m
[36m@@ -48403,21 +49288,59 @@[m [mObject.defineProperties( BufferGeometry.prototype, {[m
 [m
 } );[m
 [m
[31m-Object.assign( InterleavedBuffer.prototype, {[m
[32m+[m[32mObject.defineProperties( Raycaster.prototype, {[m
[32m+[m
[32m+[m	[32mlinePrecision: {[m
[32m+[m		[32mget: function () {[m
 [m
[31m-	setArray: function ( array ) {[m
[32m+[m			[32mconsole.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );[m
[32m+[m			[32mreturn this.params.Line.threshold;[m
 [m
[31m-		console.warn( 'THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );[m
[32m+[m		[32m},[m
[32m+[m		[32mset: function ( value ) {[m
 [m
[31m-		this.count = array !== undefined ? array.length / this.stride : 0;[m
[31m-		this.array = array;[m
[32m+[m			[32mconsole.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );[m
[32m+[m			[32mthis.params.Line.threshold = value;[m
 [m
[31m-		return this;[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m[32m} );[m
 [m
[32m+[m[32mObject.defineProperties( InterleavedBuffer.prototype, {[m
[32m+[m
[32m+[m	[32mdynamic: {[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );[m
[32m+[m			[32mreturn this.usage === DynamicDrawUsage;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m		[32mset: function ( value ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );[m
[32m+[m			[32mthis.setUsage( value );[m
[32m+[m
[32m+[m		[32m}[m
 	}[m
 [m
 } );[m
 [m
[32m+[m[32mObject.assign( InterleavedBuffer.prototype, {[m
[32m+[m	[32msetDynamic: function ( value ) {[m
[32m+[m
[32m+[m		[32mconsole.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );[m
[32m+[m		[32mthis.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );[m
[32m+[m		[32mreturn this;[m
[32m+[m
[32m+[m	[32m},[m
[32m+[m	[32msetArray: function ( /* array */ ) {[m
[32m+[m
[32m+[m		[32mconsole.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m[32m} );[m
[32m+[m
 //[m
 [m
 Object.assign( ExtrudeBufferGeometry.prototype, {[m
[36m@@ -48767,6 +49690,41 @@[m [mObject.defineProperties( WebGLRenderer.prototype, {[m
 			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );[m
 			return this.getContext();[m
 [m
[32m+[m		[32m}[m
[32m+[m	[32m},[m
[32m+[m	[32mvr: {[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );[m
[32m+[m			[32mreturn this.xr;[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m	[32m},[m
[32m+[m	[32mgammaInput: {[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );[m
[32m+[m			[32mreturn false;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m		[32mset: function () {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m	[32m},[m
[32m+[m	[32mgammaOutput: {[m
[32m+[m		[32mget: function () {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );[m
[32m+[m			[32mreturn false;[m
[32m+[m
[32m+[m		[32m},[m
[32m+[m		[32mset: function ( value ) {[m
[32m+[m
[32m+[m			[32mconsole.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );[m
[32m+[m			[32mthis.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;[m
[32m+[m
 		}[m
 	}[m
 [m
[36m@@ -48816,26 +49774,12 @@[m [mObject.defineProperties( WebGLShadowMap.prototype, {[m
 [m
 } );[m
 [m
[31m-//[m
[31m-[m
[31m-Object.defineProperties( WebGLRenderTargetCube.prototype, {[m
[31m-[m
[31m-	activeCubeFace: {[m
[31m-		set: function ( /* value */ ) {[m
[31m-[m
[31m-			console.warn( 'THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().' );[m
[31m-[m
[31m-		}[m
[31m-	},[m
[31m-	activeMipMapLevel: {[m
[31m-		set: function ( /* value */ ) {[m
[32m+[m[32mfunction WebGLRenderTargetCube( width, height, options ) {[m
 [m
[31m-			console.warn( 'THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().' );[m
[32m+[m	[32mconsole.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );[m
[32m+[m	[32mreturn new WebGLCubeRenderTarget( width, options );[m
 [m
[31m-		}[m
[31m-	}[m
[31m-[m
[31m-} );[m
[32m+[m[32m}[m
 [m
 //[m
 [m
[36m@@ -48986,41 +49930,33 @@[m [mObject.defineProperties( WebGLRenderTarget.prototype, {[m
 [m
 //[m
 [m
[31m-Object.defineProperties( WebVRManager.prototype, {[m
[32m+[m[32mObject.defineProperties( Audio.prototype, {[m
 [m
[31m-	standing: {[m
[31m-		set: function ( /* value */ ) {[m
[32m+[m	[32mload: {[m
[32m+[m		[32mvalue: function ( file ) {[m
 [m
[31m-			console.warn( 'THREE.WebVRManager: .standing has been removed.' );[m
[32m+[m			[32mconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );[m
[32m+[m			[32mvar scope = this;[m
[32m+[m			[32mvar audioLoader = new AudioLoader();[m
[32m+[m			[32maudioLoader.load( file, function ( buffer ) {[m
[32m+[m
[32m+[m				[32mscope.setBuffer( buffer );[m
[32m+[m
[32m+[m			[32m} );[m
[32m+[m			[32mreturn this;[m
 [m
 		}[m
 	},[m
[31m-	userHeight: {[m
[31m-		set: function ( /* value */ ) {[m
[32m+[m	[32mstartTime: {[m
[32m+[m		[32mset: function () {[m
 [m
[31m-			console.warn( 'THREE.WebVRManager: .userHeight has been removed.' );[m
[32m+[m			[32mconsole.warn( 'THREE.Audio: .startTime is now .play( delay ).' );[m
 [m
 		}[m
 	}[m
 [m
 } );[m
 [m
[31m-//[m
[31m-[m
[31m-Audio.prototype.load = function ( file ) {[m
[31m-[m
[31m-	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );[m
[31m-	var scope = this;[m
[31m-	var audioLoader = new AudioLoader();[m
[31m-	audioLoader.load( file, function ( buffer ) {[m
[31m-[m
[31m-		scope.setBuffer( buffer );[m
[31m-[m
[31m-	} );[m
[31m-	return this;[m
[31m-[m
[31m-};[m
[31m-[m
 AudioAnalyser.prototype.getData = function () {[m
 [m
 	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );[m
[36m@@ -49134,19 +50070,19 @@[m [mvar SceneUtils = {[m
 [m
 	createMultiMaterialObject: function ( /* geometry, materials */ ) {[m
 [m
[31m-		console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );[m
[32m+[m		[32mconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );[m
 [m
 	},[m
 [m
 	detach: function ( /* child, parent, scene */ ) {[m
 [m
[31m-		console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );[m
[32m+[m		[32mconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );[m
 [m
 	},[m
 [m
 	attach: function ( /* child, scene, parent */ ) {[m
 [m
[31m-		console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );[m
[32m+[m		[32mconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );[m
 [m
 	}[m
 [m
[36m@@ -49156,7 +50092,7 @@[m [mvar SceneUtils = {[m
 [m
 function LensFlare() {[m
 [m
[31m-	console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );[m
[32m+[m	[32mconsole.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );[m
 [m
 }[m
 [m
[36m@@ -49170,4 +50106,4 @@[m [mif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {[m
 [m
 }[m
 [m
[31m-export { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, BoxGeometry as CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DirectionalLightShadow, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FaceNormalsHelper, FileLoader, FlatShading, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontFaceDirectionCCW, FrontFaceDirectionCW, FrontSide, Frustum, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, LightProbeHelper, LightShadow, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, _Math as Math, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PositionalAudioHelper, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RectAreaLightHelper, RedFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SphericalReflectionMapping, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpotLightShadow, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StereoCamera, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uncharted2ToneMapping, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VertexNormalsHelper, VideoTexture, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding };[m
[32m+[m[32mexport { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, BoxGeometry as CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DirectionalLightShadow, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FileLoader, FlatShading, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontFaceDirectionCCW, FrontFaceDirectionCW, FrontSide, Frustum, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, LightShadow, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils as Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SphericalReflectionMapping, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpotLightShadow, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uncharted2ToneMapping, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding };[m
